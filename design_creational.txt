Design Patterns in Java: Creational (Bryan Hansen)

why to learn patterns: means of communicating problems to other dev, common vocabulary, abstract topic: not look-at and memorize

pattern groups: creational/structural/behavioural
creational: how objects are created
singleton, builder, prototype, factory, abstract factory

===
[Singleton Pattern]

concept
only one instance created guarantees control of an rsc: az instantiationt a pattern impl kontrollalja
usually lazily loaded
pl. runtime, logger (factory is lehet), Spring beans, graphics managers

class is resp to create itself and manage its lifecycle
static in nature, bar alt nem static classal impl, mert threadsafenek kell lennie es a static azt nem szuksegkeppen garantalja
private Singleton singleton; private Singleton(); public Singleton getInstance();
konstrnak nincs paramja van; ha van neki, akkor az valszeg inkabb factory lesz

Runtime singleton = Runtime.getRuntime(); singleton.gc(); sout(singleton); Runtime another = Runtime.getRuntime(); sout(another); if(singleton == another) sout("they are the same"); 
a ket obj addresse uaz

demo
public class DBSingleton {
  private static DBSingleton instance = new DBSingleton(); //most meg nem fogl lazy load, threadsafe stb-vel
  private DBSingleton() {} //csak mi krealhatunk belole. pl. DBSingletonDemo-bol nem tudjuk new-zni
  public static getInstance() { return instance; }

class DBSingletonDemo { 
  main() { DBSingleton instance = DBSingleton.getInstance(); sout(instance); DBSingleton another = DBSingleton.getInstance(); sout(another); //uaz az address lesz

ez eddig eagerly loaded volt, betoltodott a JVM startupkor
public class DBSingleton {
  private static DBSingleton instance = null;
  private DBSingleton() {} 
  public static getInstance() { if(instance==null) { instance = new DBSingleton(); } return instance; }
igy mar lazily loaded
nagy appoknal az eager load mar ktges lesz, es jo esellyel nem fogunk mindent mar a startupkor hasznalni. lazy load jo esellyel perf++
  
tegyuk threadsafe-e. nem jelent akkora perf-- hogy egyebkent ne erne meg
nem megyunk bele a kulonbozo sync lehetosegekbe bovebben
public static getInstance() { if(instance==null) { synchronized(DBSingleton.class) { if(instance == null) { instance = new DBSingleton(); } } return instance; }
a kulso if a syncen kivul van; ha ott !=null akkor nem erdekes h threadsafe-e, csak returnoljuk az instanceot; igy csokkentjuk a sync okozta perf hitet (ezert nem tesszuk a teljes getInstance() metodust syncce mert akkor minden egyes accessnel meg kellene fiz a sync ktget). igazabol csak a legelso hivaskor, a tenyleges krealaskor erdekes a sync h akkor ne legyen race cond

Derby hozzaadas
private konstruktorban DriverManager.registerDriver()
uj field: private Connection conn = null;
public Connection getConnection() { //instance metodus, nem static! instance.getConnection() formaban hivjuk a DBSingletonDemo-bol
  if(conn=null) { synchronized(DBSingleton.class) { if(conn==null) {conn = DriverManager.getConnection(dbUrl);} } return conn; }

class DBSingletonDemo { 
  main() { 
    DBSingleton instance = DBSingleton.getInstance();
    Connection conn = instance.getConnection(); //kimerve ez ~460 ms
    stmt = conn.createStatement(...); //create table...
    Connection conn = instance.getConnection(); //meg 1x meghivjuk a conn krealast. kimerve ez itt 0ms. compiler kioptimalizalta, latta h uaz az instance

pitfalls
overused. don't abuse, nem kell minden singletonna tennunk. az perf-- is okozhat
nehez unit testelni mert nem exposolnak ifacet
ha nem ugy impl akkor nem threadsafek
gyakran staticcal indulnak neki, es a vegen vmi mas lesz belole. okolszabaly, ha getInstance paramo(ka)t vesz at akkor az mar nem singleton hanem inkabb factory
java.util.Calendar nem singleton inkabb prototype, mert minden hivaskor new instance (getInstance() metodusa van, azert szoktak keverni)

singleton vs factory
singleton: returns same instance. one "constructor method" with no args. no iface exposed, private field, private konstr
factory: returns various instances (multiple objs of various types). multiple konstr to get those instances. alt iface-driven to abstract out (=> egyszerubb unit testelni). adapt to env more easily mint a singleton

===
[Builder Pattern]
gyakran haszn, de ritkan krealjuk mi magunk. sokparamos objk krealasara, amiket immut akarunk tenni miutan megkrealtuk
