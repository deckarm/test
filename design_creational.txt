Design Patterns in Java: Creational (Bryan Hansen)

why to learn patterns: means of communicating problems to other dev, common vocabulary, abstract topic: not look-at and memorize

pattern groups: creational/structural/behavioural
creational: how objects are created
singleton, builder, prototype, factory, abstract factory

===
[Singleton Pattern]
concepts
only one instance created 
guarantees control of an rsc: az instantiationt a pattern impl kontrollalja
usually lazily loaded
pl. runtime, logger (factory is lehet), Spring beans, graphics managers

design
class is resp to create itself and manage its lifecycle
static in nature, bar alt nem static classal impl, mert threadsafenek kell lennie es a static azt nem szuksegkeppen garantalja
private Singleton singleton; private Singleton(); public Singleton getInstance();
konstrnak nincs paramja van; ha van neki, akkor az valszeg inkabb factory lesz

Runtime singleton = Runtime.getRuntime(); singleton.gc(); sout(singleton); Runtime another = Runtime.getRuntime(); sout(another); if(singleton == another) sout("they are the same"); 
a ket obj addresse uaz

demo
public class DBSingleton {
  private static DBSingleton instance = new DBSingleton(); //most meg nem fogl lazy load, threadsafe stb-vel
  private DBSingleton() {} //csak mi krealhatunk belole. pl. DBSingletonDemo-bol nem tudjuk new-zni
  public static getInstance() { return instance; }

class DBSingletonDemo { 
  main() { DBSingleton instance = DBSingleton.getInstance(); sout(instance); DBSingleton another = DBSingleton.getInstance(); sout(another); //uaz az address lesz

ez eddig eagerly loaded volt, betoltodott a JVM startupkor
public class DBSingleton {
  private static DBSingleton instance = null;
  private DBSingleton() {} 
  public static getInstance() { if(instance==null) { instance = new DBSingleton(); } return instance; }
igy mar lazily loaded
nagy appoknal az eager load mar ktges lesz, es jo esellyel nem fogunk mindent mar a startupkor hasznalni. lazy load jo esellyel perf++
  
tegyuk threadsafe-e. nem jelent akkora perf-- hogy egyebkent ne erne meg
nem megyunk bele a kulonbozo sync lehetosegekbe bovebben
public static getInstance() { if(instance==null) { synchronized(DBSingleton.class) { if(instance == null) { instance = new DBSingleton(); } } return instance; }
a kulso if a syncen kivul van; ha ott !=null akkor nem erdekes h threadsafe-e, csak returnoljuk az instanceot; igy csokkentjuk a sync okozta perf hitet (ezert nem tesszuk a teljes getInstance() metodust syncce mert akkor minden egyes accessnel meg kellene fiz a sync ktget). igazabol csak a legelso hivaskor, a tenyleges krealaskor erdekes a sync h akkor ne legyen race cond

Derby hozzaadas
private konstruktorban DriverManager.registerDriver()
uj field: private Connection conn = null;
public Connection getConnection() { //instance metodus, nem static! instance.getConnection() formaban hivjuk a DBSingletonDemo-bol
  if(conn=null) { synchronized(DBSingleton.class) { if(conn==null) {conn = DriverManager.getConnection(dbUrl);} } return conn; }

class DBSingletonDemo { 
  main() { 
    DBSingleton instance = DBSingleton.getInstance();
    Connection conn = instance.getConnection(); //kimerve ez ~460 ms
    stmt = conn.createStatement(...); //create table...
    Connection conn = instance.getConnection(); //meg 1x meghivjuk a conn krealast. kimerve ez itt 0ms. compiler kioptimalizalta, latta h uaz az instance

pitfalls
overused. don't abuse, nem kell minden singletonna tennunk. az perf-- is okozhat
nehez unit testelni mert nem exposolnak ifacet
ha nem ugy impl akkor nem threadsafek
gyakran staticcal indulnak neki, es a vegen vmi mas lesz belole. okolszabaly, ha getInstance paramo(ka)t vesz at akkor az mar nem singleton hanem inkabb factory
java.util.Calendar nem singleton inkabb factory, mert minden hivaskor new instance (getInstance() metodusa van, azert szoktak keverni)

singleton vs factory
singleton: returns same instance. one "constructor method" with no args. no iface exposed, private field, private konstr. no subclasses
factory: returns various instances (multiple objs of various types). multiple konstr to get those instances (vagy param segitsegevel vezerelve, ld. getWebsite() pelda lentebb). alt iface/contract-driven to abstract out (=> egyszerubb unit testelni). always subclasses. adapt to env more easily mint a singleton (sok fwben hasznaljak, es per-env implhatjuk aszerint ahogy haszn szeretnenk)

===
[Builder Pattern]
concepts
gyakran haszn, de ritkan krealjuk mi magunk. sokparamos objk krealasara, amiket immut akarunk tenni miutan megkrealtuk
pl. StringBuilder, DocumentBuilder, Locale.Builder

design
gyakran tobb konstr van, klf param listakkal (telescoping constructors). builder ezt segit kezelni
builder gyakran static inner class, a buildelt obj egy instancet adja vissza
nem jelenti azt h nincs szukseg konstruktorokra: calls appropriate konstruktor
foloslegesse teszi viszont minden setter kiexposolasat, ami antipattern

StringBuilder builder = new StringBuilder(); builder.append("this is an example"); builder.append(42); sout(builder.toString());
String + vagy concat() helyett. jobb perf mint a sync StringBuffer

public class LaunchOrderBean { String bread, condiments, dressing, meat + default noarg konstr + getterek/setterek 
nem immut mert a setterek exposolva vannak
nem tiszta h mi a class contractja. pl. launchOrderBean = new LaunchOrderBean(); sout(launchOrderBean.getBread()); ez is lefut csak nullt ir ki

public class LaunchOrderTele { //uezek a fieldek + 1-2-3-4 paramos konstruktorok + csak getterek
konstruktorok this()-el hivjak egymast pl. public LunchOrderTele(String bread, String condiments) { this(bread); this.condiments = condiments; }
ez igy immut, de mi van akkor ha csak breadet es meatet akarok? olyan konstruktorunk nincs

public class LunchOrder {
  public static class Builder {
    //uazok a fieldek mint az outer classban. mert a builder a sajat maga containere (?)
	public Builder() {} //ha lennenek argjai, azzal enforcolhatnank h pl. a bread kotelezo minden lunchban
	public Builder bread(String bread) { this.bread = bread; return this; }  //magat a krealt Builder objt returnoljuk
	//+uilyen, Buildert returnolo metodusok a tobbi fieldre is
	//typesafe enumokat is hasznalhatnank
	public LunchOrder build() { return new LunchOrder(this); } //a LunchOrder konstrja Buildert vesz at
  }
  private LunchOrder(Builder builder) { this.bread = builder.bread; //+ uigy setteljuk be a tobbi mezot is }
  //+csak getterek

class Demo { LunchOrder.Builder builder = new LunchOrder.Builder(); builder.bread("Wheat").condiments("Lettuce").dressing("Moyo").meat("Turkey"); LunchOrder lunchOrder = builder.build(); sout(lunchOrder.getBread()); ...
ez igy otvozi a konstruktoros mo contractolhatosagat es immutjat a beanes mo flexibilitasaval. builder.bread("Wheat").meat("Turkey"); ugyanugy OK

pitfalls
nem sok van, talan az additional complexity a sima konstrhoz kepest

builder vs prototype
builder: _handles_ complex constructors. no iface required. lehet separate class (bar inkabb alt a buildelendo class inner classa), emiatt jol mukodik legacy koddal is
prototype: implemented around clone(). _avoids_ calling complex/costly constructors. mivel a clone() member varokra es konstrkra fokuszal, ezert a klonozando classon belul van impl, ami nehezze teszi a legacy koddal valo mukodest

===
[Prototype Pattern]
krealando obj typejat egy proto instance determinalja, amit leklonozunk az uj instance krealasahoz. gyakran arra haszn h legyen egy unique instance uabbol az objbol

concepts
avoids costly creation (gyakran refactoring patternkent gondolnak ra, nem upfront designkent). avoids subclassing. tip don't use "new" (hanem clone). often utilizes iface. ususally implemented with registry (ori objt ott tartjuk es onnan krealjuk a klont)
pl. java.lang.Object.clone()

design
jo valasztas, ha egy obj krealasa draga, de a member varok copyzasaval megkapjuk amit szeretnenk
tip impl a Cloneable ifacet es keruli a new keywordot
although a copy, each instance is unique
costly construction not handled by the client (vs builder)
can utilize params for construction (vs singleton), de tip nincs ra szukseg
shallow vs deep copy: csak immediate propertyket vs obj refeket is

pl. DB statement krealas draga, foleg ha uazt a queryt szeretnenk ujrafuttatni csak mas paramokkal
class Statement implements Cloneable {
  public Statement(String sql, List<String> params, Record record) { this.sql = sql;...
  public Statement clone() {  try { return (Statement) super.clone(); } catch(CloneNotSupportedException e) {} return null; }

class Demo { String sql = "..."; List<String> parameters = new ArrayList<>(); parameters.add(...); Record record = new Record(); Statement first = new Statement(sql, parameters, record); Statement second = first.clone(); => sout get-fieldek. figyeljunk h a record mezore firstbol es secondbol is uazt a Record@... cimet irja ki
ez egy shallow copy, a beadott fieldek refjeit adta vissza. deep copynal egy uj parameters arraylistet es egy uj Record objt adna vissza
shallow veszelyes mert ha itt pl. megvaltoztatnank a parameters lista elemeit az a firstben es a secondban is tukrozodne

demo
pl. ha amazon az oldalan minden itemhez krealna es kitoltene egy objt az nagyon draga lenne
public abstract class Item implements Cloneable { 
  String title, double price, String url;
  protected Object clone() throws CloneNotSupportedException { return super.clone(); //ha a sub-objectjeinkben nincs semmi unique akkor ez megfelel klonozaskent (mint pl. most)
public class Book extends Item { int numberOfPages;
public class Movie extends Item { String runtime;

public class Registry { 
  private Map<String, Item> items = new Hashmap<>(); //enum jobb lenne keykent
  public Registry() { loadItems(); }
  public Item createItem(String type) { 
    Item item = null; 
	try { item = (Item) items.get(type)).clone(); } //castolas kell, mert az iface metodus Objectet returnol (Cloneable Java 1.0 iface, amikor meg nem volt generics; emiatt lehet azon gondolkozni h sajat ifacet hasznaljunk inkabb helyette)
	catch(CloneNotSupportedException e) {} 
	return item; 
  private void loadItems() { movie = new Movie(); movie.setTitle(...); ... items.put("Movie", movie); book = new Book(); book.setTitle(...); ... items.put("Book", book); } //default field ertekekkel feltoltott prototipus objk a registryben. csak itt vannak a new-k az appban
  
public class Demo { 
  registry = new Registry(); 
  movie = (Movie) registry.createItem("Movie"); //ez lefuttatja a registry clone()-t es leklonozza a prototipus movie objt a registrybol...
  movie.setTitle("sometitle"); //...es itt tetszolegesen overrideolhatjuk a mezoit, anelkul h new-znank
  another = (Movie) registry.createItem("Movie"); 
  movie.setTitle("anothertitle"); 
nem kell minden alkalommal uj objt krealnunk , lightweight
mindket krealt Movie instance unique lesz, latszik ha kiiratjuk az addressuket
  
pitfalls
sometimes not clear when to use (vs singleton overuse). used with other patterns (pl. registry. loose def: if a pattern contains other patterns it is already a fw). alapbol csak shallow copy, deep copyhoz pluszban kodolnunk kell, es ilyenkor mar megkerdejelezodik h van-e a patternek ertelme

prototype vs factory  
prototype: lightweight construction (copy constr v clone()). shallow v deep copy valaszthato. copy of itself
factory: flexible objects (multiple constructors). concrete instance. fresh instance (new, nem defaultbol mint a prototypenal)
gondoljuk vegig h ahol factoryt akarnank hasznalni, oda nem lenne-e jo a prototype

===
[Factory Method Pattern]
concepts
doesnt expose instantion logic (a client gyak semmit nem tud, meg a krealt obj typejat sem). defer instantiation to subclasses. client csak a factory altal exposolt common ifacet ismeri. gyakran specified by architecture/fw + impl by the user
pl. Calendar, ResourceBundle, NumberFormat (ahogy mar emlitettuk, a Calendar nem singleton: van ugyan parameter nelkuli getInstance() metodusa, de klf subclassokat tud returnolni, a client nem tudja h mit kap)

design
responsible for creating objs and managing the lifecycle
created objs referenced through common iface
multiple concrete classes/impls, de a clientek ezekrol nem tudnak, csak a common ifacerol
tip parameterized create method => param determinalja h milyen concrete impl lesz returnolve (pl. Calendar.getInstance(TimeZone/Locale))

Calendar cal = Calendar.getInstance(); sout(cal); //konkret impl returnolve, pl. GregorianCalendar

demo
public abstract class Page {}
public class CartPage/AboutPage/ContactPage... extends Page {

public abstract class Website {
  protected List<Page> pages = new ArrayList<>(); //+getter
  public Website() { this.createWebsite(); }
  public abstract void createWebsite(); //a konkret classok ezt fogjak overridolni
  
public class Blog extends Website { public void createWebsite() { pages.add(new PostPage()); pages.add(new AboutPage()); ... 
blog-specifikus pageket adunk hozza => ez a konkret class fogl a krealassal, nem az abstract Website; de a factoryban az a return type!
public class Shop extends Website { ...

public class WebsiteFactory {
  public static Website getWebsite(String siteType) { switch(siteType) {case "blog": return new Blog(); case "shop": return new Shop(); default: return null; }
a konkret impl konstruktorok (new Blog(), new Shop()) a parent Website() konstruktorat hivjak, az pedig a konkret implkban overridolt createWebsite()-t

public class Demo { Website site = WebsiteFactory.getWebsite("blog"); sout(site.getPages()); site = WebsiteFactory.getWebsite("shop"); sout(site.getPages());

"blog", "shop" stringek helyett hasznalhatunk enumot; ekkor getWebsite(WebsiteType siteType) es az enum fieldekre switchelhetunk
  
pitfalls
complexity (kb. 2x annyi kod volt mint a tobbi patternnel). a creation nem magaban a factoryban tortenik hanem a krealando impl subclassokban. nem refactoring pattern, alt upfront design soran szuletik dontes h vmit factoryval csinalnak-e

factory vs singleton: ld. a singletonnal

factory param-driven. ha runtime akarjuk a creation typeot meghat akkor haszn. tulkepp a singleton oppositeja
  
===
[AbstractFactory Pattern]
concepts
factory of factories (bar a factory method pattern nelkul is lehet impl)
factory of related objs
common iface: ativel az abstract factoryn es az underlying factorykon a konkret krealando objig (product)
defer instantiation to subclasses
pl. DocumentBuilder (Java XML API). mas JDK API pelda nem nagyon van, alt inkabb fwkben impl

design
groups factories together
factory is responsible for creating objs and managing the lifecycle
ativelo common iface, ld. conceptsnel
concrete classok returnolodnek
tip parameterized create method, mint sima factorynal
kulonbseg vs factory: tip compositiont haszn

DocumentBuilderFactory abstractFactory = DocumentBuilderFactory.newInstance(); 
DocumentBuilder factory = abstractFactory.newDocumentBuilder();  
Document doc = factory.parse(xmlString.getBytes()); //a Document egy iface; a factory valaszt egy implt amit returnol a clientnek
clientkent nem tudjuk sem az abstract factory sem az underlying factory impljat, csak azt h a vegen kapunk egy documentet, amivel dolgozhatunk
abstractFactory.getClass(), factory.getClass() kiiratva pl. com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl es DocumentBuilderImpl. kicserelheto is lenne vmi masik libraryre

demo
abstract factory
public abstract class CreditCardFactory { 
  public static CreditCardFactory getCreditCardFactory(int creditScore) { if(creditScore > 650) return new AmexFactory(); else return new VisaFactory(); }
  public abstract CreditCard getCreditCard(CardType cardType); //a konkret factoryk ezt fogjak overridolni 
	
konkret factoryk
public class VisaFactory extends CreditCardFactory  {
  public CreditCard getCreditCard(CardType cardType) { switch(cardType) { case GOLD: return new VisaGoldCreditCard(); case PLATINUM: return new VisaBlackCreditCard(); } return null; } 
public class AmexFactory extends CreditCardFactory { 
  public CreditCard getCreditCard(CardType cardType) { switch(cardType) { case GOLD: return new AmexGoldCreditCard(); case PLATINUM: return new AmexPlatinumCreditCard(); } return null; }
a konkret ...CreditCard implk az abstract CreditCard classt extendaljak (de persze implhatnanak iface tipust is) 

public class Demo { 
  CreditCardFactory abstractFactory = CreditCardFactory.getCreditCardFactory(775); CreditCard card = abstractFactory.getCreditCard(CardType.PLATINUM); sout(card.getClass()); //abstract factory a creditScore alapjan AmexFactory-t, az pedig a cardType alapjan AmexPlatinumCreditCard-ot kreal
  abstractFactory = CreditCardFactory.getCreditCardFactory(600); CreditCard card2 = abstractFactory.getCreditCard(CardType.GOLD); sout(card2.getClass());   //abstract factory a creditScore alapjan VisaFactory-t, az pedig a cardType alapjan VisaGoldCreditCard-ot kreal

az abstract factory meg azt sem tudja h milyen konkret factory lesz, azt meg kevesbe h azok aztan milyen credit cardot krealnak. csak azt h deferralnia kell a megfelelo factorynak es az majd kezeli tovabb (termeszetesen a kliens sem tudja)
klf DB typeokhoz lehet jol haszn. uazok a queryjeink vannak, de nem tudjuk h Oracle v MySQL DB-n futtatjuk oket (?)

pitfalls
complexity
runtime switch van benne: a clientnek van vmi rahatasa, es szoktak attol felni h a client tul sokat tud
pattern within a pattern
elegge problem specific: tobbi pattern broader
alt sima factorybol indul, es kesobb refactoroljak abstract factoryva. sokan nehezen vizualizalhatonak tartjak

factory vs abstract factory
factory: returns various instances (multiple constructors). iface driven. adaptable to env more easily
abstract factory: factoryra irtak itt is igazak + implemented with a factory (legtobbszor, de nem muszaj). hides the factory. +1 abstraction layert ad az envhez. tip built with composition

heavily abstracted: ifaces, subclasses, composition, contracts; mas patterneknel ez kevesbe jell
tip vmi fw reszekent szerepel a kodunkban