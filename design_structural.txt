Design Patterns in Java: Structural (Bryan Hansen)

pattern groups: creational/structural/behavioural
structural: how to use/utilize objs (for perf, refactoring, mem utilization etc)
adapter, bridge, composite, decorator, facade, flyweight, proxy

===
[Adapter Design Pattern]
connecting new code to legacy code without changing the legacy contract
ld. plug adaptor (pl. USB-to-microUSB atalakito)

concepts
convert iface to another iface
alt az egyik oldalon legacy, amit nem tudunk/akarunk megvaltoztatni
translates client reqs to the code that we are adapting to (client - adapter - adaptee)
pl. Collections: Arrays -> Lists (arrays are legacy), Streams (have adapters to work with other streams or readers)

design
client centric (alt integrate new client to legacy components)
alt iface, de nem required (lehet class is)
az adaptee is lehet new impl; bar tip nem az
client.doSomething(): ezt a legacy nem tam, ezert berakunk egy adaptert amiben van egy doThis(), es ez integral a legacy.doThat()-hez

Integer[] intArray = new Integer[] {42,43,44}; List<Integer> intList = Arrays.asList(intArray);
csak adaptal, es nem ad hozza plusz funkciot (tehat nem decorator)
nem szereti a peldat, mert csak "egyszeres" adapter, tehat csak arrayt konvertal listbe, mast nem

demo
public class AdapterDemo { EmployeeClient client = new EmployeeClient(); List<Employee> employees = client.getEmployeeList(); sout(employees);
public class EmployeeClient { 
  public List<Employee> getEmployeeList() { List<Employee> employees = new ArrayList<>(); Employee employeeFromDB = new EmployeeDB(...); employees.add(employeeFromDB); return employees;
public interface Employee { public String getId(), getFirstName(), getLastName(), getEmail();
public class EmployeeDB implements Employee { private String id, firstName, lastName, email; public EmployeeDB(id, firstName, lastName, email); public String getId() + tobbi getter

ez eddig OK
public class EmployeeLDAP { private String cn, givenName, surName, mail;  + getterek
ez nem impl az Employee-t! uolyan employee jellegu class, de masok a fieldnevek, ezert a clientben Employee employeeFromLDAP = new EmployeeLDAP(...) igy nem fordulna le. helyette EmployeeLDAP employeeFromLDAP = new EmployeeLDAP(...); employees.add(new EmployeeAdapterLDAP(employeeFromLDAP));
public class EmployeeAdapterLDAP implements Employee {
  private EmployeeLDAP instance;
  public EmployeeAdapterLDAP(EmployeeLDAP instance) { this.instance = instance; }
  public String getId() { return instance.getCn(); } public String getFirstName() { return instance.getGivenName(); } ...
Employee-t impl, tehat annak megfeleloek a getterei, es bewrappel/konstrban atvesz egy EmployeeLDAP-t aminek a mezoit a getterek atmappelik az Employee-nak megfeleloen. a clientben egy ilyen tipusu objt hozza lehet addolni az Employee listahoz
ebben a formaban a clientben a sout EmployeeAdapterLDAP@...-t ir ki erre a listaelemre. EmployeeAdapterLDAP-be lehet egy toString()-et rakni ami uolyan formaban printeli ki a fieldeket mint az EmployeeDB-nel, de egyesek szerint akkor ez mar decorator lesz (a szerzo szerint nem)

egy masik adapter uugy
clientbe EmployeeCSV employeeFromCSV = new EmployeeCSV(...); employees.add(new EmployeeAdapterCSV(employeeFromCSV));
public class EmployeeCSV { int id; String firstname, lastname, emailAddress; //nem impl az Employee-t, mas tipusu es mas nevu fieldek
public class EmployeeAdapterCSV implements Employee {
  private EmployeeCSV instance;
  public EmployeeAdapterCSV(EmployeeCSV instance) { this.instance = instance; }
  public String getId() { return instance.getId() + ""; } ...
  
pitfalls: nem tul sok. ne overkomplikaljuk. lehetseges h egy adapter tobb typera is nyujt adaptolast. adapter arra valo h az egyuttmukodest segitse, nem plusz func hozzaadasara (az akkor decorator v vmi mas lesz)

adapter vs bridge
adapter: works after code is designed. deals with legacy code. tip retrofitted, unrelated classok egyuttmukodesenek erdekeben. provides a different iface for legacy code
bridge: designed upfront. lets abstraction and implementation vary, built in advance to provide a layer of abstraction and let both system to be flexible
both adapt multiple disparate systems

===
[Bridge Design Pattern]

