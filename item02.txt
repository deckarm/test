ITEM 2: CONSIDER A BUILDER WHEN FACED WITH MANY CONSTRUCTOR PARAMETERS

static factoryk es konstrk kozos limitje: nem scal jol nagyszamu optional paramra. 
pl. class nehany required + sok optional fielddel. hagyomanyosan telescoping konstr pattern: egy konstr csak a required paramokkal, egy konstr amiben egy optional param is van, egy konstr amiben ket opt param van stb. 
instance kreaasnal azt a legrovidebb konstrt haszn ami minden paramot tartalmaz amit settelni akarunk. NutritionFacts cocaCola = new NutritionFacts(240,8,100,0,35,27);
itt tip tobb olyan paramot is meg kell adnunk amit nem akarunk settelni, de kenytelenek vagyunk megadni (itt pl. fat = 0). sok paramnal ez hamar elfajul
telescoping konstr pattern muk, de nehez client kodot irni hozza v a mar megirt kodot olvasni. identically typed paramok eseteben subtle bugok lehetnek ha a client veletlenul felcserel ket ilyet; compiler nem panaszkodik de runtime misbehav (item 51)

alternativa a JavaBeans pattern, ahol param nelkuli konstr krealja az objt majd setterekkel allitjuk be a required es a relevans optional paramokat
nincsenek a telescoping hatranyai; egyszeru instance krealas es olvasas. NutritionFacts cocaCola = new NutritionFacts(); cocaCola.setServingSize(240) stb;
sajnos ennek is megvannak a maga hatranyai. mivel a konstr tobb hivas kozt van splittelve, a bean a konstr soran inkonz stateben lehet. class nem tudja konstr paramok validityjevel enforcolni a konzt. inkonz stateben levo obj hasznalata nehezen debuggolhato problemakat okoz. kapcs hatrany h igy a class nem lehet immut (item 17) es tovabbi effort kell a prgozo rezserol threadsafetyhez
ez vmennyire mersekelheto ha manualisan "freezeljuk" az objt amikor a constr kesz, es addig nem engedjuk haszn amig nem frozen, de ezt gyak nem nagyon alk. vmint runtime hibakat is okozhat mert a compiler nem tudja enforcolni h a prgozo meghivja a freeze metodust az objn haszn elott

builder pattern egy formaja, amely otvozi a telescoping konstr safetyjet a JavaBeans readabilityjet. kivant objt nem direktben krealjuk, hanem a client egy konstrt (v static factoryt) hiv a required paramokkal es egy builder objt kap vissza, es ezen hiv setter-like metodusokat a relevans optional paramok besettelesere. vegul egy param nelkuli build() metodust hiv ami megkrealja az objt, ami tip immut. a builder tip a buildelni kivant class egy static member classa (item 24)
public class NutritionFacts {
  private final int servingSize, servings, calories...
  public static class Builder {
    private final int servingSize, servings; /* required paramok */ calories = 0; ... //opt paramok, default valuera initelve
	public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings;
	public Builder calories(int val) { calories = val; return this; } //...tobbi opt paramra uigy
	public NutritionFacts build() { return new NutritionFacts(this);
  private NutritionFacts(Builder builder) { servingSize = builder.servingSize; servings = builder.servings; ...

NutritionFacts immut es minden param default value egy helyen van. a builder setter metodusai magat a buildert returnolik, igy az invocationok chainelhetoek, fluent API. client: NutritionFacts cocaCola = new Nutritionfacts.Builder(240,8).calories(100)....build(); egyszeru megirni es olvasni is. a builder pattern a Python/Scala named opt paramjai szimulalja

validity csekkek a rovidseg miatt kimaradtak. ha ASAP detektalni akarjuk az invalid paramokat akkor a builder konstraban es metodusaiban csekkeljuk oket. a tobb paramot tartalmazo invariantokat a build() altal invokolt konstrban csekkeljuk. ahhoz h tamadassal szemben bizt az invariantaokat, az obj fieldeken vegezzuk a csekkelest miutan copyztuk a paramokat a builderbol (item 50). ha egy csekk failel akkor dobjunk IllegalArgumentExceptiont (item 72) amelynek detail message jelzi h mely paramok invalidok (item 75)

builder pattern jol hasznalhato class hierekhez. builderek parh hierje, mindegyik a megfelelo classba nestelve. abstract classokhoz abstract builderek, concrete classokhoz concrete builderek
public abstract class Pizza {
  public enum Topping { HAM, MUSHROOM... }
  final Set<Topping> toppings;
  abstract static class Builder<T extends Builder<T>> {
    EnumSet<Topping> toppings = EnumSet.noneOf(Topping.class);
	public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self();
	abstract Pizza build(); 
	protected abstract T self(); //subclassoknak ezt kell overridolniuk a "this" returnolesehez
  Pizza(Builder<?> builder) { toppings = builder.toppings.clone(); //(item 50)

Pizza.Builder egy generic type, recursive type parammal (item 30). ez, az abstract self() metodussal, teszi lehetove h a metodus chaining mukodjon a subclassokban, castolas nelkul. ez egy workaround arra h Javaban nincs self type, un. simulated self-type

concrete Pizza subclassok; az elsoben required size param, a masodikban megadhatjuk h sauce in v out
public class NyPizza extends Pizza {
  public enum Size {SMALL, MEDIUM, LARGE}
  private final Size size;
  public static class Builder extends Pizza.Builder<Builder> {
    private final Size size;
	public Builder(Size size) { this.size = Objects.requireNonNull(size);
	public NyPizza build() { return new NyPizza(this);
	protected Builder self() { return this;
	private NyPizza(Builder builder) { super(builder); size = builder.size;
public class Calzone extends Pizza {
  private final boolean sauceInside;
  public static class Builder extends Pizza.Builder<Builder> {
    private boolean sauceInside = false; //default
	public Builder sauceInside() { sauceInside = true; return this;
	public Calzone build() { return new Calzone(this);
	protected Builder self() { return this;
	private Calzone(Builder builder) { super(builder); sauceInside = builder.sauceInside;

mindket subclass build() metodusa a megfelelo subclasst returnoli. ez a techn, ahol egy subclass metodus ugy van dekl h a superclassban dekl return type egy subtypejat returnolje, az un. covarian return typing. igy a clientek casting nelkul hasznalhatjak a buildereket
ezeknek a hier buildereknek a client kodja gyak uolyan mint az egyszeru buildere bolt. NyPizza pizza = new NyPizza.Builder(SMALL).addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder().addTopping(HAM).sauceInside().build();

builder elonye konstr szemben h tobb vararg paramja is lehet mivel minden param a sajat metodusaban van spec. v a builder "can aggregate the parameters passed into multiple calls to a method into a single field" mint azt az addTopping() metodusnal lattuk

builder pattern flex. egy builder ismetelten hasznalhato, tobb obj buildelesere. builder paramjai invocationonkent masok lehetnek. builder az obj krealaskor autom be is allithat egyes fieldeket, pl. serial nr ami minden obj krealaskor incr

builder hatranyai. obj krealasahoz eloszor a builderet kell megkrealnunk. builder krealas ktge valszeg nem lesz nagy, de perf-crit esetekben gond lehet. verbose++ a telescopehoz kepest ezert csakkor haszn ha eleg sok param van h megerje. de kalkulaljuk bele h kesobb tovabbi paramokat akarhatunk hozzaadni. de ha konstral v static factorykkal indulunk, es csakkor valtunk builderre amikor mar tul sok param van, az obsolete konstrok es factoryk ott fognak maradni; ezert lehet h celszeru eleve builderrel indulni

ofogl builder jo val ha olyan classokat design, amelyek konstr/static factoryjainak sok paramja van, foleg ha sok optional v identical type param van. egyszerubb client kodot irni es olvasni mint telescope, es safer mint JavaBeans




	