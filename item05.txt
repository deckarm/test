ITEM 5: PREFER DEPENDENCY INJECTION TO HARDWIRING RESOURCES

szamos class dependal egy v tobb underlying rscn. pl. spell checker egy dictionaryn. az ilyen classok gyakran static utility classkent impl (item 4). az sem ritka h singletonkent (item 3)
public class SpellChecker {
  private static final Lexicon dictionary = ...
  private SpellChecker(...) {}
  public static boolean isValid(String word) {...}

public class SpellChecker {
  private final Lexicon dictionary = ...
  private SpellChecker(...) {}
  public static INSTANCE = new SpellChecker(...);
  public boolean isValid(String word) {...}

egyik approach sem jo (inflex + nem testable), mert azt felt h csak egy single dict van. gyak minden languagenek sajat dict, vmint spec dictk is leteznek, teszteleshez is lehet h mas dict kell

megprobalhatnank h tobb dict tam, ha nonfinalla tennenk a dictionary fieldet es beraknank egy metodust amivel lehetne dictet valtani, de ez awkward, error-prone es conc mellett nem muk jol. static util class es singleton nem jok olyan classokhoz amelyek behavjet egy underlying rsc parametrizalja

a class (SpellChecker) tobb kul instanceat kellene tudni tam, amelyek mindegyike a client altal kivant rsct (dictionary) tudja haszn. erre egy pattern ha atadjuk a rsct a konstrnak az uj instance krealasakor. ez a DI egy formaja: a dict a spell checker depje, es krealaskor beinjectaljuk a spell checkerbe 

public class SpellChecker {
  private final Lexicon dictionary;
  public SpellChecker(Lexicon dictionary) { this.dictionary = Objects.requireNonNull(dictionary);
  public boolean isValid(String word) {...}
  
itt csak egy rsc van (dict) de a DI arbitrary szamu rscvel es dep graffal muk. megorzi az immutot (item 17) igy tobb client tud dependent objkat sharelni (felteve h a clientek uazokat az underlying rscket akarjak). DI alkhato konstrra, static factoryra (item 1), builderre (item 2)

egy hasznos valtozat amikor egy rsc factoryt adunk at a konstrnak. Java 8 Supplier<T> ifaceel lehet factorykat repr. Suppliet<T>-t atvevo metodusok a factory type paramjat tip bounded wildcard type-al (item 31) constrainelik h a client olyan factoryt tudjon beadni ami a megadott type bmilyen subtypejat tudja krealni
Mosaic create(Supplier<? extends Tile> tileFactory) {...}

bar a DI flex++/testability++, nagy projecteknel zavaros lehet ahol tobb ezer dep van. ezeket a DI fwk jol kezelik

tehat ne hasznaljunk singletont v static util classt olyan class impljara ahol egy v tobb underlying rsc affectalja a class behavt, es nem a class maga krealja ezeket a rscket direktben. helyette adjuk at a rscket v az oket krealo factorykat a konstrnak (v static factorynak v buildernek). DI flex++,reuse++,testability++