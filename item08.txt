ITEM 8: AVOID FINALIZERS AND CLEANERS

finalizerek unpred, gyakran veszelyesek es alt szuksegtelenek. hasznalatuk erratic behavot, perf--, portability issuekat okozhat. csak nehany valid useuk van, ld. kesobb, de alt kerulendoek. Java 9-ben finalizerek deprecated, de Java libek meg mindig haszn oket. Java 9 finalizerek replacementje a cleanerek; kevesbe veszelyesek, de szinten unpred, lassuak, es alt szuksegtelenek

ne gondoljunk a finalizerekre/cleanerekre mint a C++ destruktor analogiajara. destr az objhoz tartozo rsck reclaimelesenek normal modja, konstr counterpartja. Javaban a GC reclaimeli az objkhoz kapcs storaget amikor unreachable lesz, prgozo kozremuk nelkul. destr tovabba nonmem rscket is reclaimel, aminek a Java megfeleloje a twr (item 9)

finalizerek/cleanerek nem biztos h promptly execelve lesznek. obj unreachable valasa es finalizere/cleanere lefutasa kozt arbitrary ido telhet el. ezert finalizerben/cleanerben semmi time-criticalt nem szabad csinalni. pl. sulyos hiba finalizerre/cleanerre bizni file closeolasat mivel az open file descriptorok limited rsc. ha sok file marad open mert a finalizerek/cleanerek nem csukjak be oket idoben akkor a prg elfailelhet mivel nem tud tovabbi fileokat openelni

finalizerek/cleanerek execelesenek promptsaga a GC algotol fugg ami impltol fuggo. igy a finalizer/cleaner mukodesen dependalo prg behavje szinten. lehet h a prg a tesztelesre haszn JVMen jol fut, prodban viszont elfailel

nem csak elmeleti problema. pl. long-running GUI app ami mindig OutOfMemoryErrorral halt meg: debug kimutatta h gfx objk ezrei vartak a finalizer queuen reclaimelesre, a finalizer thread prioja viszont kisebb volt mint az app threade ezert az objk nem finalizalodtak azzal a rate-tel ahogy eligibleve valtak. nyelv spec nem garantalja h melyik thread fogja a finalizereket execelni, ezert nincs portable mod ennek a problemanak a kivedesere, csak ha nem haszn finalizereket. cleanerek ebbol a szempontbol vmivel jobbak mivel class authoroknak van controljuk a cleaner threadjeik folott, de a cleanerek is a bacgroundban futnak, a GC controlja alatt, tehat nincs garancia a prompt cleaningre

a spec nem csak azt nem garantalja h a finalizerek/cleanerek prompt lefutnak; azt se h egyaltalan lefutnak. lehetseges h a prg anelkul terminal h lefuttatna oket. ezert sosem szabad finalizerre/cleannerre bizni h persistent statet updateljen. pl. ha finalizerre/cleanerre bizzuk egy persistent lock v egy shared rsc, pl. DB releaseleset, azzal egy egesz distr syst megallithatunk

System.gc(), System.runFinalization() novelhetik az eselyet h finalizerek/cleanerek lefussanak, de nem garantaljak. System.runFinalizersOnExit(), Runtime.runFinalizersOnExit() metodusok fatally flawed es deprecated

masik problema h finalization soran dobott uncaught exc ignored, es az obj finalizalasa terminalodik. az uncaught exck pedig corrupt stateben hagyhatnak mas objkat is. ha egy masik thread egy ilyen corrupted objt probal hasznalni, abbol nondeterm behav lehet. normal esetben uncaught exc terminalja a threadet es stacktracet printel, de ha finalizerben tortenik akkor meg csak warningot sem ad. cleanernel nincs ilyen problema, mert a cleanert hasznalo libnek controlja van a threadje folott

finalizerek/cleanerek hasznalata komoly perf penalty. szerzo gepen egy AutoCloseable krealasa, twr bezarasa es GC reclaimje kb 50x gyorsabb mint finalizerrel destroyolni. ez foleg azert van mert a finalizerek meggatoljak a hatekony GC-t. cleanerek kb a finalizerekhez hasonlo sebesseguek ha class instanceok cleanelesere haszn, de gyorsabbak ha csak safety netkent haszn oket, ld lentebb. ebben az esetben a penalty csak kb 5xos

finalizerek security problemaja: kinyitjak a classt finalizer attackokra. ha konstrbol v serialization ekvivjaibol a readObject()/readResolve() metodusokbol (ch 12) exc dobodik, akkor lefuthat egy malicious subclass finalizerje a partially constructed objn, es berecordolhat egy static field refet ra, ezaltal preventalva a GC-jet. ezutan pedig mar nyugodtan lehet metodusokat is invokolni az objn, aminek nem is kellene leteznie. konstrbol dobott exc eseten az objnak nem lenne szabad letrejonnie; finalizerek eseten ez nem igy van. final classok vedve vannak a finalizer attackokkal szemben, mert nem subclassolhatoak. nonfinal classokat ugy vedhetjuk meg ha teszunk bele egy final finalize() metodust ami nem csinal semmit

mit csinaljunk finalizer/cleaner helyett ha olyan classunk van ami terminationt igenylo rscket (fileok, threadek) encapsol? class implja AutoCloseable ifacet, clientek pedig invokoljak a close() metodust minden instanceon ha mar nincs ra szukseg, tip twr hasznalataval h exck eseten is bizt legyen a termination (item 9). az instancenak trackelnie kell h closolodott: a close() metodusnak recordolnia kell egy fieldben h az obj mar nem valid; mas metodusoknak csekkelniuk kell ezt a fieldet es IllegalStateExceptiont dobniu ha azutan hivodnak h az obj closed

finalizerek/cleanerek egyik legitimate hasznalata safety netkent ha egy rsc ownere nem hivja meg a close() metodust. bar nincs garancia h a cleaner/finalizer prompt v egyaltalan le fog futni, jobb kesobb mint soha felszab a rsct ha a client nem teszi meg. ha ilyet akarunk, gondoljuk at h ez a vedelem megeri-e a ktget. egyes Java lib classokban, pl. FileInputStream, FileOutputStream, ThreadPoolExecutor, java.sql.Connection van ilyen safety netkent muk finalizer

masik legitimate hasznalat native peeru objknal. native peer egy nativ (non-Java) obj aminek egy normal obj nativ metodusokkal delegal. mivel a native peer nem egy normal obj, a GC nem tud rola es nem reclaimeli amikor a Java peerjet. cleaner/finalizer segitsegevel ez megoldhato ha a perf OK, es a native peer nem tart critical rscket. ha a perf nem jo v a native peer olyan rscket tart amiket promt reclaimelni kell, akkor a classba close() metodus kell, ld. korabban

cleanerek hasznalata trukkos. tfh roomokat cleanelni kell reclaimelesuk elott. Room implements AutoCloseable; az h az autom cleaning safety netje cleanert hasznal, csak impl detail
public class Room implements AutoCloseable {
  private static final Cleaner cleaner = Cleaner.create();
  private static class State implements Runnable {
    int numJunkPiles; State(int numJunkPiles) { this.numJunkPiles = numJunkPiles; //cleaninget igenylo rsc. nem refelhet a Room-ra!
	public void run() { sout("cleaning room"); numJunKpiles = 0; //close metodus v cleaner invokolja
  private final State state; //room stateje, cleanable-vel sharelve
  private final Cleaner.Cleanable cleanable; //cleanable; cleaneli a rommot amikor GC eligible lesz
  public Room(int numJunkPiles) { state = new State(numJunkPiles); cleanable = cleaner.register(this, state);
  public void close() { cleanable.clean();

static nested State class tart a rscket amelyekre a cleanernek szuksege van a room cleanelesehez. itt ez most a numJunkPiles field. realisztikusabban ez lehetne egy final long ami pointert tart egy native peerre. State implements Runnable, es a run() metodusa max egyszer hivodik, a Cleanable altal, amit akkor kapunk amikor a State instanceunkat registraljuk a cleanerre a Room() konstrban. a run() metodus hivasat tip a Room close() metodusa triggereli, ami a Cleanable clean() metodusat hivja. ha a client nem hivja meg a close() metodust amikor a Room instance GC eligible lesz akkor a cleaner (remelhetoleg) meghivja a State run() metodusat

lenyeges h a State instance nem refel a Room instancera. ha refelne, akkor circularity lenne ami preventalna h a Room instance GC eligible valjon. ezert kell h a State static class legyen, mivel a nonstatic nested classok reft tartanak az enclosing instancera (item 24). hasonloan nem javasolt lambdat haszn mert azok konnyen capturolhatnak reft az enclosing objra

Room cleaner safety netkent muk. ha a clientek minden Room instantiont twr blockokba agyaznak akkor autom cleaning sosem lesz szukseges
public class Adult { main() { try(Room room = new Room(7)) { sout("goodbye");
kimenet "goodbye" majd "cleaning room"
public class Teenager { main() { new Room(99); sout("peace out");
ez lehet h sosem irja ki h "cleaning room", csak exitel. ez az emlitett unpred. Cleaner spec: "cleanerek behavja System.exit() soran impl specifikus. nincs garancia h cleaning activityk invokolodnak v sem". spec nem emliti, de normal program exitre uez von. System.gc() hozzaadasaval lehet h kiirodik a "cleaning room" is, de nincs ra garancia

ne hasznaljunk cleanereket, Java 9 elott finalizereket, csak safety netkent v noncritical native rsck terminalasara. es meg akkor is tartsuk szem elott a nondeterm viselkt es perf kovetkezmenyeket

  