ITEM 11: ALWAYS OVERRIDE HASHCODE WHEN YOU OVERRIDE EQUALS

minden olyan classban overridolnunk kell hashCode()-ot, ami overridolja equals()-t. ha nem tesszuk akkor a classunk violalja a general hashCode() contractot, es nem fog jol muk collokban mint HashMap v HashSet. a contract
- hashCode() egyazon app futason belul tortent ismetelt invokolasa soran konzisztensen uazt a valuet kell returnolje, amennyiben az equals()-ben hasznalt semmilyen info nem valtozott. app kulonbozo futasai kozott a value valtozhat
- ha ket obj az equals() szerint equal, akkor a ket objn hivott hashCode()-nak uazt a resultot kell eredmenyeznie
- ha ket obj az equals() szerint unequal, akkor NEM kovetelmeny h a ket objn hivott hashCode()-nak kulonbozo resultot kell eredmenyeznie. de a prgozonak tudnia kell h unequal objkra adott kul resultok javithatjak a hashtablek perfjet

ha nem overridoljuk a hashcodeot azzal a masodik pontot violaljuk: equal objknak equal hashcodeja kell legyen. ket distinct instance logically equal lehet az equals() szerint, de az Object hashCode() metodusa szamara ok lenyegeben ket random obj, ugyhogy ket latszolag random szamot is fog returnolni, es nem ket equal szamot ahogy azt a contract megkivanna
Map<PhoneNumber,String> m = new HashMap<>(); m.put(new PhoneNumber(112223333), "Jenny"); //item10-ben hasznalt PhoneNumber class
errol azt gondolnank h m.get(new PhoneNumber(111222333)) "Jenny"-t returnol, de nullt fog. vegyuk eszre h ket PhoneNumber instance van a peldaban, az egyiket haszn a mapba insertelesnel, egy masik, equal instanceot pedig a retrieval kiserletnel. mivel a PhoneNumber class nem overridolja a hashCode()-ot, ezert a ket equal instancenak unequal hashcodeja lesz, violalva a hashcode contractot. ezert a get() metodus valszeg egy masik hash bucketben fogja keresni a szamot mint ahova a put() tette. meg ha tortenetesen uabban a bucketben is lennenek, a get() akkor is majdnem biztosan nullt returnol, mert a HashMap optimizal, becacheli az entryk hashcodejait es nem is csekkeli az obj equalityt ha a hashcodeok nem egyformak

megoldas ha irunk a PhoneNumber classba egy megfelelo hashCode() metodust. az alabbi pelda legal de nem jo
public int hashCode() { return 42;
ez legal mert bizt h equal objk hashcodeja uaz lesz. ugyanakkor rossz mert MINDEN objnak uaz lesz a hashcodeja. ezert minden obj uabba a bucketbe hashelodik, es a hashtable linked listte degeneralodik. prgk amiknek linearis idoben kellene futni, quadratic idoben fognak futni. nagy hashtablak eseteben ez a muk/nem muk kozti kulonbseget jelenti

egy jo hash func unequal instanceokra unequal hash codeokat gyart. ez a hashCode() contract harmadik pontja. idealis hash func az egy collban levo unequal instanceokat uniform szorja szet az int-ek tartomanyan. idealist elerni nehez, de jol approxolhato, recept:
1. deklaraljunk egy result nevu int vart, es initeljuk az obj elso significant fieldjenek c hashcodejara, amit 2a-ban szamolunk ki (item 10: significant field amely affectalja az equals()-t)
2. az obj minden tovabbi significant f fieldjere
a. szamoljuk ki a field c hashcodejat
i. ha a field primitiv type, szamoljuk ki Type.hashCode(f)-et ahol Type az f typejanak megfelelo primitive wrapper class
ii. ha a field egy obj ref es ennek a classnak az equals() metodusa ugy komparalja a fieldet h rekurzivan invokolja ra az equals()-t akkor invokoljuk rekurzivan a hashCode()-ot a fielden. ha a komparalas komplexebb akkor szamoljuk ki a field egy "canonical repr"-jat  es invokoljuk ezen a hashCode()-ot. ha a field valueja null akkor hasznaljunk 0-t (v vmi mas konstanst de alt 0-t szoktak)
iii. ha a field egy array, kezeljuk ugy mintha minden significant elem separate field lenne. azaz szamoljunk hashcodeot minden significant elemre, rekurzivan applyolva ezeket a ruleokat es kombinaljuk a valuekat 2b szerint. ha az arrayben nincsenek significant elemek, akkor hasznaljunk konstanst, lehetoleg ne 0-t. ha minden elem significant akkor hasznaljunk Arrays.hashCode()-ot
b. kombinaljuk a 2a-ban kiszamolt c hashcode-ot result-ba: result = 31 * result + c;
3. return result

ha megirtuk a hashCode()-ot, nezzuk meg h equal instanceoknak equal hashcodejuk van-e. csekkelesre irjunk unit testeket (ha AutoValue-val generaltunk akkor folosleges)

derived fieldeket kizarhatjuk a hashcode szamitasbol. maskent, ignoralhatunk minden fieldet amelynek valueja a hashcode szamitasban reszt vevo fieldekbol kiszamolhato. ki KELL zarnunk az equals()-ban nem hasznalt fieldeket v kock h violaljuk a hashCode() contract masodik pontjat

2b-ben hasznalt szorzas miatt a result a fieldek orderjetol fugg, sokkal jobb hash funct eredmenyezve ha a classban sok hasonlo field van. pl. ha a String hash funcjaban nem lenne ez a szorzas akkor minden anagramnak identical hashcodeja lenne. 31-et azert haszn mert paratlan prim; ha paros lenne es a szorzas overflowolodna akkor infovesztes lenne mivel a 2-vel szorzas shifteles. prim hasznalatanak elonye kevesbe triv, de van. 31 szep tulajdonsaga h a szorzas egy shifttel es egy kivonassal helyettesitheto a legtobb archon: 31 * i = (i << 5) - i

alkalmazva az elobbieket PhoneNumber classra
public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * Short.hashCode(lineNum); return result;
mivel ez egy determinisztikus szamitas amelynek inputja a PhoneNumber harom significant fieldje, ezert nyilvanvalo h equal PhoneNumber instanceok hashcodeja equal lesz. ez egy teljesen jo hashCode() impl, Java platform libekben is hasonloak vanna. egyszeru, eleg gyors es eleg jol szorja az unequal phone numbereket kulonbozo hash bucketekbe. de ha olyan hash funct akarunk ahol meg kisebb az utkozes vge akkor Guava com.google.common.hash.Hashing

Objects classban van egy static hash() metodus ami arbitrary szamu objt vesz at, es hashcodeot ad vissza rajuk. ezzel egysoros hashCode() metodusok irhatoak amelyek qualityje megfelel a recept alapjan irtaknak. viszont lassabban futnak, mert array creationt haszn a vararg miatt, vmint boxing/unboxing van ha az argok vmelyik primitiv type. csakkor haszn ha perf nem kritikus. 
public int hashCode() { return Objects.hash(lineNum, prefix, areaCode);

ha egy class immut es a hashcode szamitas ktge significant, akkor a hashcode cachelheto az objban ahelyett h minden requestnel ujraszamolnank. ha ugy gondoljuk h ennek a typenak a legtobb instancet hash keykent fogjuk haszn, akkor az instance krealasakor szamoljuk ki a hashcodeot. egyebkent initelhetjuk lazy, az elso alkalommal amikor a hashCode() invokolodik. arra figyelni kell h a class lazy inited field eseten is threadsafe maradjon (item 83). PhoneNumber classt ez nem erinti, de ezen mutatjuk be. figyeljunk h a hashCode field init erteke (itt 0) ne legyen egy commonly created instance hashcodeja
private int hashCode; public int hashCode() { int result = hashCode; if(result == 0) { /* Short.hashCode()-ok mint fent */ hashCode = result; } return result;

ne akarjunk significant fieldeket excludolni a hashcode szamitasbol perf kedveert. lehet h gyorsabb lesz de a gyengebb quality degradalhatja a hashtable perfjet akar a hasznalhatatlansagig. foleg ha a hash func olyan instanceok egy nagy colljaval szembesul amelyek fokent az ignoralt teruleteken kulonboznek egymastol. ekkor a hash func az instanceokat csak nehany hashcodera fogja mappelni es prgok linearis ido helyett quadratic idoben fognak futni. ez nem csak elmeleti problema; Java 2 elott a String hash func max 16 db, a stringben evenly spaced chart hasznalt, az elso chartol indulva. hierarchical nevek (pl. URLek) egy nagy colljara ez pont a leirt rossz minosegu viselkedest fogja tanusitani

ne adjunk reszletes specet a hashCode() altal returnolt valuera, h a clientek ertelmesen tudjanak dependalni ra; igy megmarad a flex h valtoztatni tudjunk rajta. szamos Java lib class, pl. String es Integer, az instance value fvekent adjak meg a hashCode() metodusuk altal returnolt valuet. ez nem jo otlet, mert megkoti a kezunket h future releasekben improvoljuk a hash funct. ha nem spec a detaileket, es hibat eszlelunk v jobb hash fuct fedezunk fel, akkor kesobb meg tudjuk valtoztatni

summary: mindig overridolnunk KELL a hashCode()-ot ha az equals()-t overridoltuk vagy a prg nem fog correctly futni. hashCode() metodusunknak be kell tartania az Object-ben spec general contractot, es torekednie kell arra h unequal instanceokhoz unequal hashcodeokat rendeljen. ez a leirt recepttel megvalosithato. az AutoValue fw jo alternativat nyujt a kezzel valo irassal szemben, es az IDEkben is vannak erre toolok
