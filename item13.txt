ITEM 13: OVERRIDE CLONE JUDICIOUSLY

Cloneable ifacet mixin ifacenek szantak (item 20) amivel a classok azt jelzik h cloneozhatok. de sajnos nem megfelelo erre a celra. nincs benne clone() metodus, az Object clone()-ja pedig protected. nem tudjuk invokolni a clone()-t egy objn csak azert mert implja Cloneablet, csak reflectionnal (item 65). meg egy refl invocation is failelhet, mert nem garantalt h az objnak van accessible clone() metodusa. ennek ellenere viszonylag szeles korben haszn, ezert erdemes mgerteni

Cloneable az Object protected clone() impljanak behavjat determinalja: ha egy class impl Cloneablet, akkor az Object clone() az obj egy field-by-field copyjat returnoli, egyebkent CloneNotSupportedException. ez nem tip iface hasznalat, es kerulendo. normal esetben egy iface implementalasa arrol mond vmit h a class mit nyujt a clientjeinek. ebben az esetben viszont egy superclass protected metodusanak behavjat modifolja

bar a spec nem mondja, gyak egy Cloneablet impl classtol elvaras h nyujtson egy jol muk public clone() metodust. ehhez a classnak es minden superclassanak egy komplex, unenforceble, kevesse dokumentalt protocolt kell kovetnie. az eredmeny fragile, veszelyes es extralingusitic: konstr nelkul kreal objkat

clone() general contractja gyenge, ld. Object specjeben
obj copyjat krealja es returnoli. a "copy" pontos jelentese az obj classatol fugghet. alt a cel h minden x objra x.clone() != x true legyen, es az x.clone().getClass() == x.getClass() true legyen, de ezek nem abszolut reqk. tip x.clone().equals(x) true, de ez sem abszolut req
konv szerint a metodus altal returnolt objt super.clone() hivassal kell obtainelni. ha egy class es minden superclassa (Object kivetelevel) betartja ezt a konvt akkor x.clone().getClass() == x.getClass()
konv szerint a returnolt obj indep kell legyen a cloned objtol. az indep eleresehez a super.clone() altal returnolt obj egy v tobb fieldjet modifolni kellhet a returnoles elott
ez a mech kicsit hasonlo a konstr chaininghez, kiveve h nincs enforcolva: ha egy class clone() metodusa egy olyan instanceot returnol, amit nem super.clone() hivassal obtainelunk hanem egy konstr meghivasaval, akkor a compiler nem fog jelezni; de ha a class egy subclassa super.clone()-t hiv akkor a result obj classa rossz lesz, "preventing the subclass from clone method from working properly" (?). ha a clone()-t overridolo class final, akkor ez a konv ignoralhato mivel nincs subclass. de ha egy final classban olyan clone() van ami nem invokolja super.clone()-t akkor a classnak nem is szukseges impl Cloneablet, mivel nem az Object clone() impljan relyol (?)

tfh egy olyan classban akarjuk impl a Cloneablet amelynek superclassa egy jol muk clone() metodust nyujt. eloszor hivjuk meg super.clone()-t. a visszakapott obj az original egy fully func masolata lesz. minden field value identical lesz az originalbelivel. ha minden field primitive valuet v immut objra valo reft tart (azaz nincs ref mutable statere), akkor a returned obj pontosan az lehet amire szuksegunk van, es nem szukseges tovabbi processing. pl. ez az eset az item11-ben latott PhoneNumber classnal (de tegyuk hozza h immut classoknak egyebkent sosem kell clone() metodust nyujtania, mert "it would merely encourage wasteful copying")
public PhoneNumber clone() { try { return (PhoneNumber) super.clone(); } catch(CloneNotSupportedException e) { throw new AssertionError(); //ez nem fordulhat elo

ahhoz h ez a metodus mukodjon, a PhoneNumber class deklt modifolni kell, implements Cloneable. bar az Object clone() metodusa Object-et returnol, ez a clone() metodus viszont PhoneNumber-t; covariant return type, azaz az overridolo metodus return typeja az overridden metodus return typejanak subclassa. igy a clientben nem kell castolni. a super.clone() resultjat Objectbol PhoneNumberbe kell castolnunk a returnoles elott, de ez garantaltan sikerulni fog

super.clone() hivas try-catch blokkban van. ez azert van mert az Object clone() metodus dekl throws CloneNotSupportedException, ami checked. mivel PhoneNumber implements Cloneable, tudjuk h a super.clone() hivas sikerulni fog. ez a boilerplate jelzi h a CloneNotSupportedException unchecked kellett volna legyen (item 71)

ha egy obj olyan fieldeket tart amik mutable objkra ref, az elobbi egyszeru clone() impl nem lesz jo. pl. item7 Stack classt akarjuk cloneable tenni. ha a clone() metodus egyszeruen super.clone()-t returnol akkor a resulting Stack instance size fieldjeben jo value lesz, de az elements fieldje uarra az arrayre fog ref mint az original Stack instance. az original modifolasa elrontja a clone invarjait es forditva; a prg valszeg furcsa eredmenyeket fog produkalni v NPEt dob

ez nem fordul elo ha a Stack konstrat hivjuk. hatasaban a clone() metodus konstrkent viselkedik; bizt kell h nem karositja az orig objt es megfeleloen letrehozza az invarokat a cloneon. ahhoz h a clone() jol mukodjon Stack-re, a stack internaljait kell copyzni. ennek legegyszerubb modja a clone() rekurziv hivasa az elements arrayen
public Stack clone() { try { Stack result = (Stack) super.clone(); result.elements = elements.clone(); return result; } catch(CloneNotSupportedException e) { throw new AssertionError();

vegyuk eszre h az elements.clone() resultjat nem kell castolnunk Object[]-re. arrayen hiva a clone()-t egy olyan arrayt returnol amelynek runtime es compile time typejai identicalok a cloned arrayeval. ez az array duplikalas pref modja. lenyegeben az arrayek a clone() egyetlen ertelmes hasznalata

azt is vegyuk eszre h a mo nem mukodne ha az elements final lenne, mert a clone() nem tudna uj valuet assignolni a fieldhez. ez egy fundamental problem: Cloneable arch inkompat a mutable objkra refelo final fieldekkel, kiveve azokat az eseteket ahol a mutable objk safely sharelhetoek egy obj es a cloneja kozt. ahhoz h egy objt cloneable-e tegyunk, szukseges lehet eltavolitani a final modifiert egyes fieldjeirol

nem mindig eleg egyszeruen rekurzivan meghivni a clone()-t. pl. tfh hashtablehoz irunk clone()-t, amelynek a belsejeben egy array of buckets van, ahol az elemek egy key-value parokbol allo linked list elso entryjere refelnek. perf okok miatt a class a sajat lightweight singly linked listjet impl, es nem java.util.LinkedList-et haszn
public class HashTable implements Cloneable { 
  private Entry[] buckets = ...; 
  private static class Entry {
    final Object key; Object value; Entry next; 
	Entry(Object key, Object value, Entry next) { this.key = key; this.value = value; this.next = next;
  public HashTable clone() { try { HashTable result = (HashTable) super.clone(); result.buckets = buckets.clone(); return result; } catch(CloneNotSupportedException e) { throw new AssertionError();
itt csak egyszeruen rekurzivan probaltuk cloneozni a bucket arrayt, mint elobb a Stacknel. bar a clonenak igy sajat bucket arraye lesz, ez uazokra a linked listekre fog refelni mint az orig, ami konnyen nondeterm behavot okozhat az origban es a cloneban is. megoldas h le kell copyzni a linked listeket

Entry deepCopy() { return new Entry(key, value, next == null ? null : next.deepCopy()); //az adott Entry altal headelt linked list copyzasa
public Hashtable clone() {
  try { HashTable result = (HashTable) super.clone(); result.buckets = new Entry[buckets.length];
        for(int i = 0; i < buckets.length; i++) if(buckets[i] != null) result.buckets[i] = buckets[i].deepCopy();
		return result; 
  } catch(CloneNotSupportedException e) { throw new AssertionError();
  
megfelelo sizeu uj buckets arrayt allocol, es vegigiteral az orig buckets arrayen, deep-copyzva minden nonempty bucketet. a deepCopy() metodus rekurzivan invokolja sajat magat, es lecopyzza az adott Entry altal headelt teljes linked listet. ez jol fest es jol is muk ha a bucketek nem tul hosszuak, de nem tul jo modja egy LL cloneozasanak mert minden list elemre egy stack framet consumol. hosszu lista eseten ebbol stack overflow is lehet. ezt kivedendo a deepCopy()-ban levo rekurziot iterationra cserelhetjuk
Entry deepCopy() { Entry result = new Entry(key, value, next); for(Entry p = result; p.next != null; p = p.next) p.next = new Entry(p.next.key, p.next.value, p.next.next); return result;

egy masik approach komplex mutable objk cloneozasara super.clone() meghivasa, a result obj fieldjeinek besettelese az initial statejukre, vegul higher-level metodusok meghivasaval az orig obj statejenek regeneralasa. HashTable pelda eseteben a buckets fieldet egy uj bucket arrayre initeljuk, majd az itt nem bemutatott put(key, value) metodust invokoljuk a cloneozando hashtable minden key-value parjara. ez egyszeru, viszonylag elegans clone() ami nem fut olyan gyorsan mint egy olyan ami a clone internaljait direktben manipulalja. bar ez egy clean approach, szembemegy a Cloneable archal, mert felulirja az arch alapjat jelento field-by-field object copyzast
	
mikent a konstrnak, a clone() metodusnak sem szabad invokolnia egy overridolhato metodust az eppen keszuloben levo cloneon (item 19). ha clone() egy olyan metodust invokol, amelyet egy subclass overrideol, akkor ez a metodus meg azelott lefut h a subclass fixalni tudna a statejet a cloneban, ezaltal valszeg corruptalva a clonet es az origot is. ezert az elobb emlitett put(key,value) metodusnak finalnak v privatenek kell lennie (ha private akkor valszeg "helper metodus" egy nonfinal public metodus mellett)

az Object clone() metodusa dekl throws CloneNotSupportedException, de az overridolo metodusoknak nem kell. public clone() metodusok jobb ha elhagyjak a throws clauset, mert checked exct nem dobo metodusokat konnyebb haszn (item 71)

ha oroklesre designolunk classt (item 19) akkor ket lehetosegunk van, de egyiknel se impljuk a Cloneablet. egyik lehetoseg h az Object behavjat masoljuk, es egy mukodo protected clone() metodust impl ami dekl throws CloneNotSupportedException. ekkor a subclassok implhatjak Cloneablet v nem, mintha csak direktben extendalnak Objectet. masik lehetoseg h nem impl mukodo clone() metodust, hanem egy degeneralt clone()-al preventaljuk azt is h a subclassok impljanak
protected final Object clone() throws CloneNotSupportedException { throw new CloneNotSupportedException();

ha threadsafe classt irunk ami Cloneablet impl, a clone() metodusnak megfeleloen syncelve kell lennie (item 78). Object clone() metodusa nem synchronized, ezert bar a benne levo impl egyebkent megfelelo lehet nekunk, de szukseges lehet egy synchronized clone() metodust implnunk ami super.clone()-t returnol

recap, Cloneablet impl classoknak egy public metodussal kell overridolniuk clone()-t amelynek return typeja maga a class. ez a metodus eloszor hivja meg super.clone()-t, aztan fixaljon minden fieldet amit kell. ez tip minden olyan mutable obj copyzasat jelenti, amelyek az obj internal "deep structure"-jat alkotjak,  a clone refjeinek pedig a copykra kell refelniuk. ezek a copyk keszulhetnek a clone() rekurziv hivasaval is, de nem mindig ez a jo approach. ha a class csak primitiv fieldeket es immut objkra von refeket tart, akkor valszeg nincsenek fixalando fieldek. ezalol kivetelek pl. serial nrt v egyeb unique IDt repr fieldek, amelyeket akkor is fixalni kell ha primitivek v immutok

ez a komplexitas ritkan szukseges. ha olyan classt extendalunk ami mar impl Cloneablet akkor nem nagyon van mas valasztasunk mint impl egy jol muk clone() metodust. egyebkent alt az obj copy vmi alternativ modjat erdemes valasztani. pl. copy konstr v copy factory. copy konstr egy olyan konstr amely single argjanak typeja a konstr classa, pl. public Yum(Yum yum). copy factory a copy konstr static factory analogiaja (item 1), pl. public static Yum newInstance(Yum yum)

copy konstr/factory elonye Cloneable/clone()-al szemben: nem egy risky extralinguistic obj krealo mechen alapulnak; nem kivannak meg unforceable igazodast rosszul docolt conventionokhoz; nem conflictolnak a final fieldek hasznalataval; nem dobnak szuksegtelen checked exct; nem igenyelnek castolast

emellett copy konstr/factory argjanak typeja lehet a class altal impl iface. pl. conv szerint minden alt celu coll impl nyujt olyan konstrt amelynek arg typeja Collection v Map. iface-based copy konstrk, mas neven conversion konstrk/factoryk lehetove teszik h a client val meg a copy impl typejat, es nem forceolja ra a clientre az orig impl typejat. pl. s HashSet-et akarnank TreeSet-be copyzni; ezt clone() nem tam, de conv konstr egyszeru: new TreeSet<>(s)

Cloneable problemai miatt uj ifacek inkabb ne extendaljak, uj extendable classok pedig ne impljak. bar final classok eseteben kevesbe karos ha impljak, de inkabb csak akkor ha tenyleges perf optot jelent (item 67). okolszabalykent copy funct legjobb ha konstr v factory valositja meg. ez alol kivetelek az arrayek amelyek legjobban clone()-al copyzhatoak
