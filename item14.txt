ITEM 14: CONSIDER IMPLEMENTING COMPARABLE

compareTo() metodus nem az Object-ben van dekl; hanem a Comparable ifaceben. jellegeben hasonlo az Object equals()-hoz, csak nem equalityt csekkel hanem komparalast csinal, es generic. Comparabel impl-al class azt jelzi h az instanceai kozt natural ordering van. pl. array of objs sortolasa ahol az elemek impl Comparablet: Arrays.sort(a)

hasonloan egyszeru searcholni, extrem valuekat szam olyan sorted collokban amelyekben Comparable objk vannak. pl. String impl Comparable, az alabbi prg ABC-sorrendben irja ki a command line argokat, dupl eliminalva: Set<String> s = new TreeSet<>(); Collections.addAll(s, args); sout(s);

Comparable iface impl reven lehetove tesszuk h a classunk interoperaljon egy csomo generic algoval es coll impl-val amelyek ezen az ifacen dependalnak. Java platform libekben gyak osszes value class es az enum typeok (item 34) impljak. ha olyan value classt irunk, ami vmilyen natural orderinget igenyel (ABC, num, chrono) akkor impljuk

compareTo() metodus general contractja hasonlo az equals()-ehoz: "Compares this object with the specified object for order". neg intet, zerot v poz intet returnol ha ez az obj kisebb, egyenlo v nagyobb mint a specified obj. ClassCastExceptiont dob ha a specified obj typeja preventalja h komparalhato legyen a this objhoz
(sgn(expr) eredmenye -1,0,1 attol fuggoen h expr neg, zero, poz)
- bizt kell h sgn(y.compareTo(y)) == - sgn(y.compareTo(x)) minden x,y-ra (ebbol kov h x.compareTo(y) csakkor dob exct ha y.compareTo(x) exct dob)
- bizt kell h a relation tranzitiv: ha x.compareTo(y) > 0 && y.compareTo(z) > 0 akkor x.compareTo(z) > 0
- bizt kell h ha x.compareTo(y) == 0 akkor sgn(x.compareTo(z)) == sgn(y.compareTo(z)) minden z-re
- erosen ajanlott de nem feltetel, h (x.compareTo(y) == 0) == x.equals(y). minden class ami impl Comparable ifacet, de nem telj ezt a conditiont, annak ezt jeleznie kell (“Note: This class has a natural ordering that is inconsistent with equals.”)

equals() global equiv relationt kenyszerit vmennyi objra, compareTo()-nak viszont nem kell kul obj typeok kozott mukodnie: ekkor ClassCastExceptiont dobhat, es alt ezt is teszi. a contract _megengedi_ az intertype komparalast "which are typically defined in an interface implemented by the objects being compared" (?) 

ahogy egy hashCode() contractot violalo class breakelni tud mas classokat amelyek a hashingen dependalnak, ugy egy compareTo() contractot violalo class breakelni tud mas classokat amelyek a komparalason dependalnak. komparalason dependalo classok pl. a sorted collok, TreeSet/TreeMap, es a searching, sorting algokat tart util classok, Collections/Arrays

contract elso pontja: ha megford ket obj kozt a komparalas iranyat, akkor a relacio ertelemszeruen valtozik. masodik pont: egy obj nagyobb mint a masik, masik nagyobb mint a harmadik, akkor az elsonek nagyobbnak kell lennie mint a harmadik. harmadik pont: komparalas szerint equal objknak uugy kell viselkedniuk amikor egy masik objhoz komparaljuk oket

ezek egy kovetkezenye h a compareTo() altal nyujtott equality testre uazok a restrictionok von mint az equas contract(): refl, symm, trans. ezert uaz a caveat is ervenyes: instantiable classt nem lehet uj value componenttel extendalni ugy h megorizzuk a compareTo() contractot, hacsak le nem mondunk az OO abstraction benefitjeirol (item 10). workaround is uaz. ha value componentet akarunk adni egy Comparablet impl classhoz akkor ne extendaljuk; irjunk egy unrelated classt ami az elso class egy instanceat tart, es nyujtsunk egy "view" metodust ami a contained instanceot returnoli. igy a containing classon bmilyen compareTo() metodust tudunk irni, a client pedig contained class instancekent viewzhatja a containing class instanceot ha szukseges

a contract utolso pontja inkabb eros ajanlas mint req, azt mondja h a compareTo() altal nyujtott equality test alt azt az eredmenyt returnolje mint az equals(). ha ezt betartjuk akkor a compareTo() altal nyujtott ordering consistent az equals()-al. ha violaljuk, akkor inconsistent. egy class amelynek compareTo() metodusa az equals()-al incons ordert nyujt, az mukodik, de a class instanceait tart sorted collok nem biztos h betartjak a vonatkozo coll ifacek (Collection, Set, Map) contractjat. ez azert van mert ezeknek az ifaceknek a contractja az equals() szabalyai szerint van def, viszont a sorted collok a compareTo() altal nyujtott equality testet hasznaljak. erre erdemes figyelni

pl. BigDecimal compareTo()-ja incons az equals()-al. ha krealunk egy uj ures HashSet-et, addolunk bele egy new BigDecimal("1.0")-t es egy new BigDecimal("1.00")-t, akkor ket elem lesz benne mert a ket BigDecimal instance equals() szerint unequal. de ha uezt TreeSet-el csinaljuk akkor csak egy elem lesz benne mert compareTo() szerint a ket BigDecimal instance equal (ld. BigDecimal doc)

compareTo() metodus irasa hasonlo az equals() metodusehoz, par fontos kulonbseg. mivel a Comparable iface parametrized, a compareTo() metodus statically typed, ezert nem kell typecheckelni v castolni az argjat. ha az arg type nem jo, akkor le sem fordul. ha az arg null akkor az invocation NPE-t dob mihelyt a metodus megprobalja a membereket accessalni

compareTo()-ban a fieldeket orderre es nem equalityre csekkeljuk. ref fieldek komparalasahoz invokoljuk compareTo()-t rekurzivan. ha egy field nem impl Comparablet v nonstandard orderingre van szuksegunk, akkor hasznaljunk inkabb Comparatort. irhatunk sajat comparatort v hasznalhatunk existinget
public final class CaseInsensitiveString implements Comparable<CaseInsensitiveString> { public int compareTo(CaseInsensitiveString cis) { return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);
vegyuk eszre h CaseInsensitiveString Comparable<CaseInsensitiveString>-et impl. ez azt jelenti h egy CaseInsensitiveString ref csak egy masik CaseInsensitiveString-hez komparalhato. ez a normal pattern amikor Comparablet impl classt dekl

konyv korabbi verzioi azt ajanlottak h compareTo() < es > operekkel hasonlitsak az integral primitiv fieldeket es Double.compare() es Float.compare() metodusokkal a floating point primitive fieldeket. Java 7-ben static compare() metodusokat adtak hozza minden boxed primitive classhoz. ezert a < es > hasznalata compareTo()-ban innentol nem ajanlott (verbose, error-prone)

ha egy classban tobb significant field van, akkor fontos a komparalas orderje. kezdjuk a leginkabb significant fielddel, es onnan haladjunk lefele. haladjunk addig amig egy field komparalas eredmenye nem zero (nem equal) ekkor keszen vagyunk, return result; vagy jussunk el a legkevesbe significant fieldig
public int compareTo(PhoneNumber pn) { int result = Short.compare(areaCode, pn.areaCode); if(result == 0) { result == Short.compare(prefix, pn.prefix)...

Java 8-ban a Comparator ifacebe raktak comparator construction metodusokat, ami comparatorok fluent krealasat teszik lehetove. ezek a comparatorok aztan hasznalhatoak compareTo() metodusok impl soran. tomorebb syntax, de kis perf--
private static final Comparator<PhoneNumber> COMPARATOR = Comparator.comparingInt((PhoneNumber pn)->pn.areaCode).thenComparingInt(pn->pn.prefix).thenComparingInt(pn->pn.lineNum);
public int compareTo(PhoneNumber pn) { return COMPARATOR.compare(this, pn);
ha ket phone nr area codeja uaz akkor refinelni kell a komparalast, erre jo a thenComparingInt() metodus. ez a Comparator instance metodusa, ami egy int key extractor funct vesz at, es egy comparatort returnol, ami eloszor az eredeti comparatort applyolja aztan pedig az extracted key segitsegevel dont azok kozott amik addig egyformak. tetszoleges szamu thenCOmparingInt() hivas kovetheti egymast, lexicographic orderinget nyujtva. peldaban ket hivas van, ami egy olyan orderinget nyujt, ahol a secondary key a prefix, a tertiary key pedig a line nr. vegyuk eszre h nem kellett specelni az atadott a key extractor func param typejait; Java type inference ki tudta ezt talalni

Comparatorban megvannak a comparingInt() es thenComparingInt() float es double megfeleloi is. az int verziok hasznalhatok a szuksebb integral typeokra is, pl. short, mint a peldankban. double verziok hasznalhatok floatra is

obj ref tyepokra is vannak comparator construction metodusok. static comparing() metodus, ket overloadinggal. az egyik key extractort vesz at, es a key natural orderjet haszn. a masik egy key extractort vesz at, vmint egy comparatort amit az extracted keyeken kell haszn. static thenComparing() metodusnak harom overloadja. az egyik csak egy comparatort vesz at, es a secondary orderinget nyujtja. a masodik csak egy key extractort vesz at, es a key natural orderjet hasznalja secondary orderkent. a harmadik atveszi a key extractort es comparatort is, amelyet az extracted keyeken kell haszn

neha latunk compareTo() v compare() metodusokat amelyek azon alapulnak h ket value kozti diff neg ha az elso < masodik, 0 ha =, es poz ha eslo > masodik
static Comparator<Object> hashCodeOrder = new Comparator<>() { public int compare(Object o1, Object o2) { return o1.hashCode() - o2.hashCode()
ilyet ne csinaljunk, integer overflow es IEEE 754 floating point artifactok miatt. vmint perf szempontjabol sem lesz jobb mint a korabbi peldak. hasznaljunk inkabb compare() metodust
static Comparator<Object> hashCodeOrder = new Comparator<>() { public int compare(Object o1, Object o2) { return Integer.compare(o1.hashCode(), o2.hashCode());
vagy comparator construction metodust
static Comparator<Object> hashCodeOrder = Comparator.comparingInt(o -> o.hashCode());

summary: ha ertelmes orderinggel rendelkezo value classt impl, akkor impljunk a Comparable ifacet h az instanceok konnyen sortolhatoak, searchelhetoek legyenek, es hasznalhatok comparison-based collokban. compareTo() metodusokban a field valuek komparalasanal keruljuk a < es > operek hasznalatat. helyette haszn a boxed primitiv classok static compare() metodusait v a Comparator iface comparator construction metodusait

