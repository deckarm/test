ITEM 15: MINIMIZE THE ACCESSIBILITY OF CLASSES AND MEMBERS

legfontosabb tenyezo ami egy jol designolt componentet megkul egy rosszul designolttol h mennyire hidolja el az internal datajat es egyeb impl detailjeit mas componentek elol. jol designolt comp minden impl detailt elhideol, egyertelmuen separalva az APIt az impltol. compok ekkor csak az APIjukon keresztul komm es nem fogl egymas inner mukodesevel. ez az un info hiding v encaps

info hiding fontos, mert decouplolja a syst alkoto compokat, amelyek igy isolationban dev, test, optim, haszn es modifolhatok. ez gyorsitja sys devet mert compok parh fejleszthetoek. maint-- mert a compok konnyebben megerthetoek es javithatoak anelkul h mas compokat veszelyeztetnenk. info hiding onmagaban nem  perf++, de segiti a perf tuningot: ha a sys elkeszult es profiling kimutatta h mely compok okoznak perf problemat (item 67) azok a compok optimizalhatoak miozben nem bef mas compok helyesseget. info hiding sw reuset is noveli, mert a nem tightly copuled compok gyakran mas ctxben is hasznalhatoak nem csak abban ahol fejl voltak. info hiding nagy syseknel risk--, mert indiv compok jok lehetnek meg ha maga a sys nem is az

Java szamos modon tam info hidinget. access control mech spec a classok, ifacek, memberek accessibilityjet. egy entity accessibilityjet a dekl helye, es ha vannak akkor az access modifierei (private, protected, public) hat meg. ezek megfelelo haszn kulcs az info hidinghez

okolszabaly: minden class es member legyen annyira inaccessible amennyire lehetseges. maskent: haszn a lowest possible access éevelt ami a sw megfelelo funchoz szuks

top-level (non-nested) classokra es ifacekre csak package-private es public access level van. ha top-level classt v ifacet publickent dekl akkor public lesz; egyebkent package-private. ha egy top-level class v iface package-private-te teheto akkor tegyuk azza. ha package-private-te tesszuk, azzal az impl resze lesz es nem az exported APIe, es kesobbi releasekben lehet modifolni/replacelni/eliminalni anelkul h clienteket veszelyeztetnenk. ha publicka tesszuk akkor orokre supportalnunk kell a compat megorzese miatt

ha egy package-private top level classt v ifacet csak egy class haszn, akkor gondoljuk meg tegyuk inkabb az egyetlen ot haszn class private static nested classava. de accessibility csokk sokkal fontosabb egy tulsagosan nagylelku public class eseteben mint egy package-private top-level class eseteben: a public class a package APIjanak resze, mig a package-private top level class mar az impl resze

memberekre (fieldek, metodusok, nested classok, nested ifacek) negy access level van
- private: a member csak abbol a top level classbol accessible ahol dekl van
- package-private: a member accessible a package minden classabol ahol dekl van. default accessnek is nevezik, ez lesz az access level ha nincs expl access modifier megadva (kiveve az iface membereket amelyek by default publicok)
- protected: a member accessible a dekl class subclassaibol es a package minden classabol ahol dekl van
- public: a member mindenhonnan accessible

miutan megdesignoltuk a classunk public APIjat, a reflex az kell legyen h az osszes tobbi member legyen private. csak ha a packageben levo egy masik classnak mindenkeppen accessalnia kell egy membert, akkor tegyuk package-private-e. ha gyakran csinaljuk ezt, akkor vizsg felul a designt, mert lehet h tudnank jobban decouplolt classokat csinalni. private es package-private memberek a class impl reszei es tip nem impactoljak az exported APIt. de ha a class impl serializable, akkor "beleleakelhetnek" az exported APIba (item 86, 87)

public classok memberjeinel nagy valtozas ha package-privaterol protectedre modositunk. protected member a class exported APIjanak resze es orokre supportolni kell. vmint egy exported class protected memberje "represents a public commitment to an implementation detail" (item 19). protected memberekre ritkan van szukseg

ha egy metodus overridol egy superclass metodust, akkor az access nem lehet restriktivebb mint a superclassban volt. ez azert kell h bizt h egy subclass instance mindehol haszn lehessen ahol egy superclass instance (LSP, item 15). ha ezt violaljuk az compile error. spec eset ha egy class egy ifacet implt, akkor az iface minden metodusat a classban publicnak kell dekl

gyakran van az h testing tamogatasara a szuksegesnel magasabb accessible levelt akarnank beallitani egy classra, ifacere v memberre. public class private memberjet tehetjuk package-private-te a teszteles erdekeben, de annal magasabbra nem. azaz nem elfogadhato egy classt, ifacet v membert a package exported APIjanak reszeve tenni csak azert h tesztelni tudjuk. szerencsere nincs is ra szukseg mert a testek a package reszekent futhatnak igy elerik a package private elemeket

public classok instance fieldjei ritkan kell publicok legyenek (item 16). ha egy instance field nonfinal v egy mutable objra mutato ref, akkor ha publicka tesszuk azzal feladjuk annak a lehetoseget h limitaljuk a fieldben tarolhato valuekat. azaz feladjuk annak a lehetoseget h enforcoljuk a fieldet tartalmazo invariantokat.
emellett feladjuk annak a lehetoseget h a field modifolasa eseten bmilyen actiont tudjunk vegrehajtani, ezert a public mutable fieldeket tart classok alt nem threadsafek. meg ha a field final es egy immut objra ref, ha publicka tesszuk azzal feladjuk azt a flexet h egy masik internal data repr-ra csereljunk amelyben ez a field nincs benne

uez von a static fieldekre, egy kivetellel. constantokat exporolhatunk public static final fieldkent, felteve h a constantok a class altal nyujtott abstraction reszet kepezik. konv szerint ezeknek a fieldeknek nagybetuk+undescore nevei vannak (item 68). fontos h ezek a fieldek v primitiv valuekat v immut obj refeket tart (item 17). egy mutable objra von reft tart field rendelkezik egy nonfinal field minden hatranyaval. mig a ref nem modifolhato, a refelt obj igen, aminek sulyok kovetkezmenyei lehetnek

nonzero hosszu array mindig mutable, ezert ne csinaljunk egy classba public static final array fieldet v accessort ami egy ilyen fieldet returnol, mert igy a clientek modifolni tudjak az array tartalmat. ez gyakori sec hole forras. public static final Thing[] VALUES = {...};
vigyazzunk arra h IDEk altal generalt accessorok refeket returnolnek a private array fieldekre, ami pont ezt a problemat eredmenyezi
egyik mo: array public helyett private, es adjunk hozza egy public immut listet
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
masik mo: array public helyett private, es adjunk hozza egy public metodust ami a private array copyjat returnoli
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() { return PRIVATE_VALUES.clone(); }
ket mo kozott valasszunk aszerint h a client varhatoan mit csinal majd a resulttal. melyik return type lesz more convenient, melyiknek jobb a perf

Java 9 ket uj implicit access levelt hozott be a module system reszekent. a module packagek groupja, mint ahogy a package classok groupja. module expl exportolhatja a packagei egy reszet, a module declarationjeben (ami konv szerint egy module-info.java nevu src fileban van) levo export declarationok segitsegevel. unexported packagekben levo public es protected memberek a modulen kivul nem accessiblek; modulen belul az export declk nem affectaljak az accessibilityt. module sys segitsegevel sharelhetunk classokat egy module packagei kozott anelkul h az egesz vilag szamara visible tennenk oket. unexported packagekben levo public classok public es protected memberjei jelentik a ket implicit access levelt, amelyek a normal public es protected levelek intramodular analogiai. erre a fajta sharingra eleg ritkan van szukseg es gyakran eliminalhato a packagekben levo classok rearrangelesevel

a negy main access levellel szemben a ket module-based level leginkabb advisory. ha egy module jar filejat az app classpathjara tesszuk a sajat module pathja helyett, akkor a moduleban levo packagek revertalnak a non-modular behavjukra: a packagek public classainak public es protected memberjeinek a normal accessibilityje lesz, fgtl attol h a module exportalja-e a packageket. az egyetlen hely ahol az uj access levelek enforcolva vannak az maga a JDK: a Java libek unexported packagei a modulejaikon kivulrol mashonnan inaccessiblek

a modulok altal nyujtott access protection az atlag prgozo szamara limitalt jelentosegu; ahhoz h elonyet lassuk, a packageinket modulokba kell groupolni, depjeiket explicitte kell tenni a module declarationokben, atrendezni a source treet es kulon kezelni a non-modularized packagek accesset a moduljainkbol. meg nem lehet tudni h a modulok a JDK-n kivul mennyire lesznek hasznalatosak, de addig valszeg tanacsos elkerulni oket hacsak nincs ra kenyszer

summary: amennyire lehet csokk a prg elementek accessibilityjet az ertelmesseg hatarain belul. egy minimal public API megdesignolasa utan preventaljuk azt h mindenfele kobor class, iface, member az API reszeve valjon. constantkent szolgalo public static final fieldek kivetelevel public classoknak ne legyenek public fieldjei. bizt h a public static final fieldek altal refelt objk immutok


