ITEM 17: MINIMIZE MUTABILITY

immut class amelynek instanceai nem modifolhatoak. az egyes instanceokaban levo info az obj egesz elettartama alatt fix, sosem valt. Java platform libekben szamos immut class, String, boxed primitive classok, BigInteger, BigDecimal. immut classok egyszerubben design, impl, use, kevesbe error prone, jobb secu

class immut tetelehez ruleok
1. ne nyujtsunk metodusokat amik az obj statejet modifoljak (mutatorok)
2. bizt h a class ne legyen extendalhato. ez preventalja h malicious v careless subclassok kompromittaljak a class behavjat ugy teve mintha az obj stateje megvalt volna. subclassing preventalasa alt a class finalla tetelevel, de van mas mo is ld. kesobb
3. tegyuk az osszes fieldet finalla. ez kifejezi a szandekainkat "in a manner that is enforced by the system". szinten szukseges amiatt h bizt a jo behavt ha egy ujonnan krealt instance refjet egy threadbol egy masikba adjuk at sync nelkul, ld. JMM
4. tegyuk az osszes fieldet private. ez preventalja h a clientek a fieldek altal refelt mutable objkra accesstt szerezzenek es direktben modifoljak oket. bar techn lehetseges h immut classoknak public final fieldjei legyenek amelyek primitiv valuekat v immut objkra valo refeket tart, nem ajanlott mert kizarja h kesobbi releaseben megvalt az internal reprt (item 15, item 16)
5. bizt excl accesst minden mutable comphoz. ha a classunknak olyan fieldjei vannak amik mutable objkra refelnek, akkor bizt h a class clientjei ne tudjanak refet szerezni ezekre az objkra. sose initeljunk ilyen fieldet client-provided obj refre v returnoljuk a fieldet accessorbol. krealjunk def copykat (item 50) a konstrkban, accessorokban es readObject() metodusokban (item 88)

elozo itemekben latott legtobb pelda immut, pl. item11 PhoneNumber, amelynek minden attrhoz voltak accessorjai de nem voltak mutatorjai. egy kicsit komplexebb pelda
public final class Complex {
  private final double re; private final double im; public Complex(double re, double im) { this.re = re; this.im = im; }
  public double realPart() { return re; } public double imaginaryPart() { return im; }
  //plus(Complex c), minus(Complex c), times(Complex c), dividedBy(Complex c) metodusok, mindegyikuk new Complex() instancet kreal es returnol (pl. return new Complex(re + c.re, im + c.im);)
  //equals(), hashCode(), toString()

az aritm operek mind new Complex() instanceot krealnak es returnolnek, nem a thist modifoljak. ez a pattern az un func approach, mivel a metodus nem modifolja az operandusat, hanem egy funct applyol rajta es annak az eredmenyet returnoli. vs procedural/imperative approach ahol a metodusok egy proct applyolnak az operandusukon es ezzel megvalt a statejet. vegyuk eszre h a metodusnevek perpositionok (pl. plus()) es nem verbek (pl. add()), ez is jelzi h a metodusok nem valt meg az obj valuekat. pl. BigInteger/BigDecimal classok nem telj ezt a naming convt ami sok usage errorhoz is vezetett

func approach furcsanak tunhet, de lehetove teszi immutot aminek sok elonye van. immut objk egyszeruek. immut obj csak egy stateben lehet, abban amiben krealodott. ha bizt h minden konstr letrehozza a class invariantokat, akkor garantalt h ezek orokre truek maradnak, anelkul h nekunk v a classt haszn bmilyen prgozonak tennie kellene barmit. mutable objknak komplex state spaceuk lehet, es ha a doc nem nyujt preciz leirast a mutator metodusok altal vegrehajtott state transitionokrol akkor nehez v lehetetlen mutable classokat megbizhatoan haszn

immut classok inherently threadsafek; nem igenyelnek synct. tobb conc thread sem tudja oket corruptolni. ez a threadsafe eleresenek legegyszerubb modja. mivel semmilyen thread nem eszlelhet mas thread altal okozott valtozast egy immut objn, ezert szabadon sharelhetoek. ez arra osztonoz h a clientek reusoljak az existing instanceokat ahol lehetseges. ennek egy egyszeru modja ha a commonly used valuekra public static final constantokat nyujtunk, pl. a Complex classban
public static final Complex ZERO = new Complex(0,0); // ONE, I hasonloan

tovabbfejlesztes: immut class nyujthat static factorykat (item 1) amelyek becachelik a gyakran requested instanceokat, h ne kelljen ujat krealni amikor az existing is megfelel. boxed primitivek es BigInteger ezt csinalja. ily modon a clientek sharelik az instanceokat ahelyett h ujakat krealnanak, mem footprint--, GC ktg--. ha class design soran static factorykat valasztunk konstr helytt, akkor megvan a flex h kesobb cachingot tegyunk bele, anelkul h clienteket modifolni kellene

egy kovetkezmenye annak h immut objk szabadon sharelhetoek h nem kell def copykat krealni beloluk (item 50). sot egyaltalan nem kell copykat csinalni, mert minden copy orokre ekviv marad az originallal. ezert immut classnak nem kell clone() metodust v copy konstrt nyujtani (item 13). Java korai idoszakaban ezt nem ertettek jol ezert pl. String classban van copy konstr de nem ajanlott haszn (item 6)

nem csak mi sharelhatjuk az immut objkat, de ok is sharelhetik az internaljaikat. pl. BigInteger class egy internal sign-magnitude reprt haszn. a sign egy int, a magnitude egy int array. negate() metodus egy uj BigIntegert kreal azonos magnitude, ellentetes sign. nem kell lecopyznia az arrayt bar az mutable; az ujonnan krealt BigInteger uarra az internal arrayra mutat mint az orig

immut objk jo epitokovek mas (mut v immut) objkhoz. sokkal egyszerubb egy komplex obj invarjait maint, ha tudjuk h underlying objk nem fognak valt alatta. spec eset: immut objk kivaloak map keykent es set elemkent: nem ell aggodnunk h a valuejuk megvalt miutan bekerultek a mapbe v setbe (ami destroyolna a set invarjait)

immut objk ingyen nyujtjak a failure atomicityt. statejuk sosem valt, ezert nincs veszely h temp incons alljon fenn

immut objk fo hatranya h minden distinct valuera kulon obj kell. ezek megkrealasa ktges lehet foleg ha nagyok. pl. millio bites BigInteger low-order bitjet akarjuk megvalt. BigInteger moby = ...; moby = flipBit(0);
flipBit() egy uj BigInteger instanceot kreal, ami szinten millio bit hosszu, es csak egy bitben kul az origtol. ez az oper a BigInteger sizeal aranyos timeot es spacet igenyel. vs java.util.Bitset: szinten egy bit seqt repr, de mutable; es nyujt egy metodust amellyel konstans timeban lehet egy millio bites instance egy bitjet megvalt. BitSet moby = ...; moby.flip(0);

perf problema sokszorozodik ha multistep opert hajtunk vegre amely minden stepben uj objt general, es a vegen az utolso kivetelevel mindegyiket discardolja. ketfele mo approach. az egyik h guesseljuk h mely multistep operek lesznek commonly required es nyujtsuk oket primitivekkent; ekkor az immut classnak nem kell minden stepben kulon objt krealnia. internally az immut class tetszolegesen okos lehet. pl. BigIntegernek van egy package-private mutable "companion classa", aminek celja a multistep operek gyorsitasa pl. modular exponentiation. ezt sokkal nehezebb lenne haszn mint a BigIntegert a korabbiakban felsorolt okok miatt (?): de nem kell hasznalnunk mert a BigInteger keszitoi elvegeztek a munkat helyettunk

package-private mutable companion class approach jol muk, ha meg tudjuk josolni h a clientek mely komplex opereket akarjak az immut classunkon vegrehajtani. ha nem, akkor nyujtsunk egy _public_ mutable companion classt. erre legjobb pelda a String, amelynek mutable companionja a StringBuilder (+ obsolete StringBuffer)

design alternativak. mint irtuk immut garantalasahoz a classnak nem szabad engednie a subclassingot. ez elerheto ha finalla tesszuk a classt de van flexebb alternativa. tegyuk az immut class minden konstrjat private v package-private, es hasz public static factorykat a public konstrk helyett (item 1)
private Complex(double re, double im) {...
public static Complex valueOf(double re, double im) { retun new Complex(re, im);

ez az approach gyakran a legjobb alternativa. ez a leginkabb flex mert tobb package-private impl class hasznalatat teszi lehetove. a packagen kivuli clientjei szamara az immut class eff final mert nem lehet extendalni egy olyan classt ami packagen kivulrol jon es nincs public v protected konstr. a tobb impl class altal nyujt flex mellett ez az approach lehetove teszi a perf tunolasat kesobbi releasekben, ha a static factoryk obj cachingjet tudjuk javitani

BigInteger es BigDecimal irasakor meg nem ertettek h az immut classoknak eff final kel lenniuk, ezert a metodusaik overridolhatoak. sajnos ezt nem lehet javitani a bw compat miatt. ha olyan classt irunk amelynek secje egy untrusted clienttol erk Biginteger/BigDecimal argon dependal, akkor csekkelnunk kell h az arg egy "valodi" Biginteger/BigDecimal v egy untrusted subclass instance. ha az utobbi akkor def copyznunk kell, mert felt kell h mutable (item 50)
public static BigInteger safeInstance(BigInteger val) { return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());

az immut classokra von ruleok azt mondjak h metodusok nem modifolhatjak az objt es minden fieldjenek finalnak kell lennie. ezek egy kicsit szigoruak es perf++ okbol lazithatoak. valojaban a metodus externally visible valtozast nem okozhat az obj statejeben. de egyes immut classoknak lehetnek nonfinal fieldjei amelyek cachelik a ktges szamitasok eredmenyeit az elso alkalommal. ha uazt a valuet ujra requestelik akkor a cached value lesz returnolve, megsporolva az ujraszamitas ktget. ez a trukk pontosan azert muk mert az obj immut ami garantalja h a szamitas ismetelten is uazt az eredmenyt adja

pl. item 11 PhoneNumber hashCode() az elso invokolaskor kiszam a hashcodeot, es becacheli arra az esetre ha ujbol invokoljak. ez a techn a lazy init (item 83) egy peldaja, String is ezt haszn

ha az immut classunk Serializablet impl es vannak fieldjei amelyek mut objkra ref, akkor explicit readObject() v readResolve() metodust kell nyujt, v az ObjectOutputStream.writeUnshared() es ObjectInputStream.readUnshared() metodusokat haszn, meg akkor is ha a default serialized form acceptable. egyebkent egy tamado krealhatna egy mutable instanceot a classunkbol, ld. item 88

ofoglalva ne akarjunk minden getterhez settert irni. classok legyenek immutok, hacsak nincs ra nagyon jo ok h mutok legyenek. immut classoknak szamos elonye van, es az egyetlen hatranyuk az esetleges perf prob bizonyos korulmenyek kozt. kis value objk mint PhoneNumber v Complex mindig legyenek immutok (Java platform libekben szamos class van, pl. java.util.Date v java.awt.Point amelyek immut kellettek volna legyenek de nem lettek). nagyobb value objk eseteben mint amilyen a String v BigInteger is erosen ajanlott az immut. immut class melle nyujtsunk public mut companion classt ha perf ok van ra (item 67)

vannak classok ahol az immut nem praktikus. amennyiben egy class nem lehet immut, probaljuk csokk a mutabilityjet amennyire lehet. ha csokk a statek szamat amelyben az obj lehet, egyszerubb lesz az obj es kisebb error vg. ezert tegyunk minden fieldet finalla hacsak nincs jo ok arra h nonfinal legyen. ezt osszehangolva item 15-ben irtakkal: dekl minden fieldet private finalkent hacsak nincs jo ok h maskent tegyunk

konstrk fully inited objkat krealjanak, beallitva az invarokat. ne nyujtsunk a konstr v static factory mellett meg mas public init metodust is, hacsak nincs ra nagyon jo ok. ne nyujtsunk "reinit" metodust ami lehetove teszi h egy objt ugy reusoljunk mintha mas init state-tel lett volna krealva. az ilyen metodusok keves perf++, uakkor complexity++

CountDownLatch jo pelda. mut, de a state space szandekosan kicsi. megkrealunk egy instanceot, es ha a countja elerte a 0-t akkor tobbet nem reusolhato

megj. a Complex pelda csak az immut illusztralasara szolgalt, egyebkent nem production szintu class (pontatlan kerekites, NaN, infinit kezeles)