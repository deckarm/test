ITEM 18: FAVOR COMPOSITION OVER INHERITANCE

inheritance code reuse jo modja, de nem mindig a legjobb. ha nem jol haszn akkor fragile. packagen belul safe, ahol a superclass es a subclass uazon prgozok fennhatosaga alatt van. szinten safe ha extensionra designolt es docolt classt extendalunk (item 19). de package boundaryken keresztul inheritelni ordinary concrete classokbol veszelyes. az "inheritance" alatt ez a konyv impl inheritancet ert (ahol egy class egy masikat extendal). az ebben az itemben leirtak nem von az iface inheritancere (ahol egy class egy ifacet impl v egy iface egy masikat extendal)

metodus invokolassal ellentetben az inher violalja az encapst. maskent, a subclass dependal a superclassanak az impl detailjein, azert h jol mukodjon. superclass impl releasenkent valtozhat es ha valt, akkor a subclass breakelhet meg ha az o kodjahoz nem is nyultunk. emiatt a subclassnak a superclassaval egyutt kell evolvalodnia, kiveve ha a superclass szerzoi kifejezetten extensionra designoltak es docoltak

pl. prgunk HashSetet haszn. prg perf tune erdekeben queryzni akarjuk a HashSetet h mennyi elemet addoltak hozza a krealasa ota (nem keverendo ossze a size-al ami egy elem removolasaval csokk). ehhez egy olyan HashSet valtozatot irunk ami nyilvantartja a megkiserelt elem insertionoket es exportal egy accessort erre countra
public class InstrumentedHashSet<E> extends HashSet<E> {
  private int addCount = 0;
  public InstrumentedHashSet() {} 
  public InstrumentedHashSet(int initCap, float loadFactor) { super(initCap, loadFactor);
  public boolean add(E e) { addCount++; return super.add(e);
  public boolean addAll(Collection<? extends E> c) { addCount += c.size(); return super.addAll(c);
  public int getAddCount() { return addCount;

jol nez ki, de nem muk. tfh krealunk egy instanceot es addAll()-al rakunk bele harom elemet (Java 9-ben hozzaadott List.of() static factory metodust haszn, korabbi releaseben Arrays.asList()). InstrumentedHashSet<String> s = new InstrumentedHashSet<>(); s.addAll(List.of(...));
ezen a ponton azt varnank h a getAddCount() 3-at returnol, de 6-ot fog. internally a HashSet addAll() metodusa az add() metodus tetejere van impl, ami a HashSet docjabol nem derul ki, helyesen, hiszen impl detail. az InstrumentedHashSet() addAll()-ja hozzaadott 3-at az addCount-hoz, majd super.addAll()-al invokolta a HashSet addAll()-jat, ami invokolta az InstrumentedHashSet-ben overridolt add() metodust, minden elemre egyszer; ezek mindegyike hozzaadott meg 1-et az addCount-hoz, ugyhogy vegul az eredmeny 6 lett

megprobalhatnank "javitani" a subclasst ugy h ne overridolja az addAll() metodust. ez mukodne, de a helyes muk azon dependalna h a HashSet addAll() metodusa az add() tetejere van impl. ez a "self-use" egy impl detail, nem garantalt h a Java platform osszes impljaban igy van, es releasenkent valtozhat is. igy egy ilyen InstrumentedHashSet class fragile lenne

ennel kicsivel jobb lenne ugy overridolni az addAll() metodust h iteraljon vegig a collon es minden elemre egyszer hivja meg add()-et. ez attol fgtl garantalna a jo eredmt h a HashSet addAll() metodusa h van implva, mert az a tovabbiakban nem lenne invokolva. de ez nem old meg minden problemat. ez is superclass metodusok reimpljahoz vezet amik lehet h "self-use"-olnak, ami nehezkes, time-consuming, error-prone es perf-- lehet. es nem is mindig lehetseges mert egyes metodusok nem implhatoak a subclass szamara inaccessible private fieldek accessalasa nelkul

fragility masik oka subclassokban h a superclassukba az ujabb releasekben mas metodusok is bekerulhetnek. tfh egy prg secuja azon dependal h egy collba beinsertelt minden elem kielegit vmi predicatet. ez farantalhato ugy h subclassoljuk a collt es overridolunk minden olyan metodust ami elemet addol, h bizt h a predicate teljesuljon az elem addolas elott. ez jol muk addig amig egy kov releaseben nem adunk hozza egy uj metodust ami elemet tud addolni. ha ez megtortenik akkor onnantol lehetseges "illegal" elemet addolni azaltal h invokoljuk az uj metodust amit a subclass nem overridol. ez nem csak elmeleti prob, szamos ilyen sec holet kellett fixalni amikor a Hashtable es Vector classokat retrofitteltek a coll fwbe

mindket leirt prob a metodus overridolasbol szarm. gondolhatnank h ugy safe egy classt extendalni ha csak uj metodusokat adunk hozza, es nem overridolunk existing metodusokat. ez a fajta extension safer, de nem risk mentes. ha a superclassba uj releaseben uj metodus kerul, es tortenetesen a subclassunkban van egy metodus auazzal a signatureval de mas return typeal, akkor a subclass tobbe nem fog lefordulni. amennyiben a subclassban az uj superclass metodussal azonos signatureval es return typeal volt metodus, akkor innentol overridolas van, es fennallnak a fent leirt problemak. es kerdeses az is h a mi metodusunk telj-e az uj superclass metodus contractjat, hiszen az meg nem letezett amikor megirtuk a subclass metodust

fenti problemak elkerulhetoek ha egy existing class extendalasa helyett az uj classba teszunk egy private fieldet ami az existing class egy instanceara refel. ez a composition, mert az existing class az uj class egy componentje lesz. az uj class minden instance metodusa invokolja az existing class instance megfelelo metodusat. ezt ugy hivjak h forwarding, az uj class metodusai pedig a forwarding metodusok. az uj class igy solid lesz, es nem fog dependelni az existing class impl detailjein. meg ha uj metodust is adunk az existing classhoz, annak sem lesz impactja az uj classra. 
InstrumentedHashSet composition-forwarding approachal (impl ket reszre bontva, maga a class es egy reusable forwarding class ami kizarolag a forwarding metodusokat tart)
public class InstrumentedSet<E> extends ForwardingSet<E> {
  private int addCount = 0;
  public InstrumentedSet(Set<E> s) { super(s);
  public boolean add(E e) { addCount++; return super.add(e);
  public boolean addAll(Collection<? extends E> c) { addCount += c.size(); return super.addAll(c);
  public int getAddCount() { return addCount;
public ForwardingSet<E> implements Set<E> {
  private final Set<E> s;
  public ForwardingSet(Set<E> s) { this.s = s;
  public void clear() { s.clear(); } //... osszes tobbi Set metodus uigy

az InstrumentedSet class designjat a Set iface segiti, amely "captures the functionality of the HashSet class". robust es flex design. az InstrumentedSet class impl a Set ifacet, es az egyetlen konstr argja szinten Set. lenyegeben a class egy Set-et egy masikba transformal, es hozzaadja az instrumentation funct. az inheritance-based approachal szemben, amely csak egy concrete classra mukodott, es a superclass minden konstrhoz kulon konstr kellett, ez a wrapper class bmilyen Set implt instrumentalni tud, es bmilyen existing konstral egyutt tud mukodni. 
Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp)); 
Set<E> s = new InstrumentedSet<>(new HashSet<>(INIT_CAPACITY));
sot arra is hasznalhato h temp instrumentaljunk egy set instancet amelyet mar instr nelkul is hasznaltunk
static void walk(Set<Dog> dogs) { InstrumentedSet<Dog> iDogs = new InstrumentedSet<>(dogs); //...metodus hatralevo reszeben iDogs-ot haszn dogs helyett

InstrumentedSetet wrapper classnak hivjuk mert minden InstrumentedInstance tart (bewrappel) egy masik Set instancet. ez uaz mint a GOF Decorator pattern, mert az InstrumentedSet class az instrumentationnal "dekoral" egy setet. composition es fwding kombojat neha delegationnak is hivjak (techn nem delegation, hacsak a wrapper obj nem adja at magat a wrapped objnak)

wrapper class egyik hatranya h nem jol haszn callback fwkben, ahol objk self-refeket adnak at mas objknak kesobbi invocation (callback) celjabol. mivel egy wrapped obj nem tud a wrapperjerol, ezert sajat magarol ad at egy refet (this), igy a callbackek elkerulik a wrappert. ez az un SELF problema. szoktak aggodni a fwding metodus invocationok perf impactja v a wrapper objk mem footprintje miatt, de gyak egyik se prob. fwding metodusokat irni unalmas, de minden ifacehez csak egyszer kell megirni a reusable fwding classt, ill fwk nyujtanak is fwding classokat (pl. Guava minden coll ifacehez nyujt)

inheritance csak olyan korulmenyek kozt jo ahol a subclass valoban subtypeja a superclassnak. maskent, B class csakkor extendelje A classt ha is-a kapcs van a ket class kozt. tegyuk fel a kerdest: "is every B really an A?", es ha nem tudunk igennel valaszolni ra, akkor B ne extendalja A-t. ha a valasz nem, akkor gyakran az van h B tartalmazzon egy private A instanceot, es exposoljon egy mas APIt: A nem essential resze B-nek, csak az impljanak egy detailje

Java platform libekben szamos vio van erre. pl. stack nem vector, ezert Stacknak nem kellene Vectort extendalnia. property list nem hashtable ezert Properties-nek nem kellene Hashtablet extendalnia. mindket esetben composition kellett volna

ha inheritancet haszn ott ahol compositiont kellene, akkor foloslegesen exposoljuk az impl detaileket. az igy eredmenyezett API az orig implhoz kot minket, es orokre megkoti a classunk perfjet. az internalok exposolasa lehetove teszi h clientek direktben accessaljak oket. ez legjobb esetben is confusing semanticshoz vezet. pl. ha p egy Properties instancera refel, akkor p.getProperty(key) mas eredmenyt adhat mint p.get(key): az elobbi metodus figybe veszi a defaultokat, az utobbi viszont, ami Hashtablebol oroklodik, nem. legrosszabb esetben a client corruptolhatja is a subclass invarjait, amikor direktben modifolja a superclasst. Properties eseteben a designerek azt akartak h csak stringek legyenek a keyek es valuek, de az underlying Hashtablehoz valo direkt access violalhatja ezt az invart. es ha egyszer violalodott akkor a Properties mas reszeit (load(), store()) sem lehet hasznalni. mire ezt eszrevettek mar nem lehetett javitani, mert clientek mar dependaltak a non-string keyek es valuek hasznalatan

kerdesek amiket tegyunk fel mielott inheritancet hasznalnank composition helyett. vannak flawk az extendalni kivant class APIjaban? ha igen, akkor azt akarjuk h ezek a mi classunk APIjaba is belekeruljenek? inheritance orokiti a superclass APIban levo flawkat mig compositionnal uj APIt designolhatunk ami elhidolja ezeket

summary: inheritance powerful, de problemas is, mert violalja encapst. akkor van letjogosultsaga ha tenyleges subtype kapcs van a superclass es subclass kozt. meg ekkor is lehet fragility, ha a subclass mas packageben van, es ha a superclasst nem inheritancere designoltak. ezt elkerulendo haszn compositiont es fwdingot inkabb, foleg ha letezik egy megfelelo iface amivel wrapper classt tudunk impl. wrapper classok more robust es powerful mint subclassok