ITEM 19: DESIGN AND DOCUMENT FOR INHERITANCE OR ELSE PROHIBIT IT

item 18 felhivta a figyelmet egy "foreign" class subclassolasanak veszelyeire, amit nem inheritancere designoltak es docoltak

classnak precizen docolnia kell metodus overridolas hatasait. maskent, classnak docolnia kell "its self-use of overridable methods". minden public v protected metodusra a docnak jeleznie kell h mely overridable metodusokat invokol, milyen sorrendben, es az invokolasok eredmenyei h befolyasoljak a tovabbi processinget (overridable alatt nonfinal es public v protected metodust ertunk). altalanosabban, classnak docolnia kell minden esetet amelyben egy overridable metodust invokolhat. pl. invokolas johet bg threadtol v static initializerbol

metodus ami overridable metodusokat invokol, a docja vegen, az "Implementation Requirements" reszben (Javadoc @implSpec tag) kell ezeket leirja
pl. java.util.AbstractCollection.remove() metodusnal itt jelzi h az iterator() metodus overridolasa befolyasolja a remove() behavjat. vs item 18 ahol HashSet subclassolasanal nem lehetett tudni h add() overridolasa befolyasolja addAll() behavjat

vegyuk eszre h ez violalja az eloirast h egy jo API docnak azt kell leirnia h egy metodus "mit" csinal es nem azt h "hogyan". ez kovetkezmenye annak h inheritance violalja encapst. ahhoz h docoljunk egy classt h safely subclassolhato legyen, impl detaileket kell leirnunk, amiknek egyebkent unspec kellene maradniuk

@iplSpec tag Java 8-ban kerult be, es Java 9-ben mar gyakran haszn. defaultbol enablelve kellene lennie de Java 9-ben a Javadoc utility meg mindig ignoralja, amit a -tag "apiNote:a:API Note:" command line switchel oldhatunk meg

inheritancere designolni tobbet jelent mint a self-use patternek docolasa. ahhoz h prgozok hatekony subclassokat tudjanak irni, classnak lehet h hookokat kell nyujtani a sajat internal mukodesebe, gondosan megvalasztott protected metodusokkal v ritkabban protected fieldekkel 
pl. java.util.AbstractList.removeRange() docjabol kiderul, h List implk end userei szamara nem erdekes; azert krealtak h subclassok gyors clear() metodust tudjanak nyujtani sublisteken. enelkul a subclassoknak quadratic perffel kellene dolgozniuk, v teljesen ujrairni a subList() mecht

hogy dontjuk el mely protected membereket exposolunk amikor inheritancere designolunk classt? nincs general mo. lehetoleg minel kevesebb protected membert exposoljunk, mert mindegyik egy impl detail commitmentet repr. de tul keveset se, mert egy missing protected member inheritancere hasznalhatatlanna teheti a classt

inheritancerer designolt class tesztelesenek egyetlen modja ha subclassokat irunk. ha kihagyunk egy critical protected membert akkor az egy subclass iras soran fajdalmasan fog kiderulni. hasonloan, ha megirtunk szamos subclasst es egy biz protected membert egyik se haszn, akkor az valszeg private teheto. tapasztalat szerint harom subclass alt eleg egy extendable class tesztelesere; ezek kozul legalabb egyet ne a superclass szerzoje irjon

amikor inheritancere designolunk egy olyan classt amit valszeg szeles korben fognak haszn, legyunk tudataban h orokre commitolunk a ledocolt self-use patternekre, es a protected metodusok es fieldek altal jelentett implicit impl decisionokre. eze nehezze v lehetetlenne tehetik a perf++ v func modositast kesobbi releasekben. ezert subclassok irasaval tesztelnunk kell a classunkat mielott releaselnenk

vegyuk eszre h az inheritancere von spec doc cluttereli a normal docot ami azoknak a prgozoknak szol, akik csak instanceokat akarnak krealni a classunkbol es azokon metodusokat invokolni. konyv idopontjaban toolsok nem igazan tam a ketfele doc szetvalasztasat

par tovabbi restriction amiket classoknak be kell tart az inheritance tamhoz. konstrk ne invokoljanak overridable metodusokat, se direkt se indirekt. ha ezt violaljuk abbol prg failure lesz. superclass konstr a subclass konstr elott fut, ezert a subclassban levo overriding metodus azelott fog invokolodni h a subclass konstr lefutott. ha az overriding metodus bmilyen initen dependal amit a subclass konstr hajt vegre, a metodus nem ugy fog muk ahogy varnank
public class Super { 
  public Super() { overrideMe(); } 
  public void overrideMe() {}
public final class Sub extends Super { 
  private final Instant instant; //blank final, konstr setteli be
  Sub() { instant = Instant.now();
  public void overrideMe() { sout(instant); //superclass konstr altal invokolt overriding metodus
  main() { Sub sub() = new Sub(); sub.overrideMe();

azt gondolnank h ez ketszer fogja kiirni az instantot, de elsore nullt fog, mert a Super() konstr invokolja az overrideMe() metodust mielott a Sub() konstr initelne az instant fieldet. vegyuk eszre h a prg ketfele stateben is lat egy final fieldet. azt is vegyuk eszre h ha overrideMe() vmilyen metodust probalna invokolni az instanton, abbol NPE lenne amikor a Super() konstr invokolja az overrideMe()-t; ez csak azert nem tortenik mert a sout toleralja a null argot is

private metodusok, final metodusok, static metodusok nem overridolhatok, ezeket safe konstrbol invokolni

Cloneable es Serializable iface nehezsegeket okoz ha inheritancere designolunk. alt nem jo otlet inheritancere designolt classoknak ezeket impl mert terhet ro a classt extendalo prgozokra. de vannak spec actionok amelyekkel lehetove tehetjuk h subclassok impljak ezeket az ifaceket anelkul h kotelezo lenne (item 13, item 86)

ha ugy dontunk h inheritancere designolt classban impljuk Cloneablet v Serializablet akkor figyelnunk kell mert a clone() es a readObject() metodusok hasonloan muk a konstrkhoz, es ezert egy hasonlo restriction is von rajuk: clone() es readObject() ne invokoljon overridolhato metodust, se direkt se indirekt. readObject() eseteben az overriding metodus azelott fog lefutni h a subclass stateje deserializalodott volna. clone() eseteben az overriding metodus azelott fut le h a subclass clone() metodusa fixalhatna a clone statejet. mindket esetben valszeg prghiba lesz. clone() eseteben ez a clonet es az orig objt is karosithatja; pl. ha az overriding metodus azt felt h o most az obj deep structjarol keszult clone copyt modifolja, de a copy valojaban meg el sem keszult

ha inheritancere designolt classban Serializablet impl, es a classnak van readResolve() v writeReplace() metodusa akkor az protected es nem private legyen. ha private lenne akkor a subclassok csondben ignoralnak. ez is egy olyan eset ahol egy impl detail a class APIjenek reszeve valik h lehetove tegye az inheritancet

msostanra vilagos h inheritancere designolni egy classt effortot igenyel, es limiteket rak a classra. vannak esetek ahol ez a helyes dontes, pl. abstract classok, beleertve ifacek skeletal impljait (item 20). mas esetekben nem jo dontes, pl. immut classok (item 17)

ordinary concrete classok tip sem nem finalok, se nincsenek subclassingra designolva es docolva, ami nem szerencses. valahanyszor egy ilyen classban valt, eselyes h a subclassai breakelhetnek. ez nem csak elmeleti problema, gyakran jonnek subclassing-related bug reportok miutan egy olyan nonfinal concrete class internaljait modifoljak ami nem inheritancere lett designolva es docolva

legjobb mo ha megakadalyozzuk az olyan classok subclassingjat amelyek nem ugy lettek designolva es docolva h safely subclassolhatoak legyenek. erre ket mod van. az egyszerubb ha finalkent dekl a classt. masik mo ha minden konstr private v package-private es helyettuk public static factorykat haszn. ez flexet nyujt sublassok internal hasznalatara, ld item 17

ez a javaslat furcsanak tunhet mert sok prgozo ahoz szokott h ordinary concrete classokat subclassoljon azert h insrtumentationt, notifot, syncet adjon hozza v funcot limiteljen. ha egy class impl egy olyan ifacet ami "captures its essence", mint Set, List, Map akkor ne aggodjunk a subclassing megakadalyozasa miatt. item18-ban leirt wrapper class az inheritancenel jobb alternativat nyujt a func modositasara

he egy concrete classunkat nem impl standard ifacet akkor egyes prgozokat zavarhat ha megakadalyozzuk az inheritancet. ha ugy erezzuk h muszaj megengednunk az inheritancet egy ilyen classbol akkor egy jo approach ha bizt h a class sosem invokolja az overridable metodusait, es ezt le is docoljuk. igy a classunk eleg safe lesz a subclassingra. egy metodus overridolasa sosem fogja mas metodusok behavjat affectalni

mechanikusan is tudjuk eliminalni h egy class hasznalja az overridable metodusait. mozgassuk minden overridable metodus bodyjat es private "helper metodusba" es minden overridable metodus invokolja a sajat private helper metodusat. majd csereljuk le minden overridable metodus meghivasat az overridable metodus private helper metodusanak direkt invokolasaval

summary: class inheritancere designolasa nehez. le kell docolnunk minden self-use patternjet, es ezutan commitolni ezekre a class egesz elete soran. ha nem igy teszunk akkor a subclassok dependalhatnak a superclass impl detailjein, es breakelhetnek ha a superclass impl valtozik. ahhoz h masok hatekony subclassokat irhassanak, exportalhatnunk kell egy v tobb protected metodust. hacsak nem tudjuk azt h tenylegesen szukseg van subclassokra, jobb ha megakadalyozzuk az inheritancet ugy h finalkent dekl a classt v bizt h ne legyenek accessible konstrk
