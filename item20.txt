ITEM 20: PREFER INTERFACES TO ABSTRACT CLASSES

Javaban ket mech olyan type defre, ami multiple implt tesz lehetove: ifacek es abstract classok. miota Java 8 behozta az ifacekben levo default metodusokat, azota mindket mech segitsegevel tudunk instance metodusokra implt nyujtani. fo kul h egy abstract class altal def type impljahoz a classnak az abstract class subclassanak kell lennie. mivel a Java csak egyszeres inheritancet tam, ez a restriction jelentosen constraineli az abstract classok hasznalatat type defkent. bmely class amely def minden required metodust es betartja a general contractot, implhat egy ifacet, fgtl attol h hol helyezkedik el a class hierben

existing classok konnyen retrofittelhetok h uj ifacet impljanak. csak hozza kell adni a required metodusokat ha meg nem leteznek, es hozzaadni az implements clauset a class deklhoz. pl. szamos existing classt retrofitteltek h impl Comparable, Iterablev Autocloseable ifaceket amikor azokat hozzaadtak a platformhoz. existing classok alt nem retrofittelhetoek h extendaljanak egy uj abstract classt. ha azt akarjuk h ket class uazt az abstract classt extendalja akkor eleg magasra kell tenni a type hierben h mindket class ose legyen. sajnos ez komoly collateral damaget okozhat a type hierben, mivel az uj abstract class minden descendantjat forcolja h subclassoljak, fgtl h kell-e nekik vagy nem

ifacek segitsegevel jol lehet mixint def. mixin egy olyan type amit egy class a "primary type"-ja mellett implhat, azt deklva h vmi optional behavot nyujt. pl. Comparable egy mixin iface ami lehetove teszi h egy class azt dekl h az instanceai "are ordered with respect to other mutually comparable objects". egy ilyen ifacet mixinnek hivnak mivel lehetove teszi h az optional func "mixed in" legyen a type primary funcja mellett. abstract classok uabbol az okbol nem haszn mixin defre mint amiert nem retrofittelhetok existing classokba: classnak nem lehet egynel tobb parentje, a class hierben pedig nincs reasonable hely ahova be lehetne egy mixint tenni

ifacek lehetove teszik nonhier type fwk kialakitasat. type hierek jok egy csomo dolog organizalasara, mas dolgok viszont nem ill jol egy rigid hierbe. pl. tfh egyik iface singert masik iface songwritert repr
public interface Singer { AudioClip sing(Song s);
public interface Songwriter { Song compose(int chartPosition);
irl egyes singerek songwriterek is. mivel ifaceket es nem abstract classokat haszn, teljesen OK ha egy class mindket ifacet impl. sot defhatunk egy harmadik ifacet amely a fenti kettot extendalja, es tovabbi metodusokat is def
public interface SingerSongwriter extends Singer, Songwriter { AudioClip strum(); void actSensitive();

nem mindig kell ilyen szintu flex, de ha igen, akkor az ifacek eletmentoek. az alternativa egy bloated class hier lenne, ami kulon classt tart minden supported attr kombinaciora. ha a type sysben n attr van, az 2^n supportalando kombinaciot jelent. ez az un combinatorial explosion. bloated class hierek pedig bloated classokhoz vezetnek, amelyekben szamos metodus csak az arg typejaikban kul, mivel a class hierben nincsenek olyan typeok amelyek capturolni tudnak a common behavot

ifacek safe, powerful func enhancementet tesznek lehetove a wrapper class idiom segitsegevel (item 18). ha abstract classokat haszn type defre, akkor a funct hozzaadni kivano prgozonak nem marad mas alternativaja mint az inheritance. az igy krealt classok kevesbe powerful es more frgaile mint a wrapper classok

ha egy iface metodusra letezik nyilvanvalo impl, akkor nyujthatunk egy default metodust. ld. item 21 removeIf(). ha default metodust nyujtunk akkor docoljuk le inheritancerer az @implSpec JavaDoc tag segitsegevel (item 19)

default metodusokra vannak limitek. bar szamos iface speceli az Object metodusok behavjat (equals(), hashCode()), de nem nyujthatunk rajuk default metodusokat. ezenkivul ifacekben nem lehetnek instance fieldek v nonpublic static memberek (private static metodusok kivetelevel). vmint nem adhatunk default metodusokat olyan ifacehez amit nem mi controllalunk

kombinalhatjuk az ifacek es abstract classok elonyeit, ha az iface melle nyujtunk egy abstract skeletal implementation classt. az iface def a typeot, esetleg nyujt default metodusokat, a skel impl class pedig impl a maradek non-primitiv iface metodusokat, a primitiv iface metodusok tetejere. skel impl extendalasa "takes most of the work out of implementing an interface". ez a GOF template method pattern

onv szerint a skel impl classok elnevezese Abstract"Interface" ahol Interface az iface neve amit implnak. pl. a coll fw skel implt nyujt minden fo coll iface melle: AbstractCollection, AbstractSet, AbstractList, AbstractMap. egyesek szerint "Abstract" helyett jobb lenne "Skeletal", de a konv mar megszilardult. ha jol vannak megdesignolva, a skel implk (akar kulon abstract class, v csak az iface default metodusai) nagyon konnyuve tehetik h prgozo sajat implt nyujtson egy ifacere. pl. static factory metodus, amely teljes func List implt nyujt az AbstractList tetejere
static List<Integer> intArrayAsList(int[] a) {
  Objects.requireNonNull(a);
  return new AbstractList<>() { //diamond csak Java 9-tol muk; korabbi releaseben <Integer> ki kell irni
    public Integer get(int i) { return a[i]; } //set(), size() metodusok szinten overridolva
	
ha figyelembe vesszuk h mit nyujt egy List impl akkor ez a pelda jol mutatja a skel implk erejet. ez egyben pelda a GOF adapter patternre, int arrayt viewolhatjuk Integer instanceok listjakent. a boxingok es unboxingok miatt a perfje nem tul jo. vegyuk eszre h ez egy anon class (item 24)

skel impl classok szepsege h nyujtjak az abstract classok altal nyujtott minden impl segitseget, azok nelkul a constraintek nelkul amiket az abstract classok kenyszeritenek amikor ok szolg type defkent. ha egy ifacenek van skel impl classa, akkor az iface implementaloi szamara jo valasztas ennek a classnak az extendalasa, de persze nem kotelezo. ha nem tudjuk megoldani h a classunk a skel implt extendalja, akkor meg mindig implhatjuk az ifacet direktben. meg igy is lehet profitalni az iface altal nyujtott default metodusokbol. ezenkivul a skel implt meg mindig felhasznalhatjuk ugy h az ifacet impl class az iface metodusok invokolasat fwdolja egy private inner classnak ami a skel implt extendalja. ez az un simulated multiple inheritance techn, ami rokona az item 18 wrapper idomnak; a multiple inheritance szamos benefitjet nyujtja, pitfallok nelkul

skel impl keszitese egyszeru. nezzuk meg az ifacet es allapitsuk meg h melyek a primitiv metodusok "in terms of which the others can be implemented". ezek lesznek az abstract metodusok a skel implban. ezutan nyujtsunk default metodust az ifaceben minden olyan metodusra amely direktben implhato a primitivek tetejere (ne felejtsuk el h Object metodusokra mint equals(), hashCode() nem nyujthatunk default metodust). ha a primitiv es default metodusok lefedik az ifacet akkor megvagyunk es nincs szukseg skel impl classra. egyebkent irjunk egy classt ami impl az ifacet, amiben a maradek iface metodusok impljai vannak. a classban lehetnek nonpublic fieldek es metodusok is

pl. Map.Entry iface. nyilvanvalo primitivek a getKey(), getValue() es esetleg a setValue(). az iface speceli az equals() es hashCode() behavot, es az is egyertelmu h kell a toString()-et impl. mivel az Object metodusaira nem nyujthatunk default implt, ezert ezeknek az implknak a skel impl classba kell kerulnie
public abstract class AbstractMapEntry<K,V> implements Map.Entry<K,V> {
  public V setValue(V value) { throw new UnsupportedOperationException(); //modif mapban levo entryknek overridolniuk kell
  //equals(), hashCode(), toString() implk
vegyuk eszre h ez a skel impl nem implhato a Map.Entry ifaceben v subifacekent mert default metodusokkal nem overridolhatjuk az Object metodusokat

mivel a skel implk inheritancere vannak designolva, ezert be kell tart az item19-ben leirt design es doc guidelineokat. rovidseg kedveert ebben a peldaban nem voltak docok, de egyebkent a jo doc elengedhetetlen a skel implkban, akar ifaceben levo default metodusokrol akar kulon abstract classrol van szo

skel impl egy minor valtozata a simple impl, pl. AbstractMap.SimpleEntry. simple impl ~ skel impl, ifacet impl es inheritancere van designolva, de nem abstract: o a simplest possible working implementation. korulmenyektol fuggoen hasznalhatjuk as it is, v subclassolhatjuk

summary: iface alt a legjobb mod olyan type defra ami multiple implt tesz lehetove. ha egy nontrivial ifacet exportalunk akkor fontoljuk meg h nyujtsunk melle skel implt is. a skel implt a leheto legszelesebb korig probaljuk az ifacebe tett default metodusokkal nyujtani, h az iface minden implja hasznalni tudja oket. de ifacekre von restrictionok alt szuksegesse teszik h a skel implt abstract class formajaban nyujtsuk
