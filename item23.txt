ITEM 23: PREFER CLASS HIERARCHIES TO TAGGED CLASSES

neha belefuthatunk olyan classba amelynek az instanceai ket v tobb flavoruak lehetnek, es egy tag field jelzi h melyik flavor ervenyes
class Figure {
  enum Shape { RECTANGLE, CIRCLE };
  final Shape shape; //tag field - az adott figure milyen shape
  double length, width; //csak RECTANGLE shapeben relevans fieldek
  double radius; //csak CIRCLE shapeben relevans field
  Figure(double radius) { shape = Shape.CIRCLE; this.radius = radius; } Figure(double length, double width) { shape = Shape.RECTANGLE; ... }
  //area() metodus, benne case RECTANGLE, case CIRCLE
  
az ilyen tagged classoknak szamos hatranya van. tele vannak boilerplattel, pl. enum dekl, tag fieldek, switchek. nehezen olvashato mert tobb impl van egy classba osszezsufolva. mem footprint++, mert az instanceokban benne vannak a mas flavorokhoz tartozo irrelevans fieldek is. fieldek nem tehetok finalla, csak ha a konstrk initelik az irrelevans fieldeket, ami szinten boilerplate. konstrnak be kell settelnie a tag fieldet es initelni a megfelelo datat a compiler segitsege nelkul: ha nem jo fieldeket initelunk akkor a prg runtime failelni fog. nem adhatunk uj flavort egy tagged classhoz csak ha modifoljuk a sourceot. ha uj flavort adunk hozza akkor minden switchez uj case agat kell adnunk, kulonben runtime fail lesz. vegul egy instance data typeja nem mond semmit a flavorjerol. roviden, tagged class verbose, error-prone es nem hatekony

OO nyelvek mint pl. Java jobb alternativat nyujtanak arra h egy single data type tudjon tobb obj flavort repr: subtyping. tagged classok csak a class hier gyenge utanzatai

ha tagged classt class hierbe akarunk transformalni, eloszor def egy abstract classt, amely a tagged class minden, a tagtol fuggo behavju metodusahoz tart egy abstract metodust. Figure classban csak az area() metodus ilyen. ez az abstract class lesz a class hier rootja. ha vannak olyan metodusok amelyek behavja nem dependal a tag valuejan, azokat tegyuk ebbe a classba. hasonloan ha vannak olyan data fieldek amelyeket minden flavor haszn, azokat is tegyuk ebbe a classba. Figure classban nincsenek flavor-indep metodusok v fieldek

ezutan def a tag minden flavorjahoz a root class egy concrete subclassat. a peldaban ezek circle es rectangle. minden subclassba vegyuk fel a flavornak megfelelo fieldeket. itt radius a circlehez, length es width a rectanglehez tart. vmint tegyuk minden subclassba a root class abstract metodusainak megfelelo impljat
abstract class Figure { abstract double area();
class Circle extends Figure { final double radius; Circle(double radius) { this.radius = radius; } double area() { ... }
class Rectangle extends Figure { final double length, width; Rectangle(double length, double width) { ... } double area() { ... }

ez a class hier javitja a tagged classok minden fent emlitett hatranyat. a kod egyszeru es tiszta, nincs boilerplate. minden flavor implja sajat classaban van, es egyik classban sincsenek irrelevans data fieldek. minden field final. a compiler bizt h minden class konstr initeli a data fieldjeit es minden classnak van implja a root classban dekl minden abstract metodusra. ez eliminalja a missing switch case miatti runtime fail lehetoseget. tobb prgozo extendalhatja a hiert egymastol fgtl, es a root class source accesse nelkul. minden flavorhoz separate data type tart, igy prgozok jelezhetik egy var flavorjet es tudnak varokat es input paramokat egy biz flavorra restrictelni

class hierek masik elonye h ki lehet veluk fej a typeok kozti natural hier kapcsolatokat, ami flex++ es jobb compile type checking. tfh az eredti tagged classban square is van. class hierrel ki lehet fej h a square egyben rectangle is (felteve h mindketto immut)
class Square extends Rectangle { Square(double side) { super(side, side);

vegyuk eszre h a hierben a fieldek direktben voltak accessalva es nem accessor metodusokkal. ez a rovidseg kedveert volt, de ha a hier public lenne akkor nem lenne szerencses (item 16)

summary: tagged classok ritkan jok. ha explicit tag fieldet tart classt akarnank irni, gondoljuk at h nem tudnank-e inkabb class hierrel megcsinalni. ha existing classt talalunk tag fielddel, akkor gondoljuk at h hierbe refactoroljuk
