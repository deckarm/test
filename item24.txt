ITEM 24: FAVOR STATIC MEMBER CLASSES OVER NONSTATIC

nested class egy masik classban def class. feladata kizarolag az enclosing class kiszolgalasa. amennyiben a nested class mas ctxben is hasznalhato lenne, akkor top-level classnak kellene lennie. nested classok negy fajtaja: static member class, nonstatic member class, anon class, local class. az elso kivetelevel ofogl nevuk inner classok

static member class a legegyszerubb nested class. legjobb ugy gondolni ra mint ordinary class, amely tortenetesen egy masik classok belul lett dekl, es accesse van az enclosing class minden memberehez, meg a privatekhez is. static member class az enclosing classanak static membere, es uazok az accessibility ruleok von ra mint a tobbi static memberre. ha privatekent van dekl, akkor csak az enclosing classbol accessalhato stb.

static member class egy gyakori peldaja a public helper class, amely csak az outer classaval egyutt muk. pl. enum, ami egy calculator altal tam opereket irja le (item 34). az Operator enum a Calculator class public static membere kell legyen. a Calculator clientjei az operekre Calculator.Operation.PLUS stb. nevekkel tudnak hiv

szintaktikailag a static es nonstatic member classok kozti egyetlen kul h static member classok dekljaban ott van a static modifier. a syntax has ellenere a ketfajta nested class nagyon kul. egy nonstatic member class minden instancea impliciten assoc az ot containelo class egy enclosing instanceaval. nonstatic member class instance metodusaival metodusokat invokolhatunk az enclosing instanceon v reft obtainelhetunk az encosing instancera a qualified this segitsegevel. ha egy nested class instance isolationban letezhet az enclosing class instancetol, akkor a nested classnak staticnak KELL lennie: mert nem lehetseges nonstatic member class instanceot krealni egy enclosing instance nelkul

nonstatic member class instance es az enclosing instance kozti assoc akkor jon letre amikor a member class instance megkrealodik, es ezutan nem modifolhato. normal esetben az assoc autom letrejon, amikor az enclosing class egy instance metodusabol invokoljuk a nonstatic member class konstrat. lehetseges, bar ritka a kapcst manually letrehozni, az enclosingInstance.new MemberClass(args) expressionnal. az assoc spacet foglal a nonstatic member instanceban, a krealasa pedig timeba telik

nonstatic member class egy gyakori hasznalata a GOF adapter pattern, ami lehetove teszi h az outer class egy instanceat vmi unrelated class egy instanceakent viewoljuk. pl. Map iface impljai tip nonstatic member classokat haszn a collviewjaik impljara, amelyeket a Map keySet(), entrySet89, values() metodusai returnolnek. hasonloan a coll ifacek (Set, List) impljai tip nonstatic member classokat haszn az iteratoraik impljahoz
public class MySet<E> extends AbstractSet<E> {
  public Iterator<E> iterator() { return new MyIterator(); }
  private class MyIterator implements Iterator<E> { ... }
  
ha olyan member classt dekl, ami nem igenyel accesst enclosing instancehoz, akkor az mindig legyen static. ha kihagynank a modifiert akkor minden instance egy folosleges hidden reft tartana az enclosing instancera. amint emlitettuk, ez spacebe es timeba kerul. nagyobb problema h oda vezethet h az enclosing instance retainelve lesz akkor amikor egybkent GC-eligible kellene legyen (item 7). az igy letrejovo mem leak komoly problemakat is okozhat; detektalni viszont nehez mert a ref invisible

private static member classok gyakori haszn, az enclosing classuk altal repr obj componentjeinek repr. pl. Map instance, key-value parokkal. szamos Map implban van egy internal Entry obj minden key-value parhoz. bar minden entry kapcs a maphez, az entry metodusainak (getKey(), getValue(), setValue()) nem kell accessalniuk a mapet. ezert pazarlas lenne nonstatic member classt haszn az entryk reprjara; private static member class jobb. ha veletlenul kihagynank a static modifiert az entry deklbol, a map ugy is muk fog, de minden entry egy folosleges refet fog tart a mapre, ami space es time ktg

meg fontosabb helyesen val a static es a nonstatic member classok kozt ha a kerdeses class egy exported class public v protected memberje. ebben az esetben a member class egy exported API element es kesobbi releasekben nem valtoztathato meg nonstaticrol staticra bw compat vio nelkul

anon classnak nincs neve. nem membere az enclosing classnak. nem a tobbi memberrel egyutt dekl, hanem a felh helyen van egyszerre dekl es instantiated. anon classok a kod minden pontjan megengedettek ahol egy expr legal. anon classoknak csakkor van enclosing instancea ha nonstatic ctxben vannak. de meg ha static ctxben is vannak, nem lehet masfajta static memberuk mint constant varjaik, amelyek final primitive v string fieldek, constant exprre initelve

anon classoknak szamos limitje van. csak a dekl helyen instantialhatoak. nem hajthatunk vegre rajtuk instanceof teszteket v bmi mast amihez meg kellene nevezni a classt. nem implhatnak tobb ifacet v extendalhatnak classt es implhatnak ifacet egyszerre. anon class clientjei csak azokat a membereket invokolhatjak amelyeket a superclassatol orokol. mivel az anon classok exprk kozepen vannak, ezert celszeru h rovidek legyenek (max 10 sor) kulonben az olvashatosag rovasara megy

lambdak hozzaadasa elott (item 42) anon classok voltak a kis func objk v process objk on-the-fly krealasanak pref modja. anon classok masik gyak haszn modj a static factory metodusok implja (item 20, intArrayAsList())

local classok a nested classok legritkabban haszn valtozata. local class gyak barhol deklhato ahol egy local var deklhato, es uazok a scoping ruleok von ra. member classokhoz hasonloan van nevuk es tobbszor is hasznalhatoak. anon classokhoz hasonloan csakkor van enclosing instanceuk ha nonstatic ctxben vannak def, es nem tarthatnak static membereket. es anon classokhoz hasonloan celszeru h rovidek legyenek az olvashatosag erdekeben

recap, negyfele nested class van es mindegyiknek megvan a helye. ha egy nested classnak visible kell lennie egy single metoduson kivul v nem lehet oda kenyelmesen beilleszteni, akkor haszn member classt. ha a member class minden instance refet kell tartson az enclosing instanceara akkor legyen nonstatic; egyebkent legyen static. felteve h egy class egy metodusba tartozik, ha csak egy helyrol kell instanceokat krealni es van egy preexisting type ami leirja a classt, akkor haszn anon classt; egyebkent haszn local classt