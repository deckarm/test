ITEM 26: DON’T USE RAW TYPES

class v iface amely dekljaban egy v tobb type param van, un generic class v iface. pl. List ifacenek egy E type paramja van, ami az element typejat repr. iface teljes neve List<E> ("list of e") de roviden csak Listnek szoktak nevezni. generic classok es ifacek ofogl neve generic types

minden generic type parametrized typeok egy setjet def, amely tart a class v iface nevet majd pedig az actual type paramok listajat, amelyek a generic typeok formal type paramjainak felelnek meg. pl. List<String> ("list of string") egy parametrized type, ami egy olyan listet repr, amelynek elementjei Stringek (String az actual type param, ami megfelel a formal E type paramnak)

vegul, minden generic type def egy raw tyeot, ami a generic type neve, a type paramok nelkul. pl. a List<E>-hez kapcs raw type a List. raw typeok ugy vislekednek mithat minden generic type infot kitoroltunk volna a type deklbol. csak a pre-generics koddal valo kompat miatt leteznek

genericsek hozzaadasa elott igy nezett volna ki egy coll dekl. Java 9-ben ez meg mindig legal, de nem kovetendo: private final Collection stamps = ...

amennyiben ezt a deklt ma haszn es veletlenul egy coint raknank a stamp collunkba, a hibas insert compilol es hiba nelkul le is fut (bar a compiler dob egy kicsit homalyos "unchecked call" warningot): stamps.add(new Coin(...));

a hiba csak akkor fog kibukni amikor retrievelni probaljuk a coint a stamp collbol
for(Iterator i = stamps.iterator(); i.hasNext(); ) Stamp stamp = (Stamp) i.next(); //ClassCastExceptiont dob

alapelv h errorokat a megtortentuk utan minel hamarabb celszeru felfedezni, idealis ha compile time. itt csak runtimeban bukik ki, joval azutan h elkovettuk es egy olyan helyen ami messze is lehet a hiba tenyleges helyetol. ClassCastException eszrevetele utan keresnunk kell a kodban h hol van az a metodus invocation ami coint tett a stamp collba. a compiler ebben nem segit nekunk

genericsek hasznalataval a type dekl tart a szukseges infot. private final Collection<Stamp> stamps = ...

ebbol a deklbol a compiler tudja h a stamps csak Stamp instanceokat tarthat es garantalja h igy is lesz; amennyiben a teljes codebase warningok (v suppressalasuk, item 27) nelkul lefordul. ha a stamps parametrized type decl segitsegevel van dekl akkor hibas insertion compile time error msgt general ami pontosan megmondja h mi a gond: "error: incompatible types: Coin cannot be converted to Stamp"

a compiler invisible castokat nyujt amikor collbol retrievelunk elemeket es garantalja h ezek nem fognak failelni (megint csak amennyiben a codebaseben nincsenek warningok). bar a coin inserteles stamp collba kisse mesterseges pelda, de pl. konnyen elofordulhat h veletlenul BigIntegert raknank egy collba amiben csak BigDecimal instancek lehetnenek

mint irtuk, raw typeok hasznalata legal, de ne csinaljuk, mert igy elvesztjuk a genericsek altal nyujtott safetyt es expresivenesst. csak a bw compat miatt vannak a nyelvben. pl. legalnak kell lennie ha parametrized typeok instanceait adjuk at olyan metodusoknak amiket raw typeokra designoltak, es forditva. emiatt az un. migration compatnak nevezett requirement miatt vannak tovabbra is tam a raw typeok, es vannak a genericsek erasure segitsegevel impl (item 28)

mig raw typeokat mint List ne hasznaljunk, arbitryr objk inserteleset lehetove tevo parametrized typeok hasznalata teljesen OK, pl. List<Object>. lazan fogalmazva a List nem resze a generic type sysnek, a List<Object> viszont explicit megmondja a compilernek h bmilyen typeu objk lehetnek benne. List<String>-et atadhatunk egy List typeu paramnak, egy List<Object> typeu paramnak viszont nem. genericsekre von subtyping szerint List<String> subtypeja a raw List typenak, de nem subtypeja a parametrized List<Object> typenak (item 28). ha raw typeot haszn akkor elvesztjuk a type safetyt, de ha parametrized typeot akkor nem

main() { List<String> strings = new ArrayList<>(); unsafeAdd(strings, Integer.valueOf(42)); Strings s = strings.get(0); //compiler-generated cast
private static void unsafeAdd(List list, Object o) { list.add(o);
ez lefordul, de a raw List type miatt warning: "warning: [unchecked] unchecked call to add(E) as a member of the raw type List: list.add(o);"
ha megprobaljuk lefuttatni akkor ClassCastException lesz amikor a prg a strings.get() invocation eredmenyet, ami Integer, Stringbe probalja castolni. ez egy compiler-generated cast ami helyes hasznalat eseten sikerulne, de itt most ignoraltunk egy compiler warningot es rafizettunk

ha a raw List typeot egy parametrized List<Object> typera csereljuk az unsafeAdd() deklban, akkor mar compile timeban latszik a hiba: "error: incompatible types: List<String> cannot be converted to List<Object>: unsafeAdd(strings, Integer.valueOf(42));"

csabitonak tunhet h raw typeot haszn egy collra amelynek elementy typeja unknown es nem szamit. pl. metodus ami ket setet vesz at es visszaadja a kozos elemek szamat
static int numElementsInCommon(Set s1, Set s2) { ... for(Object o1:s1) if(s2.contains(o1))...
muk, de raw typeok haszn veszelyes. a safe alternativa az unbounded wildcardok hasznalata. ha generic typeot akarunk haszn, de nem tudjuk v nem erdekel h mi az actual type param, akkor haszn egy kerdojelet. pl. a generic Set<E> type unbounded wildcard typeja Set<?> (set of some type). ez a legaltalanosabban parametrized Set type, ami _bmilyen_ setet tarthat
static int numElementsInCommon(Set<?> s1, Set<?> s2) { ... }

unbounded wildcard type Set<?> es a raw type Set kozti kuk h az elobbi safe, az utobbi nem. raw typeu collba berakhatunk bmilyen elemet, es ezaltal corruptalhatjuk a coll type invarjat (ld. unsafeAdd() fentebb); Collection<?>-ba viszont null elementen kivul nem rakhatunk mas elemet. ha megis megprobaljuk az compile-time error: "error: incompatible types: String cannot be converted to CAP#1: c.add("verboten"); where CAP#1 is a fresh type-variable: CAP#1 extends Object from capture of ?"
ez az error msg nem tul beszedes, de a compiler megtette amit kellett azaz preventalta h corruptaljuk a coll type invarjat, fgtl attol h mi volt az element typeja. nem csak h nem rakhatunk bele nullon kivul mas elemet Collection<?>-ba, de nem is feltetelezhetunk semmit a belole kigettelt objk typejarol. amennyiben ezek a megkotesek nem elfogadhatoak, akkor haszn generic metodusokat (item 30) v bounded wildcard typeokat (item 31)

van nehany minor exc a "ne hasznaljunk raw typeokat" rulera. class literalokra raw typeot kell haszn. spec ezekre nem engedi  a parametrized typeok hasznalatat (bar az array es primitive typeokat engedi). azaz List.class, String[].class, int.class legal, de List<String>.class es List<?>.class nem az

masik exc az instanceof oper. mivel a generic type info runtime erased, ezert az instanceof opert nem lehet parametrized tyeokon haszn, az unbounded wildcard tyepok kivetelevel; utobbi hasznalata raw typeok helyett nem bef az instanceof oper behavjat, a "<?>" itt csak zaj
if(o instanceof Set) Set<?> s = (Set<?>) o;
vegyuk eszre h ha megallapitottuk h o egy Set akkor a Set<?> wildcard typera kell castolnunk es nem a raw Set typera. ez egy checked cast tehat nem fog compiler warningot okozni

summary: raw typeok haszn runtime exchoz vezethet, ezert ne haszn. csak a legacy koddal valo compat miatt leteznek meg. Set<Object> parametrized type, ami egy olyan setet repr, amelyben bmilyen typeu objk lehetnek. Set<?> wildcard type ami olyan setet repr ami vmilyen unknown typeu objkat tart. Set raw type ami nem resze a generic sysnek. parametrized es wildcard safe, raw nem

referenciatabla
parametrized type: List<String>
actual type param: String
generic type: List<E>
formal type param: E
unbounded wildcard: List<?>
raw type: List
bounded type param: <E extends Number>
recursive type bound: <T extends Comparable<T>>
bounded wildcard type. List<? extends Number>
generic method: static <E> List<E> asList(E[] a)
type token: String.class
