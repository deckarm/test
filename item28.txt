ITEM 28: PREFER LISTS TO ARRAYS

array ket fontos szempontbol kul a generic typeoktol. egyreszt arrayek covariantok. azaz ha Sub a Super subtypeja, akkor a Sub[] array type subtypje a Super[] array typenak. genericsek viszont invariantok: bmely ket Type1 es Type2 eseten List<Type1> se nem supertypeja se nem subtypeja a List<Type2>-nek. ebbol ugy tunik mintha a genericsek defektesek lennenek de valojaban az arrayek defektesek
pl. az alabbi kod legal, de runtime ArrayStoreException
Object[] objectArray = new Long[1]; objectArray[0] = "I dont fit in"; 
ez viszont le sem fordul, a dekl compile error, incompatible types
List<Object> ol = new ArrayList<Long>(); ol.add("I dont fit in");
egyik modon sem rakhatunk Stringet egy Long containerbe, de array eseteben a hiba csak runtime derul ki, listnel viszont compile time

masodik kul h array reified. ez azt jelenti h egy array csak runtimeban tudja es enforcolja az element typejat. mint lattuk ha Stringet probalunk egy Long arraybe berakni, akkor ArrayStoreException lesz. genericsek viszont erasure-el vannak impl. ez azt jelenti h CSAK compile timeban enforcoljak a type constraintjeiket, runtime viszont discardoljak (eraselik) az element type infojukat. erasure reven tudnak a generic typeok egyuttmukodni a legacy koddal (item 26)

ezek fundamental kulonbsegek, ezert arrayek es genericsek nem muk jol egyutt. pl. nem lehet arrayt krealni generic typeal, parametrized typeal v type parammal (new List<E>[], new List<String>[], new E[] mindegyike compile time generic array creation error) 

generic array krealas azert illegal mert nem typesafe. ha legal lenne akkor a compiler altal generalt castok runtime ClassCastExceptiont eredmenyeznenek, ami violalna a generic type sys altal nyujtott garanciakat
List<String>[] stringLists = new List<String>[1]; List<Integer> intList = List.of(42); Object[] objects = stringLists; objects[0] = intList; String s = stringLists[0].get(0);
tfh az elso stmt ami egy generic arrayt krealna, legal. a masodik stmt megkreal es initel egy List<Integer>-t ami egy elemet tart. harmadik stmt egy Object array varba tarolja a List<String>-et ami legal, mert az arrayek covariantok. negyedik stmt berakja a List<Integer>-t az Object arraybe ami sikerul mert a genericsek erasureel vannak impl: egy List<Integer> instance runtime typeja List, egy List<String>[] instance runtime typeja pedig List[] tehat ez nem okoz ArrayStoreExceptiont. de most gond van: eltaroltunk egy List<Integer> instanceot egy arraybe ami ugy volt dekl h csak List<String> instanceokat tud tarolni. az utolso sttmttel retrieveljuk az arrayben levo listben levo egyetlen elemet. compiler autom castolja a retrievelt elemet Stringbe, de az elem Integer tehat runtime ClassCastException lesz. ezt akarjuk elkerulni, ezert valojaban az elso stmt (a generic array krealas) compile error lesz

typeok mint E, List<E> es List<String> az un nonreifiable typeok. intuitive nonreifiable type az amelynek a runtime reprja kevesebb infot tart mint a compile time reprja. az erasure miatt az egyetlen parametrized type ami reifiable, azok az unbounded wildcard typeok mint List<?> es Map<?,?> (item 26). ezert legal, bar ritkan hasznos unbounded wildcard typeokbol allo arrayt krealni

az h nem lehet generic arrayt krealni, zavaronak tunhet. ez pl. azt is jelenti h alt nem lehetseges h egy generic coll az element typejanak egy arrayet returnolje (ld. item 33 reszleges mo). azt is jelenti h zavaro warningokat kapunk ha vararg metodusokat (item 53) haszn generic typeokkal. ez azert van mert valahanyszor invokolunk egy vararg metodust, a vararg paramok tarolasara egy array krealodik. ha ennek az arraynek az element typeja nem reifiable, akkor warningot kapunk. ezt a helyzetet SafeVarargs annoval tudjuk kezelni (item 32)

ha generic array creation errort v array typera castolasnal unchecked cast warningot kapunk, legjobb mo alt a List<E> coll type hasznalata az E[] array type helyett. ez tomorseg/perf-- lehet, de cserebe safety/interoperability++

pl. Chooser classt akarunk irni, konstr egy collt vesz at es egy metodus ami egy random elemet returnol a collbol. attol fuggoen h milyen collt adunk at a konstrnak, valaszthatunk h milyen fajtaju legyen a chooser. egyszeru impl generics nelkul
public class Chooser {
  private final Object[] choiceArray;
  public Chooser(Collection choices) { choiceArray = choices.toArray();
  public Object choose() { Random rnd = ThreadLocalRandom.current(); return choiceArray[rnd.nextInt(choiceArray.length)];
ahhoz h hasznaljuk ezt a classt, a choose() return valuejat Objectbol mindig castolni kell a kivant typeba amikor invokoljuk a metodust, es a cast runtime failelni fog ha rossz typeot haszn

generikus mo kiserlet, ami nem fordul le
public class Chooser<T> {
  private final T[] choiceArray;
  public Chooser(Collection<T> choices) { choiceArray = choices.toArray();
  //choose() uaz
forditasi hiba: "error: incompatible types: Object[] cannot be converted to T[] choiceArray = choices.toArray(); where T is a type-variable: T extends Object declared in class Chooser"

probaljuk javitani h Object arrayt T arrayba castoljuk
choiceArray = (T[]) choices.toArray();
az error eltunik, de helyette warning: "warning: [unchecked] unchecked cast choiceArray = (T[]) choices.toArray(); required: T[], found: Object[] where T is a type-variable: T extends Object declared in class Chooser"
compiler azt mondja h nem garantalt a runtime cast safetyje, mert a prg nem fogja tudni h T milyen typeot repr - emlekezzunk h az element type info runtime eraselodik a genericsbol. prg mukodni fog, de a compiler ezt nem tudja bizonyitani. ha mi igen, akkor elsupperessalhatjuk a warningot annoval es megkommentezhetjuk, de jobb ha a warning okat szuntetjuk meg (item 27)

az unchecked cast warning eliminalasahoz haszn listet array helyett
public class Chooser<T> {
  private final List<T> choiceList;
  public Chooser(Collection<T> choices) { choiceList = new ArrayList<>(choices);
  public T choose() { Random rnd = ThreadLocalRandom.current(); return choiceList.get(rnd.nextInt(choiceList.size()));
ez a verzio kicsit verboseabb es kicsit lassabb is, de megeri azert h ne legyen runtime ClassCastException

summary: arrayek es genericsek type rulejai nagyon kul. arrayek covariantok es reifiedek; genericsek invariantok es erasedek. ezert az arrayek runtime type safetyt nyujtanak de compile-time safetyt nem; genericsek pedig forditva. szabaly h arrayek es genericsek nem keverhetoek jol. ha megis kevernenk oket es compile-time errorokat v warningokat kapnank, akkor az elso gondolatunk legyen az h arrayeket listekre kellene cserelni