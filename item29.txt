ITEM 29: FAVOR GENERIC TYPES

alt nem tuk nehez a deklk parametrizationja, es a JDK altal nyujtott generic typeok es metodusok felhasznalasa. sajat generic typeokat irni kicsit nehezebb, de megeri megtanulni
pl. item 7 Stack impl, Object[] elemekkel dolgozik
ennek parametrizednek kellett volna lennie, de mivel nem volt az, ezert utolag mar nem lehet generifyolni anelkul h az eredeti non-parametrized verzio clientjei ne breakeljenek. ebben a formajaban a clientnek castolnia kell a stackbol kipoppolt objkat, es ezek a castok runtime elfailelhetnek. class generifyolasa soran az elso lepes type param(ok) hozzaadasa a deklhoz. itt most egy type param van, ami a stack element typejat repr, ennek a conv szerinti neve E (item 68)

kov lepes az Object type minden elofordulasanak lecserelese a megfelelo type paramra
public Stack<E> {
  private E[] elements;
  public Stack() { elements = new E[DEFAULT_INITIAL_CAPACITY];
  public void push(E e) { ... }
  public E pop() { ... E result = elements[--size]; ...

  ilyen autom lecserelesek utan alt lesz vmi error v warning, itt most egy van: "error: generic array creation: elements = new E[DEFAULT_INITIAL_CAPACITY];"
item28-ban leirtaknak megfeleloen non-reifiable typebol, mint E, nem lehet arrayt krealni. ez a problema mindig felmerul amikor olyan generic typeot irunk amit egy array backel. ket modon oldhato meg. az egyik megkeruli a generic array creationt: helyette Object arrayt kreal, es azt atcastolja a generic array typera. ez error helyett warningot okoz; legal use, de alt nem typesafe
"warning: [unchecked] unchecked cast found: Object[], required: E[] elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];"

a compiler nem tudja bebiz h a prg typesafe, de mi igen, amennyiben be tudjuk latni h az unchecked cast nem veszelyezteti a prg type safetyjet. az elements array private fieldben van tarolva es sosincs clientnek returnolve v bmely mas metodusnak atadva. az arrayben tarolt elemek csak a push() metodusnak lesznek atadva, ami E typeot hasznal, tehat az unchecked cast nem okozhat kart

ha sikerult belatnunk h az unchecked cast safe, akkor suppressaljuk el a leheto legszukebb scopeon (item 27). itt a konstr csak az unchecked array creationt tart, tehat a warning elsuppressalhato a konstron. ezt kovetoen a class mar tisztan lefordul, es tudjuk hasznalni explicit castok nelkul, ill nem kell attol felnunk h ClassCastException lesz
@SuppressWarnings("unchecked") public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY];
magyarazo komment lehet: "The elements array will contain only E instances from push(E). This is sufficient to ensure type safety, but the runtime type of the array won't be E[]; it will always be Object[]!"

masik mod a generic array creation error eliminalasara ha az elements field typejat valt meg E[]-rol Object[]-ra. ekkor masmilyen error lesz
"error: incompatible types found: Object, required: E, E result = elements[--size];"
ha az arraybol retrievelt elemet E-re castoljuk, akkor error helyett warning lesz
"warning: [unchecked] unchecked cast found: Object, required: E, E result = (E) elements[--size];"

mivel az E non-reifiable type, ezert nincs mod ra h a compiler tudjon vmit mondani a runtime castrol. itt megint csak be tudjuk biz h az unchecked cast safe, tehat a warningot el lehet suppressalni. csak az unchecked castot tart assignmenten suppressaljuk el, nem az egesz pop() metoduson
@SuppressWarnings("unchecked") E result = (E) elements[--size];
magyarazo komment lehet: "push requires elements to be of type E, so cast is correct"

mindket generic array creation eliminalo technikanak megvannak az elonyei. az elso olvashatobb: az arry type E[]-kent van dekl, ami egyertelmuen jelzi h csak E instanceokat tart. tomorebb: egy tip generic classban a kod szamos pontjan olvasunk az arraybol; az elso techn csak egy castot igenyel (ahol az array krealva van), a masodik viszont separate castot minden alkalommal amikor egy array elementet kiolvasunk. ezek miatt az elso techn a pref, es gyakrabban haszn. viszont heap pollutiont (item 32) okoz: az array runtime typeja nem uaz mint a compile-time typeja (hacsak az E nem pont Object). emiatt vannak prgozok akik inkabb a masodik technt valasztjak, bar a heap pollution ebben az esetben nem okoz kart

az alabbi prg mutatja a generic Stack class hasznalatat. command line argok kiirasa forditott sorrendben es uppercaseben. nincs szukseg explicit castolasra ahhoz h a String toUpperCase() metodust meg tudjuk hivni a stackbol kipoppolt elemeken, es az autom cast garantaltan sikerulni fog
main() { Stack<String> stack = new Stack<>(); for(String arg: args) stack.push(arg); while(!stack.isEmpty()) sout(stack.pop().toUpperCase());

ez a pelda ellentmondasnak tunhet item 28-hoz kepest, ami a listek hasznalatat tam az arrayekkel szemben. nem mindig lehetseges v kivanatos listeket haszn a generic typejainkban. Java nem tem a listeket nativan, ezert egyes generic typeokat, pl. ArrayList az arrayek tetjere KELL impl. mas generic typeok, pl. HashMap perf okok miatt vannak arrayek tetejere impl

a generic typeok tobbsege olyan mint a Stack peldank, amennyiben is a type paramjaikra nincsenek restrictionok: krealhatunk Stack<Object>, Stack<int[]>, Stack<List<String>> v Stack bmilyen mas obj ref typeal. vegyuk eszre h nem krealhatunk Stacket primitiv typeal: Stack<int> v Stack<double> compile-time error lesz. ez a Java generic sysnek egy fundamental limitationja; workaround lehet a boxed primitive typeok hasznalata (item 61)

vannak generic typeok amelyek restrictelik a type paramjaik lehetseges valuejait. pl. java.util.concurrent.DelayQueue
class DelayQueue<E extends Delayed> implements BlockingQueue<E>
a type param list (<E extends Delayed>) azt mondja h az actualy E type param a java.util.concurrent.Delayed subtypeja kell legyen. ez lehetove teszi h a DelayQueue impl es a clientjei a Delayed metodusait tudjak haszn a DelayedQueue elemeit, explicit castolas v ClassCastException veszely nelkul. az E type param neve bounded type param. vegyuk eszre h a subtype relation szerint minden type subtypeja sajat maganak, tehat legal DelayQueue<Delayed> krealni

summary: generic typeok safebbek, es konnyebben haszn mint az olyan typeok amelyek castolast igenyelnek a client kodban. ha uj typeokat designolunk, gondoskodjunk rola h ilyen castok nelkul lehessen oket haszn. ez gyakran azt jel h tegyuk oket genericke. ha vannak olyan existing typejaink amelyeknek genericnek kell lenniuk, akkor generifyoljuk oket. ez konnyebbe teszi a typeok uj usereinek helyzetet, es nem breakeli az existing clienteket (item 26)

