ITEM 30: FAVOR GENERIC METHODS

amint a classok ugy a metodusok is lehetnek genericek. static util metodusok amelyek parametrized typeokon operalnak alt genericek. Collections class "algo" metodusai (binarySearch(), sort()) genericek

generic metodust irni hasonlo mint generic typeot irni. pl. az alabbi metodus raw typeokat haszn
public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result;
lefordul, de ket warninggal
"warning: [unchecked] unchecked call to HashSet(Collection<? extends E>) as a member of raw type HashSet: Set result = new HashSet(s1);"
"warning: [unchecked] unchecked call to addAll(Collection<? extends E>) as a member of raw type Set: result.addAll(s2);"

ezeket ugy tudjuk megfixalni es a metodust typesafe tenni, ha dekl egy type paramot, amely repr a harom set element typejat (ket arg es a return value) es ezt a type paramot haszn a metodusban. a type param list, ami a type paramokat dekl, a metodus modifierjei es a return typeja koze kerul a deklban. itt a type param list <E>, a return type pedig Set<E>. type paramokra von naming convk uazok a generic metodusokra mint a generic tyeokra (item 29, item 68)
public static <E> Set<E> union(Set<E> s1, Set<E> s2) { Set<E> result = new HashSet<>(s1); result.addAll(s2); return result;

egyszeru generic metodusokra ez minden. ez igy warningok nelkul lefordul, type safetyt nyujt es konnyu haszn. pl. az alabbi prg hivhatja a metodust; nincs benne cast, es error/warning nelkul lefordul
main() { Set<String> guys = Set.of(...); Set<String> stooges = Set.of(...); Set<String> aflCio = union(guys, stooges); sout(aflCio); //kiiras sorrendje impl fuggo

union() limitje h mindharom set typeja uaz kell legyen. bounded wildcard typeok (item 31) segitsegevel tehetjuk flexebbe

neha olyan objt kell krealnunk ami immut, de szamos kul typera applicable. mivel a genericsek erasureel vannak impl (item 28), ezert egy single objt lehet haszn minden type parametrizationra, de kell irnunk egy static factory metodust ami legyartja az objt minden requested type parametrizationra. ez az un generic singleton factory pattern, amit function objkra haszn (item 42) mint Collections.reverseOrder(), es neha collokra mint Collection.emptySet()

tfh egy identity function dispensert akarunk irni. libben van Function.identity(), tehat nincs szukseg sajatra, de peldanak jo. folosleges lenne minden requestnel uj identity func objt krealni, mivel stateless. ha a Java genericsek reifiedek lennenek, akkor typeonkent kulon identity funcra lenne szukseg, de mivel erasedek, ezert elegendo egy generic singleton
private static UnaryOperator<Object> IDENTITY_FN = (t) -> t;
@SuppressWarnings("unchecked") public static <T> UnaryOperator<T> identityFunction() { return (UnaryOperator<T>) IDENTITY_FN;
a castolas egy unchecked cast warningot okoz, mivel az UnaryOperator<Object> nem UnaryOperator<T> minden T-re. de az identity func specialis: modif nelkul returnoli az argjat, ezert tudjuk h typesafe UnaryFunction<T>-kent haszn, T valuetol fgtl. ezert nyugodtan suppressalhatjuk az unchecked cast warningot

peldaprg amely a generic singletont UnaryOperator<String>-kent es UnaryOperator<Number>-kent haszn. nincs benne cast es error/warning nelkul lefordul
String[] strings = { ... }; UnaryOperator<String> sameString = identityFunction(); for(String s : strings) sout(sameString.apply(s));
Number[] numbers = { ... }; UnaryOperator<Number> sameNumber = identityFunction(); for(Number n : numbers) sout(sameNumber.apply(n));

lehetseges, bar ritka h egy type paramot egy olyan expr boundolja, amelyben benne van maga a type param. ez az un. recursive type bound. gyakori hasznalata a Comparable iface, ami egy type natural orderingjet def (item 14)
public interface Comparable<T> { int compareTo(T o);
a T type param def a typeot, amelyhez a Comparable<T>-t impl type elementjei komparalhatoak. gyak szinte minden type csak a sajat typejanak elementjeihez komparalhato. tehat pl. String impl Comparable<String>, Integer impl Comparable<Integer> stb.

szamos metodusegy olyan collt vesz at amelynek elemei Comparablet impl; azert h sortolja, serachelje, mint/maxot szamoljon stb. ahhoz h ezeket meg tudja tenni, szukseges h a coll minden eleme komparalhato legyen minden masik elemhez, maskent a coll elemei legyenek mutually comparablek
public static <E extends Comparable<E>> E max(Collection<E> c);
az <E extends Comparable<E>> type bound azt jelenti h "any type E that can be compared to itself", ami kb megfelel a mutual comparabilitynek
(pelda metodus ezzel a headerrel, ami a coll maxat returnoli. empty coll eseten IllegalArgumentExceptiont dob aminel jobb lenne ha Optional<E> -t returnol (item 55))

recursive type boundok sokkal komplexebbek is lehetnek, de szerencsere erre ritkan van szukseg. ha megertjuk ezt az idiomot, a wildcard variantjat (item 31) es a simulated self-type idiomot (item 2), azokkal meg lehet oldani a legtobb gyak recursive type boundot

summary: generic metodusok, mikent a generic typeok, safebbek es konnyebben haszn mint az olyan metodusok, amelyek megkivanjak h a clientjeik expl castokat hajtsanak vegre az input paramokon es return valuekon. typeokhoz hasonloan metodusoknal is arra kell torekedni h castok nelkul lehessen oket haszn, ami gyakran azt jelenti h genericke kell tenni oket. es mint a typeoknal, erdemes az olyan existing metodusokat generifyolni, amelyek hasznalata castokat igenyel. ez megkonnyiti a felhasznalast, es nem breakeli az existing clienteket (item 26)