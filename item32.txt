ITEM 32: COMBINE GENERICS AND VARARGS JUDICIOUSLY

vararg metodusokat (item 53) es genericseket egyarant Java 5-ben adtak hozza, ugyhogy azt gondolnank h jol muk egyutt, de nem. varargok celja h valtozo szamu argot tudjunk atadni egy metodusnak, de ez egy leaky abstraction: amikor egy vararg metodust invokolunk, egy array krealodik a vararg paramok tarolasara; es ez az array, ami egy impl detail, visible. emiatt zavaro compiler warningokat kapunk ha a vararg paramoknak generic v parametrized typeja van

item 28-ban irottak szerint non-reifiable type az amelynek runtime reprje kevesebb infot tart mint a compile-time reprja, es h szinte minden generic es parametrized type non-reifiable. ha egy metodus a vararg paramjat non-reifiable typekent dekl, akkor a compiler warningot dob a deklra. ha a metudos olyan vararg parammal van invokolva amelynek az inferred typeja non-reifiable, akkor a compiler warningot dob az invocra is: "warning: [unchecked] Possible heap pollution from parameterized vararg type List<String>"

heap pollution akkor van ha egy parametrized typeu var egy olyan objra refel, amelynek nem az a typeja. ez a compiler autom generated castjainak failjet okozhatja, ezzel violalva a generic type sys altal nyujtott fundamental garanciat
static void dangerous(List<String>... stringLists) { List<Integer> intList = List.of(42); Object[] objects = stringLists; objects[0] = intList; /* heap pollution */ String s = stringLists[0].get(0); /* ClassCastException */
ebben a metodusban nincsen visible castolas de megis ClassCastExceptiont dob ha egy v tobb arggal hivjak meg. az utolso stmtben van egy invisible cast amit a compiler general. ez a cast failel, jelezve h a type safety megserult es h unsafe egy generic varargs array paramban valuet tarolni

ez a pelda felvet egy kerdest: egyaltalan miert legal metodust dekl vararg parammal, ha generic arrayt expl krealni illegal? maskent, az elobbi metodus miert csak warningot dob? a valasz h a metodusok amelyeknek generic v parametrized typeu vararg paramja van, gyak nagyon hasznosak lehetnek, ezert a ugy dontottek h megengedik. Java libekben szamos ilyen metodus van, pl. Arrays.asList(T... a), Collections.addAll(Collection<? super T>, T... elements), EnumSet.of(E first, E... rest). a dangerous() metodussal ellentetben ezek a lib metodusok typesafek

Java 7 elott egy generic vararg paramu metodus szzerzoje semmit nem tudott tenni a warninggal a hivas helyen. emiatt ezeket az APIkat nem volt jo haszn. usereknek egyutt kellett elniuk a warninggal v @SuppressWarnings("unchecked") annoval minden hivasi helyen (item 27). ez faraszto, nehezen olvashato es elhidolhat olyan warningokat emylek tenyleges issuekat jeleznek

Java 7-ben hozzaadtak a SafeVarargs annot, amellyel egy generic vararg paramu metodus szerzoje autom el tudja suppressalni a client warningokat.az anno lenyegeben egy igeret a metodus szerzojetol h typesafe. az igeretert cserebe a compiler nem figyelmezteti a metodus usereit h a hivas unsafe lehet

fontos, h ne annotaljunk meg egy metodust @SafeVarargs-al, csak ha tenylegesen safe. hogyan bizonyoodhatunk meg errol? mint irtuk, a metodus invokolasakor egy generic array krealodik a vararg paramok tarolasara. ha a metodus nem tarol semmit az arrayben (ami overwritolna a paramokat) es nem engedi h az array ref escapelodjon (ami lehetove tenne untrusted kod szamara h accessalja az arrayt) akkor safe. maskent, ha a vararg argot csak arra haszn, h valtozo szamu argot transmittaljunk a hivotol a metodusnak - ami a vararg celja - akkor a metodus safe

erdemes megjegyezni h a type safetyt tudjuk violalni anelkul h barmit tarolnank a vararg param arrayben. tekintsuk a kov generic vararg metodust amely egy arrayt returnol, ami a paramokat tart. elsore ez egy jo util metodusnak tunik
static <T> T[] toArray(T... args) { return args;
a metodus egyszeruen returnoli a vararg param arrayet. ez nem tunik vezselyesnek, pedig az. az array typejat a metodus argjainak compile-time typejai hat meg, es a compilernek lehet h nincs eleg infoja h pontosan meg tudja hat. mivel a metodus a vararg param arrayet returnoli, ezert "can propagate heap pollution up the call stack"

h konkretabba tegyuk, nezzuk a kov generic metodust, amely harom T typeu argot vesz at, es egy olyan arrayt returnol ami ket rnd kival argot tart
static<T> T[] pickTwo(T a, T b, T c) { ...return toArray(a,b)...;
ez a metodus onmagaban nem veszelyes, es nem generalna warningot, de invokolja a toArray() metodust amelynek generic vararg paramja van

a metodus forditasakor a compiler kreal egy vararg param arrayt amelyben ket T instanceot ad at a toArray()-nek. ez a kod egy Object[] typeu arrayt allocol, ami a legspecificebb type ami garantaltan tarolni tudja ezeket az instanceokat, fgtl attol h a pickTwo()-nak milyen typeu objkat adtak at a hivasa helyen. a toArray() egyszeruen ezt az arrayt returnoli a pickTwo()-nak, ami tovabb returnoli a hivojanak, igy tehat a pickTwo() mindig egy Object[] typeu arrayt fog returnolni

tfh a kov metodus hivja pickTwo()-t
main() { String[] attributes = pickTwo("good", "fast", "cheap");
ezzel nincs semmi gond es lefordul warningok nelkul. de runtime ClassCastExceptiont dob, bar nem tart visible castokat. ami nem lathato h a compiler a pickTwo() altal returnolt valuera generalt egy hidden castolast String[]-be, h el lehessen tarolni attributes-ba. es a cast failel mert Object[] nem subtypeja String[]-nek. ez a failure meglehetosen zavaro mert ket szinttel odebb van a toArray() metodustol ami tenylegesen okozta a heap pollutiont, a vararg param array pedig nem lett modifolva azutan h az actual paramok el lettek tarolva benne

ennek a peldanak az a celja h megmutassa h unsafe egy masik metodusnak accesst adni egy generic vararg param arrayhez, ket kivetellel: safe atadni az arrayt egy masik vararg metodusnak amely megfeleloen fel van annotalva @SafeVarargs-al; es safe atadni az arrayt egy non-varargs metodusnak amely csupan vmilyen funct hajt vegre az array contenten

alljon itt a generic vararg param egy tip safe hasznalata. a metodus tetszoleges szamu listet vesz at argkent, es egy listat returnol ami az input listek elemeit tart. mivel @SafeVarargs anno van rajta, ezert nem general warningot sem a dekl sem a hivasok helyen
@SafeVarargs static <T> List<T> flatten(List<? extends T>... lists) { List<T> result = new ArrayList<>(); for(List<? extends T> list : lists) result.addAll(list); return result;

SafeVarargs anno haszn eldontesenek szabalya: haszn minden metoduson amelynek generic v parameterized type varargja van, igy a metodus hasznaloinak nem kell folsleges es confusing compiler warningokkal fogl. ebbol kov h sose irjunk unsafe vararg metodusokat mint a dangeros() v toArray() voltak. ha a compiler lehetseges heap pollutionra figyelmeztet egy metodusunk generic vararg paramja miatt, akkor csekkeljuk h a metodus safe-e. reminder: generic vararg metodus safe ha: 1 nem tarol semmit a vararg param arrayben 2 nem teszi az arrayt (v clonejat) visible untrusted code szamara. ha a ket eloiras bmelyike violalva van akkor fixeljuk

SafeVarargs csak olyan metodusokon legal amelyek nem overridolhatoak, mivel nem lehet garantalni h minden overriding metodus safe lesz. Java 8-ban az anno csak static metodusokon es final instance metodusokon volt legal; Java 9-ben private instance metodusokon is

SafeVarargs egy alternativaja ha az item 28 tanacsa szerint replaceljuk a vararg paramot (ami valojaban array) egy List parammal
static<T> List<T> flatten(List<List<? extends T>> lists) { ...
ez aztan hasznalhato a List.of() static factory metodussal. List.of() dekl is SafeVarargs-al van annotalva
audience = flatten(List.of(friends, romans, countrymen));
ennek az approachnak az elonye h a compiler biz tudja h a metodus typesafe. nem kell SafeVarargs annoval jotallnunk a safetyjeert es nem kell attol tartanunk h hibat kovetunk el annak a megall soran h safe. fo hatrany h a client kod egy kicsivel verbosebb es kicsivel lassabb is lehet

ezt a trukk ot lehet haszn olyankor is amikor nem lehet safe varargs metodust irni, mint pl. a toArray() eseteben. ez tulajdonkeppen uazt nyujtja mint a List.of() metodus, ezert meg sem kell irnunk. a pickTwo() metodus ezek utan igy nez ki
static <T> List<T> pickTwo(T a, T b, T c) { ... return List.of(a,b); ...
a pickTwo() hivasa pedig
main() { List<String> attributes = pickTwo("good", "fast", "cheap");
a vegeredmeny typesafe mert mar csak genericset hasznal, arrayt nem

summary: vararg es generics nem muk jol egyutt mert a vararg egy leaky abstraction az arrayek tetejen, es az arrayeknek a genericsektol eltero type rulejai vannak. bar a generic vararg paramok nem typesafek, de legalok. ha ugy dontunk h olyan metodust irunk amelynek generic (v parametrized) vararg paramjai vannak, akkor eloszor bizt h a metodus typesafe, utana pedig annotaljuk meg @SafeVarargs-al h ne legyen korulmenyes haszn



