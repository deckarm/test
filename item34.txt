ITEM 34: USE ENUMS INSTEAD OF INT CONSTANTS

enumerated type amelynek legal valuei egy fixed set of constants, pl. evszakok, bolygok, kartyak. enum type hozzaadasa elott az enumerated tyeok repr common patternje a named int constantok voltak
public static final int APPLE_FUJI = 0; public static final int APPLE_PIPPIN = 1; ... public static final int ORANGE_NAVEL = 0; public static final int ORANGE_TEMPLE = 1; ...
un. int enum pattern, szamos hatrany. nem bizt type safetyt, es gyenge a kifejezoereje. compiler nem fog jelezni ha applet adunk at egy metodusnak ami oranget varna, ha ==-vel komparalunk applet orangeel, vagy pl. int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN

vegyuk eszre h minden apple constant neve APPLE_ es minden orange constant neve ORANGE_ prefix. ez azert van mert java nem nyujt namespaceket az int enum groupoknak. a prefixek preventaljak a nevutkozeseket ha ket int enum groupban azonos nevu constant van, pl. ELEMENT_MERCURY es PLANET_MERCURY

int enumokat haszn prgk torekenyek. mivel az int enumok constant varok, ezert az int valueaik belefordulnak az oket haszn clientekbe. ha egy int enumhoz kapcs value megvalt, akkor a clientjeit ujra kell ford. ha nem tesszuk akkor a clientek tovabbra is futni fognak, de rossz lesz a behavjuk

int enum constantokat nem egyszeru printable stringekbe alakitani. ha kiprintelunk egy ilyen constantot v debuggerbol iratjuk ki, akkor csak egy szamot latunk, ami nem tul sokatmondo. nincs reliable mod az egy groupba tart int enum constantokon vegigiteralni v akar csak obtainelni egy int enum group sizejat

a pattern egy valtozata ahol int constantok helyett String constantok vannak. ez az un String enum pattern meg rosszabb. bar nyujt printable Stringeket a constantjaihoz, de naiv userek behardcodeolhatjak a string constantokat a client kodba ahelyett h field neveket haszn. ha egy ilyen hardcoded string contstantban typo van akkor az compile timeban nem fog kiderulni, es runtime lesznek bugok. emellett perf-- is lehet mert string komparalast haszn

szerencsere Java nyujt alternativat ami kukusz az int es String patternek hatranyait es egyeb benefiteket nyujt, ez az enum type
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH } public enum Orange { NAVEL, TEMPLE, BLOOD }
ranezesre ez hasonlit a mas nyelvek (C, C++, C#) enum typejahoz, de a Javaban ezek teljeserteku classok, es sokkal tobbet tudnak mint mas nyelvekben, ahol az enumok lenyegeben csak int valuek

Java enum typejai mogotti alapotlet egyszeru: classok amelyek minden enumeration constantra egy instanceot exportalnak egy public static final fielden keresztul. az enum typeok eff finalok, mivel nincs accessible konstruk. mivel a clientek sem nem tudnak instanceot krealni enum typebol, sem extendalni nem tudjak, ezert nem lehetnek mas instanceok csak a dekl enum constantok. maskent, az enum typeok instance-controlledek. a singleton egy altalanositasai (item 3) amelyek lenyegeben single-element enumok

enumok compile-time type safetyt nyujtanak. ha egy paramot Apple typeunak dekl, az garantalja h a paramnak atadott minden non-null obj ref egyike a harom valid Apple valuenak. ha rossz typeu valuet probalunk atadni, az compile-time error, csakugy mint ha egy enum type exprt egy masik enum type varnak probalunk atadni, vagy ha kulonbozo enum typeok valueit az == operrel probaljuk komparalni

kulonbozo enum tyepokban levo azonos nevu constantok bekesen megfernek egymas mellett mivel minden typenak sajat namespace van. egy enum typeon belul a constantok reorderelhetoek a clientek ujraforditasa nelkul mivel a constantokat exportalo fieldek egy szigetelo layert nyujtanak az enum type es a clientjei kozott: constant valuek nincsenek beforditva a clientekbe mint az int enum patternnel. vegul az enumok printable Stringekbe alakithatoak a toString() metodusukkal

int enumok hatranyainak javitasan kivul az enum typeokhoz arbitrary metodusok es fieldek adhatoak, es arbitrary ifaceket tudnak impl. impljak az osszes Object metodust (ch 3), Comparablet (item 14) es Serializablet (ch 12), es a serialized formajuk "is designed to withstand most changes to the enum type"

miert akarunk metodusokat v fieldeket adni egy enum typehoz? pl. mert datat akarunk kapcsolni a constantjaihoz. az Apple es Orange typeokban pl. lehet egy metodus ami a gyumolcs szinet returnoli. egy enum type kezdheti az eletet enum constantok egyszeru colljakent, es idovel evolvalodhat egy full-featured abstractionbe

rich enum type lehet pl. a naprendszer bolygoi. minden bolygonak van tomege es radiusa, amelyekbol kiszamolhato a felszini gravitacioja, amibol kiszamolhato egy targy tomege a felszinen
public enum Planet {
  MERCURY(3.302e+23, 2.439e6),... //zarojelben a paramok amiket a konstr atvesz
  private final double mass; private final double radius; private final double surfaceGravity; //+getterek mass(), radius(), surfaceGravity() neven
  Planet(double mass, double radius) { this.mass = mass; this.radius = radius; surfaceGravity = ... }
  public double surfaceWeight(double mass) { ...
  
ilyen rich enum typeokat egyszeru irni. ahhol h datat kapcs az enum constantokhoz, dekl instance fieldeket es irjunk egy konstrt ami atveszi a datat es eltarolja a fieldekbe. enumok immutok ezert minden fieldjuk legyen final (item 17). fieldek lehetnek publicok is, de jobb ha privateok es vannak public accesoraik (item 16). a Planet eseteben a konstr szamolja ki a surfaceGravityt de ez csak optimalizacio. a gravity kiszamolhato lenne minden alkalommal is amikor a surfaceWeight() metodust hivjuk

Planet egyszeru de powerful. pl. prg amely atveszi egy targy foldi sulyat es kiszamolja a sulyt minden bolygon
main() { double earthWeight = Double.parseDouble(args[0]); double mass = earthWeight / Planet.EARTH.surfaceGravity(); for(Planet p:Planet.values()) sout(p.surfaceWeight());

enumoknak van egy static values() metodusa ami a valuek arrayet returnoli a dekl sorrendjeben. vegyuk eszre h a toString() metodus returnoli minden enum value dekl nevet, ennek segitsegevel println()/printf() konnyen tudja printelni. ha ez a string repr nem megfelelo, akkor overridolhatjuk a toString() metodust

mi tortenik ha removolunk egy element egy enum typebol (pl. Pluto mar nem bolygo)? bmely client amely nem refel a removolt elemre, tovabbra is jol muk. pl. a fenti main() eggyel kevesebb sort fog kiirni. ha egy client refel a removolt elemre (Planet.PLUTO), akkor ha ujraforditjuk a clientet akkor forditasi hibaval jelzi h gond van; ha nem forditjuk ujra akkor runtime exc lesz. ez a leheto legjobb viselkedes amit elvarhatunk, sokkal jobb mint amit az int enum pattern nyujt

az enum constantokhoz kapcs egyes behavokat csak a classbol v packagebol akarhatjuk haszn ahol az enum def van. az ilyeneket legjobb private v package-private metoduskent impl. ezeket minden constant egy hidden behav collban viszi magaval, ami lehetove teszi h az enumot tart class v package megfeleloen reagaljon az adott constantra. mint a normal classoknal, hacsak nincs jo okunk h egy enum metodust a clientjeinek exposoljunk, akkor dekl privatekent v szukseg eseten package-privatekent

ha egy enum alt ertelemben hasznos, akkor legyen top-level class; ha a hasznalata egy adott top-level classhoz kapcs, akkor legyen annak a top-level classnak a membere (item 24). pl. a java.lang.RoundingMode enum rounding modeot repr decimal fractionokhoz. ezeket a BigDecimal class haszn, de egy hasznos abstractiont nyujtanak amely nem csak a BigDecimalhoz kapcs. ezert a RoundingMode egy top-level enum, ezzel lehetove teszik prgozok szamara h reusoljak, ezaltal APIkon ativelo consistency++ 

a Planet peldaban bemutatott technikak a legtobb enum typehoz elegek, de neha ennel tobb kell. minden Planet constanthoz kul data kapcs, de neha minden constanthoz kulon behav kell kapcs. pl. enum type ami egy alap calculator operjeit repr, es nyujtani akarunk egy metodust amely a constantok altal repr aritmetikai opereket hajtjak vegre
public enum Operation {
  PLUS, MINUS, TIMES, DIVIDE;
  public double apply(double x, double y) { switch(this) { case PLUS: return x + y; ... } throw new AssertionError("unknown oper");
muk de nem tul szep. throw nelkul nem fordul le mert "because the end of the method is technically reachable, even though it will never be reached". ezenkivul fragile; ha uj enum constantot adunk hozza, de elfelejtjuk a megfelelo caset hozzaadni a switchez akkor ugyan le fog ford de runtime fail lesz ha az uj opert probaljuk haszn

ennel van jobb mod kul behavot adni az egyes enum constantokhoz: abstract apply() metodust dekl az enum typeban es overridoljuk minden constantra egy concrete metodussal egy un constant-specific class bodyban. ezek a metodusok az un constant-specific metodus implk
public enum Operation {
  PLUS { public double apply(double x, double y) { return x + y; } }, ...
  public abstract double apply(double x, double y);
ha ehhez a verziohoz adunk egy uj constantot, akkor nem valoszinu h elfelejtunk apply() metodust is hozzaadni mivel kzvtl a constant dekl utan van. ha megis elfelejtenenk, a compiler figyelmeztet mert az enum typeban levo abstract metodusokat minden constantra overridolni kell concrete metodussal

a constant-specific metodus implk kombinalhatoak constant-specific dataval. pl. a kov verzio overridolja a toString()-et h returnolje az operhez kapcs szimbolumot
public enum Operation {
  PLUS("+") { public double apply(double x, double y) { return x + y; } }, ...
  private final String symbol;
  Operation(String symbol) { this.symbol = symbol;
  public String toString() { return symbol; 
  public abstract double apply(double x, double y);
  
ennek segitsegevel egyszeruen lehet aritmetikai exprk eredmenyeit kiprintelni
main() { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); for(Operation op: Operation.values()) sout(op.apply(x,y));

enum typeoknak van egy autom generated valueOf(String) metodusuk, amely a constant nevet magaba a constantba alakitja. ha overridoljuk egy enum typeban a toString() metodust, akkor erdemes lehet irni egy fromString() metodust ami a custom string reprt visszaforditja a megfelelo enumba. az alabbi kod bmely enumra jo, ahol minden constant string repr unique
private static final Map<String, Operation> stringToEnum = Stream.of(values()).collect(toMap(Object::toString, e -> e));
public static Optional<Operation> fromString(String symbol) { return Optional.ofNullable(stringToEnum.get(symbol));

vegyuk eszre h az Operation constantok egy static field initializationbol kerulnek be a stringToEnum mapbe, ami azutan fut le h az enum constantok megkrealodtak. a values() altal returnolt arrayen kreal egy streamet (ch 7); Java 8 elott egy ures hashmapet kellett volna krealni, es vegigiteralni a values() arrayen, beinsertelve a string-to-enum mappingeket a mapbe, ez termeszetesen most is muk. de nem lehet azt csinalni h az egyes constantok sajat magukat rakjak bele a mapbe a konstrjukbol. ez compile error, ami jo, mert ha legal lenne akkor runtime NPE lenne. enum konstrk nem accessalhatjak az enum static fieldjeit, a constant varok kivetelevel. ez azert kell, mivel a static fieldek meg nincsenek initelve amikor az enum konstrk lefutnak. a restriction egy spec esete h az enum constantok nem accesselhetik egymast a konstrokbol

vegyuk eszre h fromString() egy Optional<String>-et returnol. ez teszi lehetove h a metodus jelezze ha a kapott string nem valid opert repr, es forcolja h a client kezelje ezt a lehetoseget (item 55)

constant-specific metodus implk hatranya h nehezebben lehet kodot sharelni enum constantok kozott. pl. enum ami a het napjait repr. ebben van egy metodus ami kiszam egy munkas napi beret a base salary es a ledolgozott ido alapjan. normal weekdayeken bmennyi tulmunka overtime fizetest jelent; hetvegen pedig minden munka. switch segitsegevel konnyu megcsinalni
enum PayrollDay {
  MONDAY, TUESDAY...;
  int pay(int minsWorked, int payRate) { 
    switch(this) { 
	  case SATURDAY: case SUNDAY: ... break; 
	  default: ... //weekdays
ez a kod tomor, de maint szempontbol veszelyes. tfh elemet adunk az enumhoz, pl spec value ami vacation dayt repr, de elfelejtjuk a switchez hozzaadni a megfelelo caset. a prg tovabbra is le fog fordulni, de a pay() metodus uazt az osszeget fogja fizetni egy vacation dayre mint egy normal weekdayre

ahhoz h safely hajtsuk vegre a pay calcot constant-specific metodus implkkal, le kell duplikalnunk az overtime szamitast minden constantra v kimozgatni a szamitast ket helper metodusba, az egyik a weekdayekre a masik a hetvegekre; es minden constantra invokolni a ket helper metodust kozul a megfelelot. mindket lehetoseg boilerplate++, olvashatosag--, error risk++

(itt van egy bekezdes amiben az abstract overtimePay() metodus replaceleserol ir, de ezt meg be sem vezettuk??)

az lenne a jo ha minden alkalommal forcolva lennenk ra h bevezessunk egy uj overtime pay strategyt amikor hozzaadunk egy uj enum constantot. szerencsere van ra mod. az otlet h mozgassuk az overtime pay szamitast egy private nested enumba, es adjuk at ennek az un. strategy enumnak egy instanceat a PayrollDay enum konstranak. a PayrollDay enum ezutan delegalja az overtime pay szamitast a strategy enumnak, igy nincs szukseg switchre v constant-specific metodus implkra a PayrollDayben. ez kevesbe tomor mint a switches mo de safer es flex++
enum PayrollDay {
  MONDAY,...,SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND);
  private final PayType payType;
  PayrollDay(PayType payType) { this.payType = payType;
  PayrolDay() { this(PayType.WEEKDAY); //default konstr
  int pay(int minsWorked, int payRate) { return payType.pay(minsWorked, payRate);
  private enum payType { //strategy enum type
    WEEKDAY { int overtimePay(int minsWorked, int payRate) { ...
	WEEKEND { int overtimePay(int minsWorked, int payRate) { ... };
    abstract int overtimePay(int minsWorked, int payRate);
	int pay(int minsWorked, int payRate) { ... }
	
"If switch statements on enums are not a good choice for implementing constant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting enum types with constant-specific behavior." (???) pl. tfh Operation enum nem a mi controlunk alatt van, es szeretnenk ha lenne benne egy instance metodus ami minden oper inverzet adja vissza. ez szimulalhato az alabbi static metodussal
public static Operation inverse(Operation op) { switch(op) { case PLUS: return Operation.MINUS; ... default: throw new AssertionError("unknown oper");

ez uigy hasznalhato olyan enum typeokon is amelyek a mi controlunk alatt vannak, ha egy metodus egyszeruen nem tart az enum typeba. egyebkent hasznalhato metodus, csak nem resze az enumnak

enumok alt has perf mint int constantok. kis perf hatrany h az enum typeok loadjanak es initjenek van space es time ktge, de gyak nem eszlelheto

haszn enumokat ha constantok egy olyan setjere van szukseg amelynek tagjai compile timeban ismertek. ebbe beletart "natural enumerated typeok", pl. bolygok, het napjai, sakkfigurak stb. de idetartoznak olyan setek is mint pl. menupontok, oper kodok v command line flagek. nem szukseges h egy enum type constant setje orokre fixed maradjon. az enum featuret azert designoltak h az enum typeok binary compat evolutionjat tam

summary: enum typeok elonyei int constantokkal szemben jelentosek. more readable, safer, more powerful. egyes enumoknak nincs szukseges expl konstrkra v memberekre, masok viszont benefitelnek abbol h datat kapcs minden constanthoz es metodusokat nyujtanak amelyek behavjat ez a data bef. keves enum benefitel abbol ha tobbfele behavot kapcsol egy single metodushoz. ebben az esetben inkabb haszn constant-specific metodusokat mintsem h az enum a valuein switcheljen. ha nehany, de nem az osszes enum constant common behavet sharel, akkor fontoljuk meg a strategy enum patternt
