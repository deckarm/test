ITEM 35: USE INSTANCE FIELDS INSTEAD OF ORDINALS

szamos enum single int valuekhoz kapcs. minden enumban van egy ordinal() metodus, ami az enum constantok poziciojat adja vissza a typeon belul. csabitonak tunhet h a kapcs int valuet az ordinalbol probaljuk kinyerni
public enum Ensemble {
  SOLO, DUET, TRIO...,DECTET;
  public int numberOfMusicians() { return ordinal() + 1;
ez muk, de maint nightmare. ha a constantokat atrendezik, a numberOfMusicians() metodus breakelni fog. amennyiben egy uj enum constantot akarunk hozzaadni amely egy olyan inthez kapcs amelyet mar haszn, akkor is problema van; pl. ha double quartetet akarunk hozzaadni amihez uugy a 8 tart mint az octethez

ezenkivul nem adhatunk hozza uj constantot anelkul h a kozbeeso int valuekhoz is ne vegyunk fel constantokat. pl. hozza akarnank adni egy constantot ami triple quartetet repr (12), de az enumban csak dectetig (10) vannak constantok, ezert fel kell vennunk egy dummy constantot az unused 11-re is. ez csunya, impractical

szerencsere van egyszeru mo. kapcs erteket sose az ordinalbol szamoljuk, hanem taroljuk egy instance fieldben
public enum Ensemble { 
  SOLO(1), DUET(2)..., DECTET(10),TRIPLE_QUARTET(12);
  private final int numberOfMusicians;
  Ensemble(int size) { this.numberOfMusicians = size;
  public int numberOfMusicians() { return numberOfMusicians;

Enum spec az ordinal()-rol: legtobb prgozo nem fogja haszn. general-purpose enum-based data structokhoz lett designolva, mint EnumSet es EnumMap. hacsak nem ilyen jellegu kodot irunk, legjobb ha nem haszn az ordinal() metodust
  