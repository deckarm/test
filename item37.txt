ITEM 37: USE ENUMMAP INSTEAD OF ORDINAL INDEXING

neha latunk olyan kodot ami arra haszn az ordinal() metodust (item 35) h beindexeljen egy arraybe v listbe
class Plant {
  enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL}
  final String name;
  final lifeCycle lifeCycle;
  Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle;
  public String toString() { return name;
  
tfh van egy garden, ami array of plants, es ki akarjuk listazni a planteket lifecycle szerint rendezve. ehhez krealunk harom setet, minden lifecyclehoz egyet, vegigiteralunk a gardenen, es berakjuk a planteket a megfelelo setbe. egyes prgozok a seteket egy arraybe tennek amit a lifecycleok ordinaljaival indexelnek
Set<Plant>[] plantsByLifeCycle = (Set<Plant>) new Set[Plant.LifeCycle.values().length]; 
for(int i = 0; i < plantsByLifeCycle.length; i++) plantsByLifeCycle[i] = new HashSet<>(); 
for(Plant p : garden) plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);
for(int i = 0; i < plantsByLifeCycle.length; i++) sout(Plant.LifeCcyle.values()[i], plantsByLifeCycle[i]);

ez muk, de tele van problemakkal. mivel az arrayek nem kompat genericsel (izem 28), a prg unchecked castot igenyel, es nem fordul le tisztan. mivel az array nem tudja h az indexe mit repr, outputot kezzel kell labelezni. de a legnagyobb problema h amikor egy olyan arrayt accessalunk amely az enum ordinaljaval van indexelve, akkor a mi respunk h a megfelelo int valuet haszn; intek nem nyujtjak az enumok type sagetyjet. ha rossz valuet haszn, akkor a prg a hatterben vmi mast fog csinalni mint amit varnank, v ha szerencsenk van akkor ArrayIndexOutOfBoundsExceptiont dob

uezt elerhetjuk egy sokkal jobb modon. az array eff egy mapkent szolgal az enum es egy value kozt tehat akar hasznalhatunk egy Mapet is. van egy gyors Map impl amit az enum keyekkel valo hasznra designoltak, java.util.EnumMap
Map<Plant.LifeCycle, Set<Plant>> plantsByLifeCycle = new EnumMap<>(Plant.LifeCycle.class);
for(Plant.LifeCycle lc : Plant.Lifecycle.values()) plantsByLifeCcyle.put(lc, new HashSet<>());
for(Plant p : garden) plantsByLifeCycle.get(p.lifeCycle).add(p);
sout(plantsByLifeCycle);

ez rovidebb, tisztabb, safer, es sebessegben is hasonlo mint az eredeti. nincs unsafe cast; nem kell az outputot kezzel meglabelezni, mert a map keyek enumok amelyek tudjak h kell magukat printable stringekke atforditani; es nincs hibazasi lehetoseg az array indexek kiszam soran. az ok amiert az EnumMap hasonlo sebessegu egy ordinal-indexed arrayhez az h az EnumMap internally egy ilyen arrayt haszn, de elhidolja ezt az impl detailt a prgozo elol, igy kombinalja a Map richnesset es type safetyjet az array sebessegevel. vegyuk eszre h az EnumMap konstr a key type Class objt veszi at: ez egy bounded type token, ami runtime generic type infot nyujt (item 33)

tovabb roviditheto ha streammel (item 45) manageljuk a mapet: sout(Arrays.stream(garden).collect(groupingBy(p->p.lifeCycle)));
ezzel az a gond h a sajat map impljat valasztja, es gyak ez nem EnumMap lesz ezert nem lesz olyan jo a space es time perfja mint ahol expl EnumMapot haszn. ezt ki lehet kusz, ha a Collectors.groupingBy()-nak azt a verziojat haszn, amely lehetove teszi h a hivo spec a map implt a mapFactory parammal: sout(Arrays.stream(garden).collect(groupingBy(p->p.lifeCycle, ()->new EnumMap<>(LifeCycle.class), toSet())));
ez az optim egy ilyen peldanal nem biztos h megeri, de krit lehet egy olyan prgnal ami surun haszn a mapet

a stream-based verzio behavja kicsit kul az EnumMap verziotol. az EnumMap verzio mindig egy nested mapet kreal minden plant lifecyclehoz, mig a stream-based verzio csakkor kreal nested mapet ha a garden min egy plantet tart azzal a lifecycle-al. tehat ha pl. a garden csak annualokat es perennialokat tart, de biennialokat nem, akkor a plantsByLifeCycle size 3 lesz az EnumMap verzioban es 2 a stream-based verziokban

elofordul h array of arrayeket indexelnek ketszeresen ordinalokkal, ket enum valuebol torteno mapping repr celjabol. pl. transition ket fazisa (liquid to solid: freezing, liquid to gas: boling stb.)
public enum Phase {
  SOLID, LIQUID, GAS;
  public enum Transition {
    MELT, FREEZE, ...;
	private static final Transition[][] TRANSITIONS = { { null, MELT, SUBLIME }, { FREEZE, null, BOIL }, { DEPOSIT, CONDENSE, null } }; //sorok from-ordinal, oszlopok to-ordinal szerint indexelve
	public static Transition from(Phase from, Phase to) { return TRANSITION[from.ordinal()][to.ordinal()];

muk, es meg elegansnak is tunhet, de ez felrevezeto. mint a garden peldanal, a compiler itt sem tudja a kapcst az ordinalok es az array indexek kozt. ha elrontjuk a transition tablat v elfelejtjuk updatelni amikor a Phase v Phase.Transition enum typeokat modifoljuk, akkor runtime failure lesz. ez lehet ArrayIndexOutOfBoundsException, NPE v (legrosszabb) hibas viselkedes a hatterben. a tabla merete quadratic a phasek szamaban, meg akkor is ha a non-null elemek szama kisebb

itt is jobban jarunk EnumMappel. mivel minden phase transitiont a phase enumok egy parja indexel, a legjobb ha a kapcst ugy repr h "map from one enum (the “from” phase) to a map from the second enum (the “to” phase) to the result (the phase transition)". a phase transitionhoz tart ket phaset akkor repr legjobban, ha osszekapcs oket a phase transition enummal, amit aztan fel lehet haszn a nested EnumMap initjehez
public enum Phase {
  SOLID, LIQUID, GAS;
  public enum Transition { 
    MELT(SOLID,LIQUID), FREEZE(LIQUID,SOLID),...;
	private final Phase from; private final Phase to;
	Transition(Phase from, Phase to) { this.from = from; this.to = to;
	private static final Map<Phase Map<Phase,Transition>> m = Stream.of(values()).collect(groupingBy(t->t.from,()->new EnumMap<>(Phase.class),toMap(t->t.to, t->t, (x,y)->y, ()->new EnumMap<>(Phase.class))));
	public static Transition from(Phase from, Phase to) { return m.get(from).get(to);

a phase transition map initelo kod kicsit komplex. a map typeja Map<Phase,Map<Phase,Transition>> ami azt jelenti h "map from (src) phase to map from (dest)	phase to transition)". ezt a map-of-mapst ket collector cascaded seqjevel initeljuk. az elso collector src phase szerint groupolja a transitionokat, a masodik pedig egy EnumMap-ot kreal dest phase-to-transition mappingekel. a masodik collectorban levo (x,y)->y merge function unused; azert kell mert meg kell adnunk map factoryt  h EnumMapot kapjunk, es a Collectorsban telescoping konstrk vannak. a konyv elozo verziojaban expl iterationnal volt initelve a phase transition map; ami verbosebb kod de valszeg jobban ertheto

tfh uj phaset akarunk hozzaadni: plasma. ehhez ket transition kapcs, ionization (gas to plasma) es deionization. array-based prg updatelesehez egy uj constantot kellett volna adni a Phasehoz, kettot a Phase.Transitionhoz, az eredeti 9-elemu array of arrayst pedig lecserelni egy 16-elemure. ha tul sok v tul keves elemet adunk az arrayhez v egy elemet rossz helyre rakunk az gond: prg lefordul de runtime fail. az EnumMap-based verzional fel kell vennunk PLASMA a phasek koze, es IONIZE(GAS,PLASMA) es DEIONIZE(PLASMA,GAS) a phase transitionok koze, a tobbi nem valt. a prg minden mast kezel es lenyegeben nem hagy lehetoseget nekunk a hibara. internally a map-of-maps egy array of arrayssal van impl, tehat egy kis space v time ktgel fizetunk a plusz clarity/safety/maint-ert

a rovidseg kedveert a peldakban null jelolte ha nem volt state change (to es from azonos). ez nem jo practice es NPE lehet belole runtime. egy tiszta es elegans mo erre a problemara meglepoen trukkos es hosszu ami elvonna az item fo mondanivalojatol a figyelmet

summary: csak ritkan jo ha ordinalokkal indexelunk arrayekbe: haszn inkabb EnumMapet. ha a repr kivant kapcs tobbdim, haszn EnumMap<...<EnumMap<...>>. ez egy spec esete annak az alt principlenek h app prgozoknak ritkan v sosem ajanlott Enum.ordinalt haszn (item 35)
