ITEM 41: USE MARKER INTERFACES TO DEFINE TYPES

marker iface olyan iface amelyben nincs metodus dekl, csak "megmarkol" vmilyen propertyvel egy classt ami implja az ifacet. pl. Serializable (ch 12); ha egy class impl ezt az ifacet, azzal azt jelzi h az instanceai kiirhatoak egy ObjectOutputStreamre (azaz serializalhatoak)

marker annok (item 39) nem teszik a marker ifaceket obsolette. marker ifaceknek ket elonyuk van a marker annokkal szemben. eloszor, marker iface def egy typeot amelyet a marked class instancei implnak; a marker annok nem tesznek ilyet. a marker ifacek lehetove teszik h compile timeban vegyunk eszre olyan errorokat amelyek egyebkent csak runtime derulnenek ki ha marker annokat haszn

a Java serialization (ch 12) a Serializable marker ifacet haszn annak jelzesere h egy type serializable. az ObejctOutputStream.writeObject() metodus, amely serializalja a neki atadott objt, azt varja h az argja serializalhato legyen. amennyiben ennek a metodusnak az arg typeja Serializable lenne akkor egy nem megfelelo obj serializalasara von kiserlet compile time kiderulne. a marker ifacek celja a compile-time error detektalas, de sajnos az ObjectOutputStream.write API nem hasznalja ki a Serializable ifacet: az arg typeja Object, igy egy nem serializalhato obj serializalasi kiserlete csak runtime fog elfailelni

a marker ifacek masik elonye a marker annokkal szemben h pontosabban targetalhatoak. ha egy anno type ElementType.TYPE-al van dekl akkor _bmely_ classra v ifacere applyolhato. tfh egy olyan markert akarunk amely csak egy bizonyos iface impljaira applicable. ha marker ifacekent def, akkor ezt az egy ifacet extendalva garantalhatjuk h minden marked type subtypeja lesz az egyetlen ifacenek amelyre applicable

a Set iface elvileg egy ilyen restricted marker iface. csak Collection subtypeokra applicable, de nem ad hozza uj metodusokat a Collection altal def metodusokhoz kepest. alt nem tekintik marker ifacenek, mert szamos Collection metodus contractjat finomitja, pl. add(), equals(), hashCode(). de konnyu elkepzelni olyan marker ifacet amely csak egy bizonyos iface subtypejaira applicable, es nem finomitja az iface metodusainak contractjat. egy ilyen marker iface leirhatja az obj vmely invariantjat v jelezheti h az instanceok processalhatoak vmely masik class egy metodusa altal (oly modon ahogy a Serializable iface jelzi h az instanceok processalhatoak ObjectOutputStream altal)

marker annok fo elonye marker ifacekkel szemben h reszei az anno facilitynek; ezert a marker annok "allow for consistency in annotation-based frameworks"

tehat mikor kell marker annot es mikor marker ifacet haszn? annot kell haszn ha a marker bmilyen mas elemre von mint class v iface, mert ifacet csak classok v ifacek implhatnak ill extendalhatnak. ha a marker csak classokra v ifacekre von, akkor tegyuk fel a kerdest: "akarok olyan metodus(oka)t irni amelyek csak olyan objkat vesznek at amelyek meg vannak markolva?". ha igen akkor haszn marker ifacet es nem annot. igy az ifacet tudjuk haszn param typekent ezekhez a metodusokhoz, es igy compile-time csekkeles lesz. ha nem akarunk olyan metodus(oka)t irni amelyek csak markolt objkat vesznek at, akkor valszeg jobban jarunk marker annoval. amennyiben a marking egy olyan fw resze amely annokat hasznal, akkor egyertelmu valasztas a marker anno

summary: marker ifaceknek es marker annoknak is megvan a haszna. ha olyan typeot akarunk def, amely "does not have any new methods associated with it" akkor marker iface a jo mo. ha olyan prg elemeket akarunk megmarkolni amelyek nem classok es nem ifacek, v egy olyan fwbe akarjuk fittelni a markert ami anno typeokat haszn akkor marker anno a jo mo. ha azt vesszuk eszre h olyan marker annot irunk amelynek targetje ElementType.TYPE akkor gondoljuk vegig h tenyleg anno typenak kellene lennie v marker iface jobb valasztas lenne

bizonyos ertelemben ez az item 22 inverze, amely azt mondja: "ha nem akarsz typeot def, akkor ne haszn ifacet". ez az item vmi olyasmit mond h "ha typeot akarsz def, akkor haszn ifacet"