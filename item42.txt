ITEM 42: PREFER LAMBDAS TO ANONYMOUS CLASSES

tortenelmileg az egy abstract metodust tart ifacek (v ritkabban abstract classok) szolgaltak function typekent. az instanceaik, az un function objk, repr a functionokat v actionokat. JDK 1.1 ota a function obj krealasanak fo modja az anon class volt (item 24). az alabbi kodreszletben egy anon class instancet haszn a sort comparison functionjanak megkrealasara (ami meghat a sort ordert)
Collections.sort(words, new Comparator<String>() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length()); } } );

az anon classok megfeleloek voltak a function objkat igenyelo klasszikus OO patternekhez, pl. Strategy. a Comparator iface egy abstract strategyt repr a sortinghoz; a fenti anon class pedig egy concrete strategy, stringek sortolasahoz. az anon classok verbosityje miatt viszont erdemes volt bevezetni a functional prgingot a nyelvbe

Java 8-ban formalizaltak, h az egyetlen abstract metodust tart ifacek specek es spec kezelest igenyelnek. ezeket az ifaceket functional ifacenek hivjak, az instanceaikat pedig lambda exprek (roviden: lambdak) segitsegevel lehet krealni. lambdak szerepuket tekintve hasonloak anon classokhoz, de tomorebbek. a fenti kod anon class helyett lambdaval
Collections.sort(words, (s1,s2) -> Integer.compare(s1.length(), s2.length()));

vegyuk eszre h a lambda typeja (Comparator<String>), a paramok typejai (s1 es s2, mindketto String) es a return valueja typeja (int) hianyoznak. a compiler a ctxbol kikovetkezteti ezeket a typeokat az un type inference reven. biz esetekben a compiler nem kepes ezt megtenni, es ezert meg kell adnunk oket. a type inference szabalyai igen komplexek, keves prgozo erti oket reszleteiben. foszabalykent ne irjuk ki lambda paramok typejait, hacsak a jelenletuk nem javitja a prg olvashatosagat. ha a compiler errort dob, miszerint nem tudja inferelni egy lambda paramn typejat, akkor irjuk ki. neha szukseges h castoljuk a lamba expr return valuejat, de ez ritka

egy figyelmeztetes a type inference kapcsan. item 26 szerint ne hasznaljunk raw typeokat, item 29 szerint reszesitsuk elonyben a generic typeokat, item 30 szerint reszesitsuk elonyben a generikus metodusokat. ez a tanacs duplan fontos ha lambdakat haszn, mert a compiler a legtobb type infot, ami lehetove teszi a type inferencet, a genericsbol nyeri ki. ha mi nem adjuk meg ezt az infot, akkor a compiler nem fog tudni type inferencet csinalni, nekunk pedig manualisan kell megadnunk a typeokat a lambdainkban, ami verbosity++. a fenti kod pl. nem fog lefordulni ha a words var typeja raw List es nem parametrized List<String>

a peldaban levo comparator meg tomorebb is lehet, ha lambda helyett comparator construction metodust haszn (item 14, item 43)
Collections.sort(words, comparingInt(String::length));
sot meg ennel is rovidebb lehet ha a Java 8-ban a List ifacehez adott sort() metodust haszn
words.sort(comparingInt(String::length));

a lambdak hozzaadasa a nyelvhez praktikussa teszi h function objkat haszn ott ahol ennek korabban nem volt ertelme. pl. item 34 Operation enum type. mivel minden enum constant apply() metodusa mas behavot jelntett, ezert constant specific class bodykat hasznaltunk, es minden constantra overridoltuk az apply() metodust
item 34 szerint az enum instance fieldek preferaltak a constant specific class bodykkal szemben. lambdakkal konnyu constant-spec behavot impl ugy h instance fieldeket haszn. minden enum constant konstranak adjunk at egy lambdat ami impl az o behavjat. a konstr eltarolja a lambdat egy instance fieldben, es az apply() metodus fwdolja az invocationt a lambdanak. igy a kod egyszerubb es tisztabb mint az ott latott verzio
public enum Operation {
  PLUS("+", (x,y) -> x + y), ...
  private final String symbol; private final DoubleBinaryOperator op;
  Operation(String symbol, DoubleBinaryOperator op) { this.symbol = symbol; this.op = op;
  public double apply(double x, double x) { return op.applyAsDouble(x,y);
  public String toString() { return symbol;
DoubleBinaryOperator ifacet haszn azokhoz a lambdakhoz, amelyek az enum constantok behavjat repr. ez egyike a java.util.functionban levo szamos predef functional ifacenek (item 44). egy olyan funct repr, amely ket double argot vesz at es egy double resultot returnol

a lambda-alapu Operation enum alapjan azt gondolhatnank h a constant-specific metodus bodyknak mar nincs letjogosultsaga, de ez nem igy van. a metodusoktol es classoktol elteroen a lamdaknak nincs neve es docja: ha egy szamitas nem self-explanatory v tobb mint nehany sor hosszu akkor ne tegyuk lambdaba. lambdaba egy sor az idealis, harom sor az ertelmes max. ha ezt tullepjuk az nem tesz jot a prg olvashatosaganak. ha egy lambda hosszu v nehezen olvashato akkor probaljuk meg egyszerusiteni v refaktoraljuk a prgt h eliminaljuk. emellett az enum konstrnak atadott argok static ctxben evalualodnak. ezert az enum konstrban levo lambdak nem tudjak az enum instance memberjeit accessalni. tovabbra is erdemes constant specific class bodykat haszn ha egy enumban olyan constant specific behav van ami nehezen ertheto, nem implhato nehany sorban v instance fieldekhez/metodusokhoz igenyel accesst

szinten gondolhatjuk h anon classok a lambdak bejovetelevel obsolette valtak. ez mar kozelebb jar az igazsaghoz de van par dolog amit anon classokkal meg tudunk csinalni, lambdakkal viszont nem. lambdak func ifacekre vannak limitalva. ha abstract class egy instanceat akarjuk krealni azt anon classal meg tudjuk tenni, de lamdbaval nem. anon classokat hasznalhatunk olyan ifacek instanceainak krealasahoz amelyekben tobb abstract metodus van. vegul egy lambda nem obtainelhet refet sajat magara. lambdaban a this az enclosing instancera von; anon classban a this az anon class instancera von. ha accessalnunk kell a function objt a bodyjabol akkor anon classt kell haszn

lambdak hasonlitanak anon classokhoz abban h nem lehet oket megbizhatoan serializalni/deserializalni "across implementations". ezert ne nagyon serializaljunk lambdat (v anon class instanceot). haolyan function objnk van amelyet serializableve akarunk tenni, mint pl. Comparator, akkor haszn egy private static nested class instanceot (item 24)

summary: Java 8-tol a lambdak a legjobb mo a kismeretu function objk reprjara. ne haszn anon classokat function objkhoz, hacsak nem olyan typeok instanceait kell krealnunk amelyek nem functional ifacek. lambdak olyan egyszeruve teszik a kismeretu function objk reprjat h megnyitja az utat korabban nem haszn functional prg technk szamara is