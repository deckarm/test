ITEM 45: USE STREAMS JUDICIOUSLY

streams APIt Java 8-ban adtak hozza h a bulk operek vegrehajtasat egyszerusitsek, seq v parallel. az API ket key abstractionje: stream, ami data elementek finite v infinite seqjet repr, es data pipeline, ami egy multistage computationt repr ezeken az elementeken. stream elementjei barhonnan johetnek. gyakori sourceok a collok, arrayek, fileok, regexp pattern matcherek, pseudo rnd nr generatorok es mas streamek. a streamben levo data elementek lehetnek obj refek v primitiv valuek. harom primitiv type van tam: int, long es double

stream pipeline alkotoreszeu: source stream, 0 v tobb intermediate oper, 1 terminal oper. minden intermediate oper vmilyen modon transformalja a streamet, pl. minden elementet atmappel az element vmilyen functionjara, v kifilterezi azokat az elementeket amelyek nem telj vmilyen conditiont. intermediate operek egy streamet egy masikba transformalnak, amelynek az element typeja lehet uaz v mas mint az input streame. a terminal oper vmi final szamitast vegez az utolso intermediate oper result streamjen, pl. eltarolja az elementjeit egy collba, returnol egy elementet, v kiirja az osszes elementet

stream pipelineok evaluationja lazy: eval nem kezdodik el amig a terminal oper nincs invokolva, es nem lesznek kiszamitva azok a data elementek amelyek nem szuksegesek a terminal oper kiszamitasahoz. ez a lazy eval lehetove teszi h infinite streameken is lehessen dolgozni. terminal oper nelkul a stream pipeline silent no-op, ezert ne feledkezzunk meg rola

streams API fluent: a pipelinet alkoto callok egyetlen expressionba chainelhetoek. tenylegesen tobb pipeline is chainelheto egyetlen expressionba

defaultbol a stream pipelinek seq futnak. ahhoz h egy pipeline parallel fusson, csupan meg kell hivni a parallel() metodust a pipeline bmelyik streamjen, de ez ritkan celszeru (item 48)

streams API kelloen flex ahhoz h gyak bmely szamitas elvegezheto streamekkel, de ez nem jelenti azt h mindig azt is kell haszn. ha jol haszn, akkor a streamek rovidebb es tisztabb prgkat eredmenyezhetnek; ha nem, akkor viszont nehezen olvashato/mainainelheto prgkat. nincsenek kobe vesett szabalyok h mikor kell streameket haszn, inkabb heuristicsek

pl. prg amely dict filebol olvassa ki a wordoket es kiirja az osszes, egy adott sizenal hosszabb anagram groupot (ket word anagram ha uazokat a betuket tart mas sorrendben). a prg a megadott dict filebol olvassa be a wordoket es berakja oket egy mapbe. a map key a word betui abc-sorrendben; pl. "staple" eseteben "aelpst", es "petals" eseteben is "aelpst": a ket word anagram, es minden anagramnak uazok lesznek az abc-sorrendezett betui (un. alphagram). a map value egy lista, ami tart az osszes wordot aminek uaz az alfagramja. a dict feldolgozasa utan minden lista egy teljes anagram group lesz. a prg ezutan vegigiteral a map values()-en es kiir minden listet amelynek merete eleri a thresholdot
Map<String, Set<String>> groups = new HashMap<>();
/* twr-ben dictionaryra Scanner, es loopolas a wordokon */ groups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word); 
for(Set<String> group: groups.values()) if(group.size >= minGroupSize) sout(group.size(), group);

wordok insertelese a Java 8 computeifAbsent() metodust haszn. ez a keyt keresi a mapben: ha benne van, akkor a hozzatart valuet returnoli. ha nincs benne, akkor kiszam egy valuet a megadott function objt applyolva a keyre, es a kiszamolt valuet returnoli. ez a metodus egyszerusiti olyan mapek impljat amelyek egy keyhez tobb valuet kapcs

uezt a problemat meg lehet oldani csak streamekkel is; a dict file megnyitasan kivul (az is csak azert h twr-t tudjunk hasznalni) az egesz prg egyetlen expression. ezt ne csinaljuk (peldakodot le sem irom)

szerencsere van kozeput is, ami nem overusolja a streameket, es rovidebb es tisztabb is mint az elso valtozat
try(Stream<String> word = Files.lines(dictionary)) { words.collect(groupingBy(word -> alphabetize(word))).values().stream().filter(group -> group.size() >= minGroupSize).forEach(g -> sout(g.size(), g));
twr-ben megnyitja a dictionary filet, es obtainel egy streamet ami a file osszes sorat tart. a stream neve words, ezzel jelezve h a stream elementjei wordok. a stream pipelinejan nincsenek intermediate operek; a terminal operje collectalja az osszes wordot egy mapbe ami alphabetized formajukban groupolja a wordoket (item 46). ez uaz a map amit a prg elozo valtozataiban is krealtunk. ezutan egy uj Stream<List<String>>-et nyitunk a map values() viewjan. ennek a streamnek az elementjei az anagram groupok. a streamet megfilterezzuk ugy, h ignoraljuk azokat a groupokat amelyek sizeja kisebb mint minGroupSize, es vegul a megmaradt groupokat a forEach() terminal operrel iratjuk ki

a g lambda nevet azert valasztottak mert kulonben tul szeles lett volna a konyvbe a kod, egyebkent group lett volna a jo nev. explicit typeok nelkul a lambda paramok jo elnevezese fontos a stream pipelineok olvashatosaga szempontjabol

vegyuk eszre tovabba h az alphabetize() metodus kulon van (az elozo nem ajanlott megoldasban igazabol volt az volt a jelentos kulonbseg, hogy ez a logika is a streamen belul volt). ez noveli az olvashatosagot mert nevet ad az opernek, es kivul tartja az impl detaileket a main prgn. stream pipelineokban a helper metodusok haszn meg fontosabb mint iterativ kodban mivel a pipelineokban nincsenek expl type infok es named temp varok

ha az alphabetize() metodust streameket haszn irnank meg az valszeg kevesbe lenne tiszta, es lassabb lenne. ezek a hatranyok abbol szarm h a Java nem tam a primitiv char streameket; de nem is lenne feasible ha tam
"Hello World!".chars().forEach(System.out::print);
azt gondolnank h ez Hello World!-ot irna ki, de ha lefuttatjuk akkor latjuk h egy szamsort. ez azert van mert a chars() altal returnolt stream elementjei nem char hanem int valuek, es ezert a print() int overloadja invokolodik. nyilvan confusing h egy chars() nevu metodus int valuek streamjet returnoli. a prgt megfixalhatjuk egy castolas segitsegevel forcolva a megfelelo overloading invokolasara
"Hello World!".chars().forEach(x -> System.out.print(char) x);
de idealis esetben jobb ha nem haszn streameket char valuek processalasara

amikor elkezdunk stremeket haszn, ugy erezhetjuk h minden loopunkat at kellene alakitani streamekke, de ne tegyuk. bar lehetseges, de valszeg nem fog jot tenni a prg olvashatosaganak es maintainabilityjenek. foszabalykent meg a mersekelten komplex taskok megoldasa is legjobb a streamek es az iteration vmilyen kombojaval mint a fenti anagram prg. csakkor refactoraljunk existing kodot streamekre v haszn streameket uj kodban ha avan ertelme

mint az itt bemutatott prgkban lathato volt, stream pipelineok function objk (tip lambdak v metodus refek) hasznalataval vegeznek el ismetelt szamitasokat, mig az iterativ kod blockok segitsegevel csinalja uezt. van par dolog amit kod blockokkal meg tudunk csinalni de function objkkal nem
- readelni es modifolni tudun k bmely, a scopeban levo local vart; lambdabol csak final v eff final varokat tudunk readelni es nem tudunk semmilyen local vart modifolni
- returnolni tudunk az enclosing metodusbol, break-elni v continue-zni egy enclosing loopot v dobni olyan checked exct amelyet a metodus dekl; lambdabol ezeket nem tudjuk

ha egy problemara ezek jellemzoek, akkor ahhoz a streamek valszeg nem tul jok. streamekkel viszont lehetseges
- elementek seqjet uniformly transformalni
- elementek seqjet filterezni
- elementek seqjeit kombinalni egy single operrel (pl. add, concat, min)
- elementek seqjet collba accumulalni, esetleg vmilyen common attr szerint groupolva oket
- elementek seqjet searchelni olyan elementeket keresve amelyek telj vmilyen criteriont 

ha egy problemara ezek jell, akkor valszeg jo candidate streamekre

egy dolog amit streamekkel nehez megcsinalni, a pipeline kulonbozo stagejeibol az osszetartozo elementeket egyszerre accessalni: ha egyszer egy valuet atmappeltunk egy masik valuera, akkor az orig value elveszett. egy workaround ha a valuet egy pair objra mappeljuk, ami az orig es az uj valuet is tart, de ez nem kielegito mo, kulonosen ha a pair objkra tobb kulonbozo pipeline stageben is szukseg van. a kod igy messy es verbose lesz, ami pont nem celja a streamek hasznalatanak. ha megoldhato akkor jobb workaround a maping invertalasa amikor a korabbi stagebeli valuet akarjuk accessalni

pl. elso 20 Mersenne primet akarjuk megtalalni. Mersenne szam def: 2^p - 1. ha p prim akkor a kapcs Mersenne szam lehet h prim; ha az akkor Mersenne prim. a pipeline initial streamjeben az osszes primszamot akarjuk; ez egy infinite stream amit az alabbi metodussal tudunk krealni (BigInteger static importokkal)
static Stream<BigInteger> primes() { return Stream.iterate(TWO, BigInteger::nextProbablePrime);

a metodus neve (primes()) egy tobbesszamu fonev, ami leirja a stream elementjeit. ez a naming conv javasolt minden metodushoz ami streameket returnol, mivel noveli a stream pipeline olvashatosagat. a metodus a Stream.iterate() static factoryt haszn, amely ket paramot vesz at: a stream elso elementjet es egy functiont ami a stream kov elementjet generalja a megelozobol. ezt haszn a feladat megoldasa
primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE)).filter(mersenne -> mersenne.isProbablePrime(50)).limit(20).foreach(System.out::println);
primek streamjebol indul, kiszam a Mersenne szamokat, kifilterezi ami nem prim (az 50 magic nr "controls the probabilistic primality test"), a result streamet 20 elementre limiteli, es kiirja ezeket

tfh minden Mersenne primhez az exponenset (p) is ki akarjuk irni. ez csak az initial streamben elerheto, az eredmenyeket kiiro terminal operbol nem accessible. szerencsere egy Mersenne szam exponenset konnyu kiszam ha invertaljuk az elso intermadiate operben levo mappinget. az exponens a bitek szama a binary reprben, ezert az alabbi terminal oper megfelelo: .forEach(mp -> sout(mp.bitLength(), mp));

szamos task eseteben nem egyertelmu h streameket v iterationt haszn. pl. kartyapakli initje. tfh Card egy immut value class ami Rank es Suit enum typeokat encaps. ez a task repr bmilyen mas taskot ami ket setbol kivalasztando element parok kiszamolasat jelenti (ket set Descartes szorzata)
iterativ impl nested for-each loopokkal
List<Card> result = new ArrayList<>(); for(Suit suit: Suit.values()) for(Rank rank: Rank.values()) result.add(new Card(suit, rank)); return result;
stream-based impl ami intermediate flatMap() opert haszn. ez egy stream minden elementjet atmappeli egy-egy streamre, aztan pedig concatenalja (flatteneli) ezeket egyetlen streamme (a map()-en belul nested lambda van)
Stream.of(Suit.values()).flatMap(suit -> Stream.of(Rank.values()).map(rank -> new Card(suit, rank))).collect(toList());

melyik a jobb? szemelyes pref es a kornyezet donti el. az elso egyszerubb es termeszetesebbnek hat. masodik tomorebb, es nem nehez megerteni ha ismerjuk a streameket es a dfunctional prgozast. ha nem vagyunk biztosak benne akkor valszeg az iterativ a jobb valasztas

summary: egyes taskokat jobban lehet streamekkel vegezni, masokat iterationnel. szamos taskot a ketto kombojaval a legjobb megoldani. nincsenek kobe vesett szabalyok, de vannak hasznos heuristicsek. szamos esetben nyilvanvalo h melyik approachot eredemes haszn, de vannak esetek amikor nem. ha nem vagyunk bizt h melyik a jobb akkor probaljuk ki es nezzuk meg
