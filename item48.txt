ITEM 48: USE CAUTION WHEN MAKING STREAMS PARALLEL

mainstream nyelvek kozott a Java mindig elen jart a conc prg tamban. amikor a Java kijott 1996-ban, built-in suport volt benne threadekhez, synchronizationnal es wait()/notify()-al. Java 5-ben bejott a java.util.concurrent lib, conc collokkal es executor fwel. Java 7-ben bejott a fork-join fw, egy high-perf fw parallel decompositionra. Java 8-ban bejottek a streamek, amelyek parallelizalhatoak egy egyszeru parallel() metodushivassal. conc prgk irasa egyszerusodik, de correct es gyors conc prgkat irni tovabbra is nehez. safety es liveness violationok a conc prgozassal jarnak, es ezalol a parallel stream pipelineok sem kivetelek

pl. item 45-ben szereplo Mersenne primszam prg. ha naivan megprobaljuk felgyorsitani hozzaadva egy parallel() hivast s stream pipelinehoz, annak az lesz a hatasa h nem fog semmit kiirni, hanem a CPU usage felmegy 90%-ra es ott is marad (liveness failure). szerzonel fel ora utan sem allt meg

mi tortent? egyszeruen fogalmazva a streams lib nem tudja hogyan paralellizalja ezt a pipelinet es a heuristics failelni fog. meg a legjobb korulmenyek kozott is, egy pipeline paralellizasa valszeg nem fogja a perfet nov ha a src a Stream.iterate() v az intermediate limit() opert haszn; ebben a streamben pedig mindketto benne van. ami meg rosszabb, a default parallelization strategy "deals with the unpredictability of limit by assuming there’s no harm in processing a few extra elements and discarding any unneeded results". ebben az esetben kb. 2x annyi ideig tart minden Mersenne primet megtalalni mint a megelozot. igy egyetlen extra element kiszamitasanak ktge kb egyenlo lesz az osszes megelozo element kiszamitasanak kombinalt ktgevel, es ez az artalmatlannak tuno pipeline megfekteti az automatikus parallelization algot. a tanulsag egyszeru: ne parallelizaljunk stream pipelineokat valogatas nelkul, mert a perf kovetk katasztrofalis lehet

szabalykent, parallelizalasbol szarm perf nov a legjobb olyan streameken amelyeket ArrayList, HashMap, HashSet es ConcurrentHashMap instanceokon; arrayeken; int rangeken es long rangeken krealunk. ezeknek a data structoknak kozos jell h bmilyen kivant meretu subrangekre pontosan es olcson splittelhetoek, ami egyszeruve teszi h parallel threadek kozt felosszuk a workot. a streams lib altal erre a celra haszn abstraction a spliterator, amit a Stream es Iterable spliterator() metodusa returnol

egy masik fontos tenyezo ami kozos ezekben az data structokban h jo locality-of-referencet nyujtanak, ha sequential vannak processalva: a sequential element refek egyutt vannak tarolva a memben. a refek altal refelt objk nem biztos h kozel vannak egymashoz a memben, ami csokk a loc-of-reft. a loc-of-ref kritikus a bulk operek parallellizalasahoz: enelkul a threadek az ido nagy reszet idleben toltik, arra waitelve h a data a membol a proc cachebe transferralodjon. a legjobb loc-of-refu data structok a primitiv arrayek, mert a data folyamatosan van a memben tarolva 

stream pipeline terminal operje szinten hatassal van a parallel exec hatekonysagara. ha jelentos mennyisegu workot vegzunk a terminal operben a pieline overall workhoz kepest, es ez az oper inherently sequential, akkor a pipeline parallelizalasnak hatasa limited. parallelizalasra a legjobb terminal operek a reduction, ahol a pipelinebol kijovo elemeket a Stream reduce metodusai segitsegevel kombinaljuk ossze, v a prepackaged reductionok mint a min(), max(), count() es sum(). a short-circuiting operek, anyMatch(), allMatch() es noneMatch() szinten alkalmasak paralellizalasra. a Stream collect() metodusa altal vegrehajtott operek az un mutable reductionok nem jok paralleliazalsra, mert a collok kombinalasanak overheadje ktges

ha sajat Stream, Iterable v Collection implt irunk, es jo parallel perfet akarunk, akkor overridolnunk kell a spliterator() metodust, es alaposan tesztelni az eredmenykent kapott streamek perfjet. high qual spliteratorokat irni nehez 

a stream parallelizalas nem csak rossz perfhez vezethet, beleertve liveness failureket; hanem rossz eredmenyekhez es unpred behavhoz is (safety failure). safety failurek eredhetnek egy olyan pipeline paralellizalasabol ami mappereket, filtereket es egyeb, a prgozo altal nyujtott function objkat haszn amelyek nem tartjak be a specjuket. a Stream spec szigoru kovetelmenyeket tamaszt ezekkel a function objkkal szemben. pl. a Stream reduce() operjenek atadott accumulator es combiner functionok associative, non-interfering es stateless kell legyenek. ha ezeket violaljuk (item 46) de sequential futtatjuk a pipelinet, akkor valszeg jo eredmenyt kapunk; ha parallelizaljuk akkor viszont valszeg failel, lehet h katasztrofalisan

meg kell emliteni h ha a parallelized Mersenne prim prg completionig futtot volna, akkor sem a megfelelo (novekvo) sorrendben irta volna ki a primeket. ha uazt a sorrendet szeretnenk mint a sequential verzioban, akkor a forEach() terminal opert forEachOrdered()-re kellene cserelni, ami garantalja h encounter order szerint traversal a parallel streameken

meg ha felt is h egy hatekonyan splittable src streamunk van, paralellizalhato v cheap terminal operrel, es non-interfering function objkkal, nem fogunk a parallelizalasbol jol speedupot nyerni hacsak a pieline nem vegez eleg valodi workot h offsetelje a parallelizalasbol szarm ktgeket. nagyon durva becsleskent, a streamben levo elementek szama szorozva az elementenkent execelt kodsorok szamaval legalabb 100ezer kell legyen

fontos emlekezni ra h egy stream parallelizalasa szigoruan perf optim. mint minden optim eseteben, elotte es utana is tesztelni kell a perft h megeri-e (item 67). idealis esetben a tesztet realistic sys setting mellett kell vegrehajtani. normal esetben egy prgban levo minden parallel sstream pipeline egy common fork-join poolban fut. egyetlen nem jol viselkedo pipeline is karosithatja a tobbiek perfjet, a sys unrelated reszeiben is

ezekbol jol latszik h streamek parallelizalasa egy risky dolog. szerzo egy ismerose tobbmillios kodbazisban csak par helyet talalt ahol a parallel streamek hatekonyak voltak. ez nem jelenti h egyaltalan ne parallelizaljunk streameket. a megfelelo korulmenyek kozot lehetseges a procok szamaban kozel linear speedupot elerni, egyszeruen csak hozaadva a parallel() hivast a stream pieplinehoz. bizonyos domainekben, pl. machine learning v data processing kulonosen jo speedup erheto el

egyszeru pelda ahol stream pipeline parallelizalas hatekony, primek szama amelyek kisebb-egyenlo n-nel
static long pi(long n) { return LongStream.rangeClosed(2, n).mapToObj(BigInteger::valueOf).filter(i -> i.isProbablePrime(50)).count();
szerzo gepen n = 10^8-ra 31 sec-ig fut. rangeClosed() utan egy parallel() hozaadva 9.2 secre csokken, azaz 3.7x-es gyorsulas. meg kell jegyezni h a gyakban vannak erre a problemara sokkal hatekonyabb algok is, pl. Lehmer formula

ha random szamok egy streamjet parallelizaljuk, akkor SplittableRandom instanceal kezdjuk es ne ThreadLocalRandommal (es foleg ne az obsolete Randommal). ezt pontosan erre designoltak, es linear speedup lehetoseg van benne. ThreadLocalRandomot single thread hasznalatra designoltak, es bar adaptalni tudja magat h parallel stream srckent mukodjon, de nem lesz olyan gyors mint a SplittableRandom. a Random minden operre syncel, ezaltal a parallelizalast gyak lehetetlenne tevo contentiont okoz

summary: ne probaljunk meg stream pipeline paralellizalni hacsak jo okunk nincs azt hinni h megorzi a jo eredmenyt, es egyuttal noveli a speedet. nem megfelelo paralallizalas ktge prg failure v perf katasztrofa lehet. ha ugy gondoljuk h a parallelizalas lehetseges, bizt h a kod parallel futas mellett is helyes maradjon, es vegezzunk alapos perf mereseket realistic conditionok mellett. ha a kod helyes maradjon, es a meresek igazoljak a perf novt, csakkor parallelizaljuk a streamet prod kodban