ITEM 49: CHECK PARAMETERS FOR VALIDITY

a legtobb metodusnak es konstrnak van vmi restrictionje arra h milyen valuekat lehet atadni nekik paramkent. pl. nem ritka h az index valueknak nemnegativnak kell lennie, obj refeknek pedig non-nullnak. az ilyen restrictionokat docolni kell, a metodus body elejen pedig csekkekkel enforcolni. ez egy spec esete annak a general principlenek h meg kell probalni az errorokat a leheto leghamarabb detektalni. ha nem igy teszunk az noveli a vget h az error nem lesz detektalva, ill ha megis, akkor neheziti az error src meghatarozasat

ha egy metodusnak invalid paramot adunk at, es a metodust csekkeli ezt meg az execeles elott, akkor gyorsan es tisztan fog failelni, megfelelo exct dobva. ha a metodus nem csekkeli a paramjait akkor tobb dolog tortenhet. a metodus failelhet vmi confusing exc dobasaval a processing kozepen. ennel rosszabb ha a metodus normal modon returnol de rossz eredmenyt szamol ki. legrosszabb ha a metodus normal modon returnol, de vmi objt inkorrekt stateben hagy, ami pedig a jovoben vmikor, a kod vmi unrelated pontjan fog vmi errort okozni. mas szavakkal ha nem validaljuk a paramokat, azzal violalhatjuk a failure atomicityt (item 76)

public es protected metodusokra haszn a Javadoc @throws tagjet h docoljuk az exct ami dobva lesz ha egy param restriction violalodik (item 74). tip az exc IllegalArgumentException, IndexOutOfBoundsException v NPE lesz (item 72). ha ledocoltuk egy metodus paramjaira von restrictionokat, es az exckat amik akkor lesznek dobva ha a restrictionok violalodnak, akkor onnantol mar egyszeru enforcolni a restrictionokat
/* ... @param m the modulus, which must be positive @return this mod m @throws ArithmeticException if m is less than or equal to 0 */
public BigInteger mod(BigInteger m) { if(m.signum() <= 0) throw new ArithmeticException("Modulus <= 0: " + m);

a doc nem mondja h "mod throws NullPointerException if m is null" pedig valojaban ez tortenik, az m.signum() invokolas mellekhatasakent. ez az exc az enclosing BigInteger class docjaban van leirva. a class-level comment minden paramra von a class osszes public metodusaban. ez egy jo mod elkerulni h minden NPEt minden metodusban kulon docljunk. ez kombinalhato a @Nullable v hasonlo anno hasznalataval annak jelzesere h egy adott param lehet null, de ez nem standard, es tobb annot is haszn erre a celra

a Java 7-be hozzaadott Objects.requireNonNull() metodus flex es kenyelmes, mar nem kell manualis null csekkeleseket csinalni. megadhatjuk a sajat exc detail msgunket is ha akarunk. a metodus az inputjat returnoli, tehat a value felhaszn egyidoben hajthatjuk vegre a null csekkelest
this.strategy = Objects.requireNonNull(strategy, "strategy must be not null");
tereszetesen ignoralhatjuk is a return valuet es haszn az Objects.requireNonNull()-t onallo null csekkeleskent

Java 9-ben egy range-checking facilityt adtak java.util.Objects-hez. harom metodusbol all: checkFromIndexSize(), checkFromToIndex(), checkIndex(). ez nem olyan flex mint a null csekkelo metodus. nem tudjuk megadni a sajat exc detail msgunket, es csak list es array indexeken lehet haszn. nem kezel closed rangeket (amelyek mindket endpointot tart). de ha pont erre van szuksegunk, akkor hasznos lehet

nem exportalt metodusoknal, mi, azaz a package authorjai kontrollaljuk h milyen korulm kozott hivhato a metodus, tehat nekunk kell bizt h csak valid param valuek legyenek atadva. ezert a nonpublic metodusok csekkelhetik a paramjaikat assertionokkal
private static void sort(long a[], int offset, int length) { assert a!= null; ...
lenyegeben ezek az assertionok claimek arra nezve h az assertalt condition true lesz, fgtl h az enclosing packaget a clientek hogyan haszn. normal validity csekkektol elteroen assertionok AssertionErrort dobnak ha failelnek. es nornal validity csekkektol elteroen nincs hatasuk es lenyegeben nincs ktguk ha nem enableljuk oket, amit a java command -ea (v -enableassertions) flagjevel tehetunk meg
