ITEM 50: MAKE DEFENSIVE COPIES WHEN NEEDED

Java tobbek kozott azert jo, mert safe nyelv. ez azt jelenti, h ha nincsenek native metodusok, akkor immunis olyan dolgokra mint buffer overrun, array overrun, wild pointer es egyeb mem corruption errorok amik unsafe nyelvekben mint C/C++ jelen vannak. safe nyelvben lehet ugy classokat irni h biztosan tudjuk h az invarjaik meg fognak tartani, fgtl attol h a sys mas reszein mi tortenik. ez nem lehetseges olyan nyelvekben amelyek egy nagy arraykent kezelik a memet

de meg safe nyelvben sem vagyunk alapbol elszigetelve mas classoktol. defensiven kell prgoznunk, azt felt, h a classunk clientjei megprobaljak destroyolni az invarokat. ez jelenthet szandekos tamadast v honest mistaket is, lenyeg h megeri olyan classokat irni amelyek robusztusak a rosszul viselkedo clientekkel szemben

bar mas class nem tudja egy obj internal statejet modifolni az obj altal nyujtott segitseg nelkul, ilyen segitseget meglepoen konnyu nem szandekosan nyujtani. pl. az alabbi class egy allitolag immut time periodot repr
public final class Period {
  private final Date start; private final Date end;
  public Period(Date start, Date end) { if(start.compareTo(end) > 0) throw new IllegalArgumentException(); this.start = start; this.end = end;
  public Date start() { return start; 
  public Date end() { return end;
ez elsore ugy tunik h immut es enforcolja az invart h egy period startja nem lehet az endje utan. de konnyu az invart violalni kihaszn h a Date mutable
Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); end.setYear(78);
ez igy modifolja a p internaljait

Java 8-ban ezt ugy lehet kivedeni ha Date helyett Instant (v LocalDateTime v ZonedDateTime) mivel azok immutok. Date obsolete and uj kodban ne haszn. ezzel egyutt ez egy letezo problema, mivel van amikor mut value typeokat kell haszn az APInkban es internal reprunkban, amire jok az itt targyalt technikak

h megvedjuk a Period instance internaljait az ilyen tamadastol, def copyt kell csinalnunk a konstr minden mut paramjarol es ezeket a copykat haszn az origok helyett
public Period(Date start, Date end) { 
  this.start = new Date(start.getTime()); this.end = new Date(end.getTime());
  if(this.start.compareTo(this.end) > 0) throw new IllegalArgumentException();
igy az elozo tamadasnak nincs hatasa a Period instancera. vegyuk eszre h a def copykat a paramok validity csekelese (item 49) elott krealjuk, es a validity csekkeles a copykon es nem az origokon tortenik. bar ez unnaturalnak tunhet, de szukseges. ez vedi meg a classt attol h egy masik thread meg tudja valt a paramokat a window of vulnerability, azaz a paramok csekkelese es copyzasa kozt eltelt ido alatt (un time-of-check/time-of-use (TOCTOU) attack)

vegyuk eszre h nem a Date clone() metodusat haszn a def copyk krealasara. mivel Date nonfinal, nem garantalt h a clone() egy java.util.Date classu objt returnol; returnolhet egy olyan untrusted subclass instancet amit malicious tamadasra designoltak. egy ilyen subclass pl. minden instancera rogzithet egy refet egy private static listaban az instance krealasakor, a tamado pedig accessalhatja ezt a listet, kontrollalva ezaltal az osszes instanceot. h preventaljuk az ilyen tamadasokat, ne haszn clone() metodust olyan param def copyjanak krealasara, amelynek a typeja untrusted partyk szamara subclassolhato

a modositott konstr megved az elozo tamadas ellen, de tovabbra is lehetseges Period instancet modifolni, mivel az accessorjai hferhetove teszik a mut internaljait
Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); p.end().setYear(78);

ez ellen ugy lehet vedekezni h az accessorok a mut internal fieldek def copyjait returnoljek
public Date start() { return new Date(start.getTime());
public Date end() { return new Date(end.getTime());

az uj konstr es accessorokkal a Priod most mar immut. malicious v incompetent prgozok sem tudjak violalni az invart miszerint period startja nem lehet az endje utan (leszamitva az extralinguistic modokat mint nativ metodusok v refl). ez azert van igy mert magan a Periodon kivul mas class nem szerezhet accesst egy Period instance mut fieldjeire. ezek a fieldek teljesen encapsolva vannak az objba

az accessorokban, a konstr ellentetben, lehet haszn a clone() metodust def copyk krealasara. ez azert van, mert tudjuk h a Priod internal Date objainak classa java.util.Date es nem vmi untrusted subclass. ezzel egyutt jobb konstr v static factoryt haszn instance copyzasara, okokat ld. item 13

paramok def copyzasa nem csak immut classokra jo. valahanyszor olyan metodust v classt irunk amely internal data structban tarol reft egy client altal nyujtott objra, gondoljuk vegig h ez az obj mut-e. ha igen, akkor gondoljuk vegig h a classunk toleralna-e ha az obj megvalt miutan bekerult a data structba. ha nem, akkor def copyznunk kell az objt, es nem az origot hanem a copyt rakni be a data structba. pl. ha egy client altal nyujtott obj reft akarunk elementkent haszn egy internal Set instanceban v keykent egy internal Map instanceban, akkor tudunk kell rola h a set/map invarjai korruptalodnak ha az obj az inserteles utan modifolodik

uez von internal componentek def copyzasara mielott returnoljuk oket a clienteknek. a classunk akar immut akar nem, meg kell gondolni mielott egy mut internal componentre von refet returnolunk. jobb def copyt returnolni. emlekezzunk arra is h nonzero-hosszu arrayek mindig mutok. ezert internal arrayrol mindig def copyt kell krealnunk mielott clientnek returnolnenk. alternativakent returnolhetunk egy immut viewt az arrayre. ezeket a def technikakat item 15 irja le

ennek az egesznek az a tanulsaga h ahol lehet haszn immut objkat az objunk componentjeikent, h ne kelljen def copyznunk (item 17). a Period pelda eseteben Java 8-ban haszn Instant (LocalDateTime v ZonedDateTime). korabbi releasenel egy lehetoseg ha a Date.getTime() altal returnolt primitive longot taroljuk a Det ref helyett

def copynak perf ktge lehet es nem is mindig justified. ha egy class megbizik a hivojaban, h nem fog internal componentet modifolni, mondjuk mert a class es a clientje uabban a packageben vannak, akkor nem szukseges def copyzni. ha igy teszunk, akkor a docban rogziteni kell h a hivo nem modifolhatja az erintett paramokat v return valuekat

meg package boundarykon ativeloen sem mindig szukseges mut paramrol def copyt krealni "before integrating it into an object". vannak metodusok es konstrk amelyek invocationja "indicates an explicit handoff of the object referenced by a parameter". ilyen metodus invokolasakor a client megigeri h nem fogja az objt direktben modifolni. metodus v konstr amely "expects to take ownership of a client-provided mutable object", docjaban ezt rogziteni kell (??)

olyan classok amelyben olyan metodusok v konstrk vannak, amelyek invocationja transfer of controlt jelent, nem tudjak megvedeni magukat malicious clientektol. az ilyen classok csakkor elfogadhatoak, ha mutual trust van a class es a clientje kozott v ha a class invarok serulese senki masnak nem art, csak maganak a clientnek. utobbira egy pelda a wrapper class pattern (item 18). a wrapper class termeszetetol fuggoen a client destroyolhatja a class invarjait ugy h direktben accessalja az objt miutan az be lett wrappelve, de az tip csak maganak a clientnek art

summary: ha egy classban mut componentek vannak, amelyeket clienttol gettel v oda returnol, akkor a classnak ezeket def copyznia kell. ha a copyzas ktge magas ES a class megbizik a clientjeiben h nem modifoljak a componenteket helytelenul, akkor a def copy kivalthato docolassal, ami leirja h a client nem modifolhatja az erintett componenteket