ITEM 51: DESIGN METHOD SIGNATURES CAREFULLY

ez az item API design hintek gyujtemenye, amelyek onmagukban nem erdemelnenek kulon itemeket

- Choose method names carefully
neveknek mindig a standard naming concentionokhoz kell igazodnia (item 68). fo celkent olyan neveket kell val, amelyek erthetoek es konz az uabban a packageben levo tobbi nevvel. masodlagos celkent a neveknek konz kell lenniuk "with the broader consensus, where it exists". ne haszn hosszu metodusneveket. ketely eseten nezzuk meg a Java lib APIkat h ott milyenek vannak. bar ott is van inkonz - ami a libek meretet es scopejat tekintve elkerulhetetlen - de azert jelentos a consensus

- Don’t go overboard in providing convenience methods
minden metodusnak tudnia kell "pull its weight" ("elbirni a sajat sulyat"?). tul sok metodus nehezze teszi egy classt megtanulni, haszn, docolni, tesztelni es maintainelni. ez fokozottan igaz ifacekre, ahol tul sok metodus az implementorok es a userek helyzetet is megneheziti. a classunk v ifaceunk altal supportalt minden actionhoz nyujtsunk egy fully functional metodust. "shorthandet" csakkor nyujtsunk ha gyakran haszn; ha ketelyeink vannak, akkor ne

- Avoid long parameter lists
cel h max 4 param legyen. legtobb prgozo nem tud hosszu param listakat megjegyezni. ha sok metodus tullepi ezt a limitet, az API nem lesz hasznalhato a doc folyamatos csekkelese nelkul. modern IDEk segitenek, de rovidebb param listak igy is jobbak. azonos typeu paramokbol allo hosszu seqek kulonosen karosak. userek nem csak nem fognak emlekezni, de ha veletlenul felcserelik a paramokat, akkor a prg tovabbra is le fog fordulni es futni, csak mast fog csinalni mint amit varnak

harom mod van a tul hosszu param listak roviditesere. az egyik ha feldaraboljuk a metodust tobb kisebb metodusra, amelyek mindegyikenek csak a paramok egy subsetjere van szuksege. ha nem jol csinaljuk akkor ez tul sok metodushoz is vezethet, de akar csokkentheti is a metodusok szamat az ortogonalitas novelesevel. pl. java.util.List iface nem nyujt metodusokat egy element egy sublistben valo elso ill utolso elofordulasi indexenek megtalalasahoz, amelyek darabonkent 3 paramot igenyelnenek. helyette nyujtja a subList() metodust amely ket paramot vesz at es a sublist egy viewjat returnoli. a kivant funkciohoz ez a metodus kombinalhato az indexOf() v lastIndexOf() metodussal, amelyeknek csak egy paramja van. tovabba a subList() metodus osszekombinalhato bmilyen metodussal ami List instanceon operal, h arbitrary szamitasokat tudjunk sublisten vegezni. az ilyen APInak nagyon magas power-to-weight ratioja van

a hosszu param listak roviditesenek masodik modja ha helper classokat krealunk arra h param groupokat tartsanak. ezek tip static member classok (item 24). ez a techn akkor ajanlott ha paramok egy gyakran elofordulo seqje vmi distinct entityt repr. pl. ha egy olyan classt irunk ami egy kartyajatekot repr, es azt vesszuk eszre h allandoan ket param seqjet adjuk at ami egy kartya rankjat es suitjat repr. az APInk, es a classunk internaljai is valszeg benefitelnenek abbol ha krealnank egy helper classt ami egy cardot repr, es a param seq minden elofordulasat kicserelnenk egy helper class typeu paramra

harmadik mod, amely kombinalja az elozo kettot, a Builder pattern (item 2) adaptalasa obj krealasrol metodus invokolasra. ha van egy sokparamos metodusunk, fokent ha a paramok egy resze opcionalis, akkor elonyos lehet def egy objt ami az osszes paramot repr, a client pedig tobb "setter" hivast hajthat vegre ezen az objn, amelyek mindegyik egy paramot, v egy kis, related param groupot settel be. ha a kivant paramok be vannak settelve, akkor a client invokolja az obj "execute" metodusat amely vegrehajtja a vegso validity csekkeket a paramokon ha kell, aztan pedig a tenyleges szamitast

- For parameter types, favor interfaces over classes (item 64)
ha van megfelelo iface egy param reprjara akkor haszn azt, es ne egy olyan classt ami impl ezt az ifacet. pl. nem indokolt olyan metodust irni ami HashMapet vesz at, haszn Mapet helyette. igy beadhatunk HashMapet, TreeMapet, ConcurrentHashMapet, TreeMap vmely submapjet v bmilyen Map implt. ha iface helyett classt haszn, akkor egy adott implhoz kotjuk a clientet es kikenyszeritunk egy szuksegtelen es esetleg ktges copy muveletet ha az input data esetleg mas formaban van

- Prefer two-element enum types to boolean parameters (unless the meaning of the boolean is clear from the method name)
enumokkal a kod egyszerubben olvashato es irhato. vmint lehetove teszik h kesobb tovabbi optionokat adjunk hozza. pl. lehet egy Thermometer typeunk egy static factoryval, ami ezt az enumot veszi at
public enum TemperatureScale { FAHRENHEIT, CELSIUS}
Thermometer.newInstance(TemperatureScale.CELSIUS) nem csak sokkal ertelmesebb mint Thermometer.newInstance(true), de kesobb a TemperatureScale-hez hozzaadhatjuk pl. a KELVIN-t anelkul h a Thermometer-hez uj static factoryt kellene adnunk. vmint refactoralhatjuk a temperature-scale dependencyket enum constant metodusokba (item 34). pl. minden scale constantnak lehet egy metodusa, ami double valuet vesz at es Celsiusba konvertalja
