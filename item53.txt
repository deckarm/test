ITEM 53: USE VARARGS JUDICIOUSLY

vararg metodusok, pontos nevukon variable arity metodusok 0 v tobb argot vesznek at egy adott typebol. a vararg facility eloszor egy arrayt kreal, amelynek merete a hivasban atadott argok szama, aztan berakja az arg valuekat az arraybe, es vegul atadja az arrayt a metodusnak

pl. egy vararg metodus, amely int argok egy seqjet veszi at, es az osszeguket returnoli. sum(1,2,3) eredmenye 6, sum() eredmenye 0
static int sum(int... args) { int sum = 0; for(int arg:args) sum+=arg; return sum;

neha szukseges olyan metodust irni ami 1 v tobb argot vesz at egy adott typebol. pl. egy metodus, ami az argjainak minimumat szam. ennek nyilvan nincs ertelme ha a client nem ad at argot. az array hossza runtimeban csekkelheto
static int min(int... args) {
  if(args.length == 0) throw new IllegalArgumentException();
  int min = args[0]; for(int i = 1; i < args.length; i++) if(args[i] < min) min = args[i]; return min;
ennek szamos probleaja van. legkomolyabb h ha a client arg nelkul invokolja, akkor runtimeban failel el es nem compile timeban. a masik problema h csunya. explicit validity csekket kell beraknunk az argsra, es nem tudunk for-each loopot haszn, ha nem initeljuk min-t Integer.MAX_VALUE-ra, ami szinten csunya

szerencsere van jobb mod is ra. dekl a metodust ugy h ket paramot vegyen at, egy normal paramot az adott typebol, es egy varargot uebbol a typebol
static int(int firstArg, int... remainingArgs) { 
  int min = firstArg; for(int arg: remainingArgs) if(arg < min) min = arg; return min;
  
mint ebbol a peldabol is lathato, varargok akkor hatekonyak, ha olyan metodust akarunk amelynek valtozo szamu argja lehet. varargokat a printf()-hez designoltak, ami ugyanakkor kerult a platformba, vmint a core reflcetion facilityhez (item 65) ami retrofitteltek. mindketto jelentosen benefitelt a varargsbol

legyunk ovatosak ha perf krit helyzetekben haszn a varargokat. egy varargs metodus minden invocationje array allocot es initet jelent. ha tudjuk h nem engedhetjuk meg ezt a ktget, de szuksegunk van a varargs flexre, van ra mo. tfh tudjuk h a metodushivasok 95%-anak 3 v kevesebb paramja van. ekkor dekl ot overloadingot a metodushoz, negyet 0-3 normal parammal, az otodiket pedig vararggal a 3-nal tobb param esetere
public void foo() + (int a1) + (int a1, int a2) + (int a1, int a2, int a3)
public void foo(int a1, int a2, int a3, int... rest)

igy tudjuk h az array krealas ktget csak az invocationok 5%-ban kell megizetnunk, amikor a paramok szama >3. mint a legtobb perf optim, ez a technika alt nem appropriate, de eletet menthet

az EnumSet static factoryjai hasznaljak ezt h az enum setek krealasanak ktget minimumra szoritsak. ez azert kellett, mert krit volt h az enum setek a bit fieldek egy perf++ helyettesiteset nyujtsak (item 36)

summary: varargok hasznosak ha olyan metodust kell def, amelynek valtozo szamu argja van. varargokat elozzek meg a required paramok, es figyeljunk a varargok perf ktgere
