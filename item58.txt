ITEM 58: PREFER FOR-EACH LOOPS TO TRADITIONAL FOR LOOPS

ahogy item 45 leirta, egyes taskokhoz jobbak a streamek, masokhoz az iteration
traditional for loop collon es arrayen
for(Iterator<Element> i = c.iterator(); i.hasNext();) { Element e = i.next(); //do sg with e
for(int i = 0; i < a.length; i++) { //do sg with a[i]

ezek jobbak mint a while loopok (item 57) de nem tokeletesek. az iterator es az index varok csak zajt jelentenek, csak az elementekre van szuksegunk. ezenkivul ezek hibalehetoseget is jelentenek. az iterator a loopban 3x fordul elo, az index var 4x, ami azt jelenti h sok helyen hasznalhatunk veletlenul rossz vart. ha ez tortenik, nem garantalt h a compiler eszreveszi a problemat. vegul, a ket loop meglehetosen kul, a container typenak tul nagy a szerepe, es ezt a typeot korulmenyes megvalt

for-each loop (mas neven enhanced for stmt) megoldja ezeet a problemakat. nincs benne zaj es hibalehetoseg mert elrejti az iterator es index varokat. az idiom egyforman muk collokra es arrayekre, es konnyen meg lehet a container impl typejat valt
for(Element e:elements) { //do sg with e

a kettospont kiolvasva "in", tehat a loop jelentese "for each element e in elements". foreach loopnak nincs perf ktge, meg arrayekre se: a generalt kod lenyegeben identical azzal a koddal amit kezzel irnank

a foreach loop elonyei a traditional for looppal szemben meg nagyobbak nested iter eseteben. gyakori hiba nested iternel
enum Suit {...}  enum Rank {...}
static Collection<Suit> suits = Arrays.asList(Suit.values()); static Collection<Rank> ranks = Arrays.asList(Rank.values()); List<Card> deck = new ArrayList<>(); 
for(Iterator<Suit> i = suits.iterator(); i.hasNext(); ) 
  for(Iterator<Rank> j = ranks.iterator(); j.hasNext(); ) 
    deck.add(new Card(i.next(), j.next()));
nehezen eszlelheto hiba: a next() metodus tul sokszor hivodik meg a kulso collon (suits). a kulso loopbol kellene meghivni h suitenkent 1x hivodjon meg, de ehelyett a belso loopban van meghivva, tehat cardonkent 1x hivodik meg. miutan vegigfutottunk a suitokon, a loop NoSuchElementExceptiont dob

ha nagyon balszerencsesek vagyunk, akkor a kulso coll merete eppen tobbszorose a belso collenak - talan azert, mert uaz a ket coll - a loop normalisan fog terminalni, de nem azt csinalja, amit varnank. pl. az alabbirol azt varnank h ket kockaval dobott minden lehetseges valtozatot kiirja
enum Face { ONE, TWO, THREE, FOUR, FIVE, SIX }
Collection<Face> faces = EnumSet.allOf(Face.class);
for(Iterator<Face> i = faces.iterator(); i.hasNext(); ) 
  for(Iterator<Face> j = faces.iterator(); j.hasNext(); ) 
    sout(i.next(), j.next());
nem dob exct de csak a hat "duplat" irja ki ("ONE ONE" ... "SIX SIX"), nem mind a 36 lehetseges valtozatot

fixalashoz a kulso loop scopejaba kell tenni egy vart, ami a kulso elementet tart
for(Iterator<Suit> i = suits.iterator(); i.hasNext(); ) {
  Suit suit = i.next();
  for(Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
    deck.add(new Card(suit, j.next()));
ez muk, de nem tul szep

ha nested for-each loopot haszn, akkor a problema egyszeruen eltunik
for(Suit suit: suits) for(Rank rank: ranks) deck.add(new Card(suit, rank));
	
sajnos van harom common eset ahol nem lehet for-eachet haszn
- destructive filtering: ha ugy kell egy collon traversalnunk, h menet kozben removolnunk kell egyes elemeket, akkor explicit iteratort kell haszn h meg tudjuk hivni a remove() metodusat. explicit traversal Java 8 ota neha elkerulheto a Collection removeIf() metodusaval
- transforming: ha listen v arrayen kell traversalni es replacelnunk kell nehany v az osszes elementjenek a valuejat, akkor ehhez szuksegunk van a list iteratorra v array indexre
- parallel iteration: ha tobb collt kell parallel traversalnunk, akkor explicit controlra van szuksegunk az iterator v az index var folott, h minden iterator v index var "can be advanced in lockstep" (mint a fenti buggy card es kocka peldakban lattuk)
ha ezen esetek vmelyikevel van dolgunk, akkor haszn egy normal for loopot es figyeljunk az ebben az itemben emlitett problemakra

for-each loop nemcsak collokon es arrayeken valo iteralast teszi lehetove, hanem bmely olyan objn amely impl az Iterable ifacet, amelyben egyetlen metodus van: Iterator<E> iterator();
kicsit trukos az Iterablet impl ha scractchbol kell megirnunk a sajat Iterator implnkat, de ha olyan typeot irunk ami elementek groupjat repr, akkor erosen fontoljuk meg h ez implja Iterablet, meg ha Collectiont nem is implja. igy a usereink for-each looppal tudnak majd iteralni a typeunkon

summary: a for-each loopnak jelentos elonyei vannak a traditional for looppal szemben atlathatosag, flex es bug prevention szempontbol, es nincs perf ktg. ahol tehetjuk, haszn for-each loopot for loop helyett