ITEM 60: AVOID FLOAT AND DOUBLE IF EXACT ANSWERS ARE REQUIRED

float es double typeokat elsosorban sci calcokra designoltak. binary floating-point aritmetikat hajtanak vegre, amellyel pontos approximaciokat valositanak meg sok nagysagrendben. de nem nyujtanak exact eredmenyt es nem szabad oket olyan helyeken haszn ahol exact eredmeny kell. a float es double typeok kulonosen rosszak monetary szamitasokra, mivel nem lehet 0.1-et (v a 10 bmely neg hatvanyat) floatkent v doublekent repr

pl. 1.03$-bol akarunk 42c-t elkolteni, mennyi marad?
sout(1.03 - 0.42);
a kiiras 0.6100000000000001 lesz. es ez nem egyedi eset. pl. 1$-unk van es 9 termeket akarunk venni, darabjat 10c-ert
sout(1.00 - 9 * 0.10);
a kiiras 0.09999999999999998 lesz

gondolhatnank h a problema megoldhato ha a resultot kiiras elott kerekitjuk, de ez nem mindig muk. pl. van egy $-unk, a termekek ara pedig 10c, 20c, 30c stb. minden termekbol egyet akarunk venni 10c-tol felfele, ameddig van penzunk
double funds = 1.00; int itemsBought = 0; 
for(double price = 0.10; funds >= price; price += 0.10) { funds -= price; itemsBought++ } 
sout(itemsBought, funds);
kiiras 3 es 0.3999999999999999 lesz, ami nem a helyes valasz!

a megoldas ha monetary szamitasokra BigDecimal, int v long haszn. javitott verzioban a BigDecimal String konstrt haszn es nem a double konstrt, h elkeruljuk h pontatlan valuek jojjenek be a szamitasba
final BigDecimal TEN_CENTS = new BigDecimal(".10"); int itemsBought = 0; BigDecimal funds = new BigDecimal("1.00");
for(BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = price.add(TEN_CENTS)) { funds = funds.subtract(price); itemsBought++; }
sout(itemsBought, funds);
igy mar a helyes valaszt kapjuk, miszerint 4 termeket tudunk venni, es 0.00 penzunk marad

BigDecimal haszn ket hatranya: kevesbe kenyelmes mint primitiv aritm typeot haszn, es lassabb. az utobbi irrelevans ha egy rovid problemat oldunk meg, de az elobbi zavaro lehet

BigDecimal alternativaja lehet int v long, az osszegektol fuggoen, es a tizedespontot magunk kezeljuk. ebben a problemaban a nyilvanvalo approach ha $ helyett centben szamolunk
int itemsBought = 0; int funds = 100;
for(int price = 10; funds >= price; price += 10) { funds -= price; itemsBought++; }
sout(itemsBought, funds);

summary: ne haszn floatot v doublet olyan szamitashoz ami exact eredmenyt igenyel. haszn BigDecimalt ha azt akarjuk h a sys trackelje a tizedespontot, es ha nem zavar a kenyelmetlenseg h nem primitiv typeot haszn. BigDecimal elonye h a kerekitest controllalhatjuk, 8 lehetseges rounding modebol lehet val. ez hasznos ha olyan business szamitasokat vegzunk, ahol a kerekitesi mod legally meg van hat. ha fontos a perf, tudjuk trackelni a tizedespontot es a mennyisegek nem tul nagyok akkor haszn intet v longot. ha a mennyisegek nem lepik tul a 9 dec digitet akkor int, ha a 18 dec digitet akkor long. ha tullephetik a 18 dec digitet akkor BigDecimal