ITEM 61: PREFER PRIMITIVE TYPES TO BOXED PRIMITIVES

Java type sys ket reszbol all: primitivek, mint int, double, boolean es ref typeok mint String, List. minden primitive typehoz tart egy ref type, un boxed primitive. int, double, boolean boxed primitivjei Integer, Double, Boolean

item 6 szerint autoboxing/unboxing elhomalyositja de nem szunteti meg a kulonbseget a primitive es boxed primitive typeok kozt. ketto kozt jelentos kulonbsegek vannak es fontos figyelni arra h melyiket haszn


harom alapveto kul. eloszor, primitiveknek csak valueja van, boxed primitiveknek viszont value mellett van identityjuk is. maskent, ket boxed primitive instancenak lehet uaz a valueja de mas az identityje. masodszor, primitive typeoknak csak fully functional valuejai lehetnek, mig minden boxed primitivenek ezeken kivul van egy nonfunctional valuje is, a null. vegul, a primitivek time/space hatekonyabbak mint a boxed primitivek. mindharom kul komoly gondot okozhat ha nem figyelunk

pl. comparator Integer valuek asc orderjere. gyakban nem kell ilyet irnunk, mert ez az Integer natural orderingje, de jo pelda
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
ugy nez ki h muk es szamos teszten atmegy. pl. Collections.sort()-al egyutt haszn helyesen sortol millio elementes listat, duplicate elementekkel is. de valojaban sulyosan flawed. pl. naturalOrder.compare(new Integer(42), new Integer(42)); mindket Integer instance uazt a valuet repr, tehat az osszehas eredmenye 0 kellene legyen, de 1 lesz, ami azt jelentene h az elso Integer value nagyobb mint a masodik

mi a problema? az elso csekk jol muk. i < j expr evaluationja auto-unboxolja az i es j altal ref Integer instanceokat, azaz extractolja a primitive valuejaikat; majd csekkeli h az elso int value kisebb-e mint a masodik. tfh nem. ekkor az i == j expr evaluationja jon, ami identity comparisont csinal a ket obj ref kozt. ha az i es j distinct Integer instanceokra ref, amelyek uazt az int valuet repr, akkor ez falseot returnol, a comparator pedig helytelenul 1-et returnol, amivel azt jelzi h az elso Integer value nagyobb mint a masodik. == operatort haszn boxed primitivekre szinte mindig rossz

gyakban, ha egy type natural orderjet leiro comparatorra van szukseg, akkor haszn Comparator.naturalOrder(); ha pedig sajat comparatort irunk akkor haszn a comparator construction metodusokat v a static compare metodusokat a primitive typeokon (item 14). a fenti comparatorban a hibat fixalhatjuk ha def ket local vart amelyekben eltaroljuk a boxed Integereknek megfelelo primitive int valuekat, es minden comparalast ezeken vegzunk. igy elkeruljuk a hibas identity comparisont
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> { int i = iBoxed, j = jBoxed; return i < j ? -1 : ( i == j ? 0 : 1); };

nezzuk az alabbi prgt
static Integer i; main() { if(i == 42) sout("unbelievable");
ez NPEt dob amikor az i == 42 exprt evalualja. a problema h i Integer es nem int, es mint minden nonconstant ref fieldnek, az init valueja null. az i == 42 expr evalualasa soran Integert comparal inthez. szinte minden esetben amikor primitiveket es boxed primitiveket keverunk egy operben, a boxed primitive auto-unboxolva lesz. ha egy null obj ref auto-unboxolodik, akkor NPEt kapunk. mint ez a prg mutatja, ez szinte barhol elofordulhat. fixalni egyszeru, i dekl intkent Integer helyett

vegul nezzuk ezt az item 6 prgt
Long sum = 0L; for(long i = 0; i < Integer.MAX_VALUE; i++) sum +=; sout(sum);
ez igy sokkal lassabb mint kellene, mert a sum local var Long boxed primitivekent van dekl, long primitive type helyett. a prg error v warning nelkul lefordul, futas soran a var viszont folyamatosan boxolva es unboxolva lesz, ami perf--

az itemben targyalt mindharom esetben uaz a problema: prgozo nem tett kulonbseget primitivek es boxed primitivek kozt. az elso ket prgban failure lett, a harmadikban perf--

mikor haszn boxed primitiveket? szamos legit haszn van. eloszor, coll elementkent, keykent, valuekent. collokba nem rakhatunk primitiveket, ezert boxed primitiveket kell haszn. ez egy general elv spec esete. parametrized typeokban es metodusokban (ch 5) boxed primitiveket kell haszn type paramkent, mert a nyelv nem teszi lehetove h primitiveket haszn. pl. nem lehet vart dekl ThredLocal<int>, hanem ThreadLocal<Integer> kell. vegul refl metodus invocationoknel is boxed primitiveket kell haszn (item 65)

summary: haszn primitiveket amennyiben valasztasi lehetosegunk van. primitive typeok egyszerubbek es gyorsabbak. ha boxed primitiveket kell haszn, akkor ovatosan. autoboxing csokk a verbosityt, de a veszelyt nem. ha a prgunk ket boxed primitivet ==-el comparal, akkor identity comparisont csinal, ami szinte biztosan nem az amit akarunk. ha a prgunk mixed-type szamitasokat csinal, boxed es unboxed primitiveket is haszn, akkor unboxingokat fog csinalni, es ha unboxingot csinal, akkor NPEt dobhat. vegul, ha a prgunk primitive valuekat boxol, az szuksegtelen es ktges obj krealasokat okozhat