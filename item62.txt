ITEM 62: AVOID STRINGS WHERE OTHER TYPES ARE MORE APPROPRIATE

Stringek designalasanak celja h textet repr, es ebben jok. mivel a stringek gyakoriak, es a nyelv jol tam oket, tendencia h masra is akarjak haszn oket mint amire designoltak. ez az item attekint par dolgot amire ne haszn stringet

- Strings are poor substitutes for other value types
amikor egy prgba data erkezik filebol, nwrol, keyboardrol, az gyakran string formaban tortenik. tendencia h ugy is hagyjuk, de ez csakkor justified ha a data naturally textual. ha numeric, akkor at kell forditani a megfelelo numeric typeba, pl. int, float, BigInteger. ha valasz egy igen-nem kerdesre, akkor at kell forditani egy megfelelo enum typeba v booleanba. altalanosabban, ha van megfelelo value type, akar primitive akar obj ref, akkor azt kell haszn; ha nincs, akkor irnunk kell egyet. bar ez a tanacs nyilvanvalonak tunik, gyakran violaljak

- Strings are poor substitutes for enum types
ld item 34, az enumok sokkal jbb enumerated type constantok mint a stringek

- Strings are poor substitutes for aggregate types
ha egy entitynek tobb componentje van, alt nem jo otlet single stringgel repr. pl. az alabbi egy IRL sysben talalhato
String compoundKey = className + "#" +.next();
ennek az apparoachnak szamos hatranya van. ha az elvalasztokent hasznalt char elofordul az egyik fieldben is, akkor gond lehet. a fieldek accessalasahoz parsolni kell a stringet, ami lassu, korulmenyes, error-prone. nem nyujthatunk sajat equals(), toString(), compareTo() metodusokat, hanem azt a behavot kell haszn amit a String nyujt. jobb approach ha irunk egy classt ami repr az aggregatet, ez gyakran private static member class (item 24)

- Strings are poor substitutes for capabilities
neha stringet haszn h accesst grantoljunk vmilyen functionalityhez. pl. thread-local var facility olyan varokat nyujt, "for which each thread has its own value". Java libekben 1.2 ota van benne, de azelott prgozoknak sajatot kellett irniuk. ez olyan designokhoz vezetett, ahol client altal nyujtott string keyeket haszn a thread-local varok identifyolasara
public class ThreadLocal {
  private ThreadLocal() {} //noninstantiable
  public static void set(String key, Object value); //besetteli a current thread valuejat a megadott keyhez
  public static Object get(String key); //returnoli a current thread valuejat a megadott keyhez
ezzel az a problema, h a string keyek egy shared global namespacet repr a thread-local varokhoz. ahhoz hogy ez mukodjon, a client altal nyujtott string keyeknek uniquenak kell lennie: ha ket client veletlenul uazt a nevet val a thread-local varjaknak, akkor sharelni fognak egy single vart, ami alt mindket client failjet fogja okozni. security is gyenge. egy malicious client szandekosan hasznalhatja uazt a string keyt mint egy masik client, h accesst szerezzen a masik client datajahoz

az API fixalhato, ha string helyett egy nem hamisithato keyt (un capabilityt) haszn
public class ThreadLocal {
  private ThreadLocal() {} //noninstantiable
  public static class Key { Key() {} } //capability
  public static Key getKey() { return new Key(); } //unique, nem hamisithato keyt general
  public static void set(Key key, Object value); 
  public static Object get(Key key); 

ez megoldja a stringes API mindket problemajat, de lehet ennel jobb is. a static metodusokra igazabol mar nincs szukseg. helyette lehetnek a key instance metodusai; es innentol kezdve a key nem a thread-local var keye tobbe: hanem o maga a thread-local var. es innentol a top-level classnak igazabol mar nincs is hozzaadott erteke, tehat torolhetjuk, es atnevezhetjuk a nested classt ThreadLocalra
public final class ThreadLocal {
  private ThreadLocal();
  public void set(Object value);
  public Object get();

ez nem typesafe, mivel az Objectben levo valuet castolni kell az actual typejara amikor retrieveljuk a thread-local varbol.  az eredeti stringes APIt lehetetlen typesafe tenni, es a keyeset is nehez, itt viszont egyszeruen parametrized classa lehet alakitani a ThreadLocalt (item 29)
public final class ThreadLocal {
  private ThreadLocal();
  public void set(T value);
  public T get();
  
ez igy nagyjabol az az API amit a java.lang.ThreadLocal is nyujt. megoldja a stringes API problemait, gyorsabb es elegansabb mint a keyes APIk

summary: keruljuk el a kesztetest h stringkent repr objkat, vannak jobb data typeok v irhatoak. nem megfeleloen haszn stringek korulmenyesek, kevesbe flex, lassabbak es error-proneabbak mint mas typeok. pl. primitive typeok, enumok es aggr typeok helyett gyakran haszn helytelenul stringeket