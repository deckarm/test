ITEM 63: BEWARE THE PERFORMANCE OF STRING CONCATENATION

string concat operator (+) kenyelmes mod stringek osszefuzesere. jol muk pl. egysoros output v kismeretu, fixed-size obj string reprjanak generalasara, de nem scalable. n db string concatolasara hasznalva n quadratic lesz az idoigenye. ez a string immut kovetkezmenye (item 17). ha ket stringet concatolunk, mindketto tartalma lecopyzodik

pl. az alabbi mondjuk egy billing stmtnek a string reprjat krealja, ismetelten concatolva a lineokat
String result = ""; for(int i = 0; i < numItems(); i++) result += lineForItem(i); return result;
perf nagyon rossz ha az itemek szama nagy. megfelelo perf eleresehez StringBuildert kell haszn String helyett a krealas alatt levo stmt tarolasara
StringBuilder b = new StringBuilder(numItems() * LINE_WIDTH); for(int i = 0; i < numItems(); i++) b.append(lineForItem(i)); return b.toString();

Java 6 ota jelentos erofesziteseket tettek string concat gyorsitas erdekeben, de a ket mo kozti perf kul meg mindig jelentos. ha numItems() 100-at returnol, lineForItem() pedig egy 80 char hosszu stringet, akkor a masodik mo szerzo gepen 6.5x gyorsabb. mivel az elso mo az itemek szamaban quadratic, a masodik viszont linear, a perf kul az itemek szamanak novekedesevel meg nagyobb lesz. vegyuk eszre h a masodik mo preallocol egy StringBuildert ami eleg nagy a result tarolasahoz, igy nem kell menet kozben autom novelni; de meg ha default-sized StringBuildert haszn, akkor is 5.5x gyorsabb mint az elso mo

az elv egyszeru: ne haszn a string concat opert nehany string osszefuzesenel tobbre, hacsak a perf nem irrelevans. haszn StringBuilder.append() metodust helyette. alternativakent haszn char arrayt v processaljuk a stringeket egyenkent, osszefuzes helyett
