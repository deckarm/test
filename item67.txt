ITEM 67: OPTIMIZE JUDICIOUSLY

harom mondas az optimalizalasrol amit mindenkinek ismernie kell
- efficiency neveben tobb bunt kovettek el sztechben (anelkul h egyebkent elertek volna) mint bmely mas okbol, beleertve a sima ostobasagot is (Wulf)
- small efficiency az esetek 97%-ban felejtos: premature opt is the root of all evil (Knuth)
- optim soran ket szabaly 1) ne csinaljuk 2) (experteknek) MEG ne csinaljuk - amig nincs egy teljesen tiszta unopt mo (Jackson)
mindharom mondas 2 evtizeddel a Java nyelv elott szuletett. lenyeg: optimmal konnyebb bajt okozni mint javitast, foleg ha premature csinaljuk. igy olyan swt allithatunk elo ami se nem gyors, se nem helyes, es nem egyszeru javitani

ne aldozzunk be arch principleket perf miatt. arra torekedjunk h jo prgt irjunk es ne arra h gyorsat. ha egy jo prg nem eleg gyors, az archja lehetove teszi majd h optimizaljuk. jo prgk alk az info hiding principlet: ahol lehetseges, indiv componentekbe lokalizaljak a design donteseket, ezert ezek a dontesek modosithatoak anelkul h affectalnak a sys tobbi reszet (item 15)

ez nem jelenti azt h a perf szempontok ignoralhatoak egeszen a prg befejezeseig. impl problemak fixalhatoak kesobbi optimizalassal, de perf-- okozo sulyos arch flawk fixalasa nem biztos h lehetseges a sys ujrairasa nelkul. a design egy fundamental reszenek megvalt pedig egy ill-structured syst eredmenyezhet, amit nehez maintainelni es evolvalni. ezert mar a design process soran gondolnunk kell a perfre

torekedjunk ra h elkeruljuk az olyan design donteseket amelyek limitaljak a perft. a design azon componentjei amelyek legnehezebben megvaltoztathatoak, a componentek kozti ill a kulvilaggal valo interactionok specelese. ezen design componentek kozt a legfontosabbak az APIk, wire-level protocolok es persistent data formatok. nem csak a componentek megvalt nehez v lehetetlen, de komoly limiteket jelenthetnek a sys altal valaha elerheto perfre is

gondoljunk az API design donteseink perf kovetkezmenyeire. ha egy public typeot mut teszunk, az sok szuksegtelen def copyzast igenyelhet (item 50). hasonloan, ha inheritancet haszn egy public classban, ahol compositiont kellene, az a classt orokre hozzakoti a superclassahoz, ami mesterseges limitet jelenthet a subclass perfjere (item 18). ha iface helyett impl typeot haszn egy APIban, az hozzakot minket egy adott implhoz, bar lehet h a jovoben ennel gyorsabb implkat is irnak majd (item 64)

az API design hatasai a perfre nagyon is realis problemat jelentenek. pl. java.awt.Component.getSize() metodus. az a dontes h ez a perf-krit metodus egy Dimension instanceot returnol, azzal egyutt h a Dimension instanceok mutok, azt jelenti h a metodus bmilyen impljanak minden invocationkor egy uj Dimension instanceot kell allocolnia. bar kis objk allocolasa modern VMeken mar nem ktges, de objk millioinak szuksegtelen allocolasa perf-- lehet

szamos ennel jobb API design alternativa lett volna. idealis esetben Dimension immut lenne (item 17); alternativakent a getSize() helyett lehetett volna ket metodus, amelyek a Dimension obj indiv primitive componentjeit returnolik. Java 2-ben egyebkent ezeketz hozza is adtak a Componenthez perf okok miatt. az ezt megelozo client kodok viszont meg mindig a getSize() metodust haszn, es szenvednek az orig API design dontes kovetkezmenyeitol

szerencsere alt a jo API design konz ajo perffel. nagyon rossz otlet APIt warpolni ("elgorbiteni"?) perf erdekeben. a perf issue ami miatt warpoljuk az APIt, a platform v egyeb underlying sw egy kesobbi releaseben eltunhet, de a warpolt API az osszes hatranyaval egyutt ott marad a nyakunkon

ha egyszer alaposan megdesignoltuk a prgt, es krealtunk egy tiszta, tomor es jol strukturalt implt, akkor lehet az optimon gondolkodni, amennyiben a prg perfjevel nem vagyunk megelegedve

Jackson fenti ket optim szabalya: 1 "ne csinaljuk", 2 "meg ne csinaljuk". hozzaadhatott volna meg egy harmadikat is: merjunk perfet minden megkiserelt optim elott es utan. az eredmenyek meglepoek lehetnek. gyakran a megkiserelt optimoknak nincs merheto hatasa perfre; neha meg rontanak is rajta. a fo ok, h nehez megjosolni h a prg hol fogja a legtobb idot tolteni. a prg azon resze, amirol azt gondoljuk, h az lassu, lehet h nem az, es ekkor az optim csak idopazarlas. alt az a jell h a prgk az ido 90%-at a kodjuk 10%-ban toltik

profiling toolok segithetnek eldonteni hova fokuszaljuk az optim effortjainkat. ezek a toolok runtime infot nyujtanak, pl. az egyes metodusok mennyi ideig tartanak, es hanyszor vannak invokolva. a tuning effortok fokuszalasa mellett ez figyelmeztethet algo valtozasok szuksegessegere is. ha quadratic v rosszabb algo van a prgunkban azon semmilyen tuning nem fog segiteni. ki kell cserelnunk az algot egy hatekonyabbra. minel tobb kod van a sysben, annal fontosabb profilert haszn. ~ tu a szenakazalban: minel nagyobb a kazal, annal hasznosabb metal detectort haszn. masik tool ami emlitest erdemel a jmh, ami egy microbenchmarking fw ami reszletes vist nyujt a Java kod perfjaba

megkiserelt optimok hatasanak merese Javaban meg fontosabb mint hagyomanyos nyelvekben mint C,C++ mivel a Javaban gyengebb perf model van: a klf primitive operek relativ ktge kevesbe jol def. nagyobb az "abstraction gap" akozott amit a prgozo megir es amit a CPU futtat, ami nehezebbe teszi megbizhatoan megjosolni az optimok perf kovetkezmenyeit. szamos perf mitosz van, ami valojaban feligazsag vagy teljesen fals

Java perf model nemcsak ill-defined, de kul implkent, releasenkent es proconkent. ha a prgunkat tobbfele implon v hw platformon akarjuk futtatni, akkor fontos h az optim hatasait mindegyiken megmerjuk. es neha elofordulhat h perf tradeoffokat kell csinalni a kul implkon v hw platformokon

miota ezt az itemet kb 2 evtizede eloszor megirta, a Java sw stack minden componentjenek complexityje megnott, procok, VMk, libek; es megnott a hwk szama is amelyeken Java futni tud. mindezt osszeadva a Java prgk perfje meg kevesbe predictable mint 2001-ben volt, ami azt jelenti h annal szuksegesebb h megmerjuk

summary: na arra torekedjunk h gyors prgokat irjunk - jo prgkat irjunk es a sebesseg majd ebbol kovetkezik. de gondoljunk a perfre a sys design soran, fokent az APIk, wire-level protocolok es persistent data formatok designja soran. ha sys kiepitese befejezodott, merjuk meg a perfjet. ha eleg gyors, akkor OK. ha nem, akkor keressuk meg a problema forrasat profilerrel, es optimizaljuk a sys relevant reszeit. az elso lepes az algok megvizsgalasa: semmilyen low-level optim nem segit ha rossz algokat val. ismeteljuk ezt a processt amig szukseges, minden valt utan megmerve a perfet, amig elegedettek nem leszunk vele