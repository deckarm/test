ITEM 71: AVOID UNNECESSARY USE OF CHECKED EXCEPTIONS

sok Java prgozo nem szereti a checked exckat, de ha helyesen haszn, az javithatja az APIkat es prgkat. return codeokkal es unchecked exckkal ellentetben, forcoljak a prgozokat h kezeljek a problemat, ezaltal reliability++. de checked exck overusolasa APIkban nem szerencses. ha egy metodus checked exckat dob, az invokolo kodnak kezelnie kell oket 1 v tobb catch blockban, v dekl h throwsolja oket es propagalnia oket kifele. mindket modon az API useren van a burden. a burden Java 8-ban nott, mivel a checked exct dobo metodusokat streamekben kzvtl nem lehet haszn (item 45-48)

ez a burden justified lehet, ha az API megfelelo haszn sem preventalhatja az exc conditiont ES az APIt haszn prgozo vegre tud hajtani vmi hasznos actiont az exccel valo szembesuleskor. ha nem teljesul mindket feltetel, akkor unchecked exct kell haszn. tegyuk fel a kerdest magunknak, hogyan fogjak a prgozok kezelni az exct
} catch(TheCheckedException e) { throw new AssertionError(); }
} catch(TheCheckedException e) { e.printStackTrace(); System.exit(1); }
ha ennel jobb kezeles nem lehetseges, akkor unchecked exc kell

a checked exc altal a prgozok szamara okozott burden lenyegesen magasabb ha ez az egyetlen checked exc amit a metodus dob. ha mar van masik is, akkor a metodusnak mar try blockban kell lennie, es ez az exc legfeljebb egy uj catch block hozzaadasat igenyli. ha egy metodus egyetlen checked exct dob, akkor ez az exc az egyetlen ok ami miatt a metodusnak try blockban kell lennie, es amiert nem lehet streamekben kzvtl haszn. ezek miatt erdemes feltennunk a kerdest h vhogy el tudjuk-e kerulni a checked exct

checked exc eliminalasanak legegyszerubb modja ha a kivant result typebol returnolunk egy optionalt (item 55). checked exc dobas helyett pedig a metodus egy empty optionalt returnol. hatrany h a metodus nem tud plusz infot returnolni arrol h miert nem tudja a kivant muveletet elvegezni. az exceknek ezzel ellentetben descriptiv a typejuk, es tudnak metodusokat nyujtani plusz info szolgaltatasahoz (item 70)

checked excbol csinalhatunk unchecked exct, ha ket reszre szedjuk a dobo metodust; az elso egy booleant returnol ami jelzi h dobva lesz-e az exc. az API refaktoralasa a hivo kodreszt igy modositja
try { obj.action(args); } catch(TheCheckedException e) { ...handle exc... }
helyett
if(obj.actionPermitted(args)) { obj.action(args); } else { ...handle exc... }

ez a refaktoralas nem mindig appropriate de ha igen, akkor kellemesebbe teheti az API hasznt. bar az utobbi hivas nem szebb mint az elobbi, a refaktoralt API flexebb. ha a hivo tudja h a hivas sikeres lesz, v tudja h a thread terminalhat ha fail van, akkor a refaktoralas utani hivas lehet egyszeruen obj.action(args);

ha azt gyanitjuk h ez a trivialis hivas lesz a normalis eset, akkor az API refaktoralas valszeg appropriate. az eredmeny API lenyegeben uaz az state-testing metodus API mint item 69, es uazok a caveatok: ha egy objt conc akarunk accessalni ext sync nelkul, v "is subject to externally induced state transitions", akkor a refaktoralas inappropriate, mert az obj stateje megvaltozhat az actionPermitted() es az action() hivasok kozt. ha egy kulon actionPermitted() metodus megduplazna az action() metodus altal vegzett tevekenyseget, akkor a reafktoralas perf okok miatt nem indokolt

summary: ha mersekelten haszn, akkor a checked exck novelhetik a prgk reliabilityjet; ha overusoljuk oket, akkor az API haszn fajdalmas lehet. ha a hivok nem tudnak a failurebol recoverelni, akkor dobjunk unchecked exct. ha a recovery lehetseges, es forcolni akarjuk a hivokat h kezeljek az exc conditionokat, akkor eloszor probaljunk meg optionalt haszn; checked exct pedig csakkor haszn, ha ez nem nyujt eleg infot failure eseten