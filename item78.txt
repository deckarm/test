ITEM 78: SYNCHRONIZE ACCESS TO SHARED MUTABLE DATA

synchronized keyword bizt h egyidoben csak egy thread execelhet egy metodust v blockot. sok prgozo csak ugy gondol a syncre mint a mutual excl egy fajtajara, ami preventalja h egy thread inkonz stateben lasson egy objt mikozben egy masik thread eppen modifolja. eszerint egy obj konz stateben krealodik (item 17) es az ot accessalo metodusok lockoljak. ezek a metodusok observelik a statet, es opcionalisan state transitiont okoznak, ezzel egyik konz statebol a masikba tranformaljak az objt. a sync megfelelo hasznalata garantalja h soha semmilyen metodus nem fogja az objt inkonz stateben latni

ez a meglatas helyes, de csak az egyik fele a tortenetnek. sync nelkul egy thread altal okozott valtozasok nem visiblek mas threadek szamara. sync nem csak azt preventalja h threadek egy objt inkonz stateben lassanak, de bizt h minden thread amely belep egy sync metodusba v blokkba, az latni fogja minden olyan megelozo modif hatasait, amelyeket uaz a lock guardolt

a nyelv spec garantalja h egy var writeja v readje atomic, kiveve ha a var type long v double. maskent ha readelunk egy olyan vart ami nem long v double, akkor garantaltan egy olyan valuet kapunk amelyet oda egy masik thread writeolt be, meg akkor is ha tobb thread conc modifolja a vart sync nelkul

hallhattunk esetleg olyat h perf++ celjabol mellozhetjuk a syncet atomic data read/writenal. ez egy veszelyesen rossz tanacs. bar a nyelv spec garantalja h egy thread nem fog arbitrary valuet latni amikor readel egy fieldet, azt nem garantalja h egy thread altal writeolt value visible lesz egy masik szamara. threadek kozti reliable kommhoz es mutual exclusionhoz szukseges a sync. ez a nyelv spec un. memory model reszebol kov, ami spec h egy thread altal vegrehajtott valtozasok hogyan es mikent lesznek visible masok szamara

shared mutable datahoz valo access syncelesenek mellozese komoly kovetkezmenyekkel jarhat meg akkor is ha a data atomically readable/writable. pl. egyik thread megallitasa egy masikbol. lib nyujtja a Thread.stop() metodust de ez mar jo ideje deprecated mert inherently unsafe, hasznalata data corruptionhoz vezethet. egy thread megallitasanak egy masikbol valo ajanlott modja h az elso thread pollozzon egy boolean fieldet ami initially false, de a masodik thread truera allithatja, ezzel jelezve az elso thread szamara h allitsa meg magat. mivel boolean field read/write atomic, egyes prgozok mellozik a syncet amikor accessaljak a fieldet
public class StopThread {
  private static boolean stopRequested;
  main() throws InterruptedException {
    Thread backgroundThread = new Thread(() -> { int i = 0; while(!stopRequested) i++; });
	backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true;
azt gondolnank h ez a prg kb 1 secig fut, ami utan a main thread truera allitja a stopRequestedet, ezaltal megallitva a background thread loopjat. de elofordulhat h a prg soha nem terminal: a bg thread orokre loopolni fog

a problema h sync nelkul nincs garancia h mikor, ha egyaltalan valaha, fogja a bg thread latni h a main thread megvaltoztatta a stopRequested valuejat. sync nelkul a VM siman atalakithatja ezt a kodot
while(!stopRequested) i++;	
erre
if(!stopRequested) while(true) i++;
ez a transzformacio az un hoisting, es az OpenJDK Server VM pl. pont ezt csinalja. az eredmeny liveness failure: a prg nem halad tovabb. a problema mo egyik modja ha synceljuk az accesst a stopRequested fieldhez
public class StopThread {
  private static boolean stopRequested;
  private static synchronized void requestStop() { stopRequested = true;
  private static synchronized boolean stopRequested() { return stopRequested;
  main() throws InterruptedException { Thread backgroundThread = new Thread(() -> { int i = 0; while(!stopRequested()) i++; });
  backgroundThread.start(); TimeUnit.SECONDS.sleep(1); requestStop();
igy a prg valoban terminal kb 1 sec utan

vegyuk eszre h mind a write metodus (requestStop()) mind a read metodus (stopRequested()) synchronized. NEM eleg csak a write metodust syncelni! a sync csakkor garantalt ha mind a read mind a write metodus synchronized. neha egy-egy prg ami csak a writeokat (v csak a readeket) synceli, ugy tunhet h mukodik egyes gepeken, de ez felrevezeto

a StopThread classban levo synchronized metodusok actionjai sync nelkul is atomicok lennenek. maskent, ezeknek a metodusoknak a syncelese csak a comm hatas miatt van haszn, nem mutual excl celjabol. bar a loop minden egyes iterationjeben valo synceles ktge itt nem magas, van egy alternativa ami kevesbe verbose, es a perfje is valszeg jobb: a fenti elso valtozatban a stopRequested field volatile-kent legyen dekl. bar a a volatile modifier nem csinal mutual exclt, de garantalja, h bmely thread amely readeli a fieldet, a legutobb bewriteolt valuet fogja latni

volatile haszn ovatosnak kell lenni
private static volatile int nextSerialNumber = 0; 
public static int generateSerialNumber() { return nextSerialNumber++;
ennek a metodusnak az lenne a celja h minden invocation egy unique valuet returnoljon (amig el nem erjuk a 2^32 invocationt). a metodus stateje egyetlen atomically accessible fieldbol all, nextSerialNumber, es ennek a fieldnek minden lehetseges valueja legal. ezert nem szukseges sync h megvedjuk az invariantjait. de a metodus ezzel egyutt sem fog megfeleloen muk sync nelkul

a problema h a ++ oper nem atomic. valojaban ket opert hajt vegre a nextSerialNumber fielden: egy thread eloszor readeli a valuet, majd bewriteolja az uj erteket ami a regi ertek plusz egy. de ha egy masik thread pont a ketto kozott readeli a fieldet, akkor o is uazt a valuet fogja latni amit az elso thread, tehat az inkrementalt ertek is uaz lesz mint amire az elso thread inkrementalt, azaz nem lesz unique. ez un safety failure: a prg rossz eredmenyt szamit

fixeles egy modja ha a generateSerialNumber() metodus synchronized. ez bizt h a kulonbozo invocationok nem fognak interleavelni es h minden invocation latni fogja vmennyi megelozo invocation hatasait. igy a nextSerialNumber volatile modifierjere nincs is szukseg. tovabbi biztositaskent hasznalhatunk int helyett longot es dobhatunk exct ha a nextSerialNumber eppen atbillenne

de meg jobb ha item 59 szerint AtomicLongot haszn. java.util.concurrent.atomic package primitiveket nyujt single varok lock-free, threadsafe prgozasahoz. amig a volatile csak a comm hatasat nyujtja a syncelesnek, ez a package atomicityt is nyujt. generateSerialNumber() eseteben pont erre van szuksegunk, es valszeg perfje is jobb mint a sync valtozatnak
private static final AtomicLong nextSerialNum = new AtomicLong();
public static long generateSerialNumber() { return nextSerialNum.getAndIncrement();

a legjobb mod az itt emlitett problemak elkerulesere ha nem sharelunk mutable datat. v shareljunk immut datat (item 17) v egyaltalan ne shareljunk. maskent, confinaljuk be a mutable datat egy single threadbe. ha ezt tesszuk, akkor fontos h docoljuk, h a prg evolvalodasa soran is megmaradjon ez a policy. szinten fontos a hasznalt fwk es libek megfelelo ismerete mert ezek is behozhatnak threadeket

elfogadhato, ha egy thread egy darabig modifol egy data objt, aztan megshareli mas threadekkel, es csak az obj ref shareles muveletet synceli. mas threadek ezek utan readelhetik az objt sync nelkul, addig amig nem lesz ujra modifolva. az ilyen objk az un eff immut objk. ha ilyen obj refeket transferalunk egyik threadbol a masikba, az az un safe publication. obj ref safe publisholasnak tobb modja is van: tarolhatjuk static fieldben a class init reszekent; tarolhatjuk volatile fieldben, final fieldben v olyan fieldben ami normal locking segitsegevel van accessalva; v tehetjuk conc collba (item 81)

summary: ha tobb thread sharel mutable datat, minden threadnek amely readeli v writeolja a datat, syncelnie kell. sync nelkul nincs garancia h egy thread altal vegrehajtott modositasok visible lesznek mas threadek szamara. shared mutable data syncelesenek elmulasztasa eseten liveness es safety failurek lephetnek fel, amelyeket nagyon nehez debuggolni; idoszakosak es timing-dependentek lehetnek es VM-enkent mas lehet a behav. ha csak inter-thread kommra van szuksegunk, mutual exclra nem, akkor a volatile modifier lehet a synceles egy megfelelo formaja, de a haszn trukkos lehet
