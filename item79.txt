ITEM 79: AVOID EXCESSIVE SYNCHRONIZATION

item 78 a nem elegendo mennyisegu sync veszelyeirol beszel. ez az item az ellenkezo problemarol. helyzettol fuggoen az excessive sync perf--, DL, v akar nondeterministic behavot okozhat

elkerulendo a liveness es safety failureket, sose adjuk at a controlt a clientnek egy synchronized metoduson v blockon belul. maskent, egy synchronized region belul ne invokoljunk metodust ami overridolasra van designolva, v egy olyannak amit a client nyujt egy function obj formajaban (item 24). a synchronized regiont tart class szempontjabol ezek un alien metodusok; a class nem tudja h ezek mit fognak csinalni es nincs felette controlja. fuggoen attol h egy alien metodus mit csinal, ha synchronized regionbol hivjuk meg, abbol exc, DL v data corruption is lehet

pl az alabbi class egy observable set wrappert impl. clientek notifokra tudnak subscribolni, amelyek akkor kuldodnek ha a sethez elemet adunk. ez a GOF observer pattern. rovidseg kedveert nincsenek notifok amikor elemeket removolunk a setbol. a class az item 18 ForwardingSet tetejere van impl
public class ObservableSet<E> extends ForwardingSet<E> {
  public ObservableSet(Set<E> set) { super(set);
  private final List<SetObserver<E>> observers = new ArrayList<>();
  public void addObserver(SetObserver<E> observer) { synchronized(observers) { observers.add(observer);
  public boolean removeObserver(SetObserver<E> observer) { synchronized(observers) { return observers.remove(observer);
  private void notifyElementAdded(E element) { synchronized(observers) { for(SetObserver<E> observer : observers) observer.added(this, element);
  @Override public boolean add(E element) { boolean added = super.add(element); if(added) notifyElementAdded(element); return added;
  @Override public boolean addAll(Collection<? extends E> c) { boolean result = false; for(E element:c) result |= add(element); return result;

az observerek az addObserver() metodus invokolasaval subscribolnak a notifokra es removeObserver() invokolasaval unsubscribolnak. mindket esetben az alabbi callbac iface egy instance adodik at a metodusnak
@FunctionalInterface public interface SetObserver<E> { void added(ObservableSet<E> set, E element);
ez az iface strukturalisan hasonlo BiConsumer<ObservableSet<E>,E>-hez. azert haszn custom func ifacet inkabb, mert az iface es a metodus nevek olvashatobba teszik a kodot, es az iface evolvalodhat is h tobb callback legyen benne. ezzel egyutt lehetne BiConsumert is hasz (item 44)

ranezesre az ObservableSet jol muk. pl. az alabbi prg 0-tol 99-ig kiirja a szamokat
main() { ObservableSet<Integer> set = new ObservableSet<>(new HashSet<>()); set.addObserver((s,e) -> sout(e)); for(int i = 0; i < 100; i++) set.add(i);

most csereljuk ki az addObserver hivast egy olyanra ami kiirja a sethez addolt Integer valuet, es removolja magat ha a value 23
set.addObserver(new SetObserver<>() { public void added(ObservableSet<Integer> s, Integer e) { sout(e); if(e == 23) s.removeObserver(this); } });
vegyuk eszre h ez a hivas egy anon classt instanceot haszn az elozo lambdaval szemben. ez azert van mert a func objnak at kell adnia sajat magat a s.removeObserver()-nek, es lamdbak nem tudjak magukat accessalni (item 42)

azt varnank h a prg kiirja a szamokat 0-tol 23-ig, aztan az observer unsubscribeol es a prg csendben terminal. valojaban ami tortenik h kiirja a szamokat, majd ConcurrentModificationExceptiont dob. az a gond h a notifyElementAdded() metodus eppen az observers listan iteral amikor meghivja az observer added() metodusat; ami meghivja az observable set removeObserver() metodusat; ami meghivja az observers.remove() metodust. es ez gond, mert akkor probalunk removolni egy elemet egy listabol mikozben eppen iteralunk rajta, ami illegal. a notifyElementAdded() metodusban levo iteration egy synchronized blockban van, h preventaljuk a conc modifot; de ez nem preventalja h az iteralo thread sajat maga callbackeljen az observable setbe es modifolni probalja az observers listet

most probaljuk meg azt h irunk egy observert ami megprobal unsubscribolni; de nem a removeObserver()-t hivja direktben, hanem egy masik threader ker meg ra, egy executor servicet haszn (item 80)
set.addObserver(new SetObserver<>() {
  public void added(ObservableSet<Integer> s, Integer e) {
    sout(e);
    if(e == 23) { 
      ExecutorService exec = Executors.newSingleThreadExecutor();
	  try { exec.submit(() -> s.removeObserver(this)).get(); } catch(ExecutionException | InterruptedException ex) { throw new AssertionError(ex); } finally { exec.shutdown();
vegyuk eszre h a prg ket kul exc typeot catchel egy clauseban. ez az un multicatch Java 7-ben lett hozzaadva. jelentosen novelheti az olvashatosagot, es csokkentheti az olyan prgok meretet amelyek tobbfele exc typera uugy reagalnak

ha lefuttatjuk a prgt, akkor DL lesz. a bg thread s.removeObserver()-t hiv, ami megprobalja lockolni observers-t, de nem tudja a lockot acqolni, mivel a main thread mar tartja a lockot. ekozben a main thread arra waitel h a bg thread befejezze az observer removolast; ez igy DL

a pelda eroltetett, mert igazabol nincs ok ra h az observer egy bg threadet haszn arra h unsubscribolja magat, de a problema valos. alien metodusok invokolasa synchronized regionokbol szamos DL-t okozott mar real sysekben, pl. GUI toolkitekben

mindket elozo peldaban (ez exc es a DL) szerencsesek voltunk. a synchronized region altal guardolt rsc (observers) konz stateben volt amikor az alien metodus (added()) invokolodott. de mi van ha akkor invokolunk egy alien metodust egy synchronized regionbol amikor a region altal vedett invariant eppen temporarily invalid? mivel a Java lockok reentrantok, az ilyen hivasokbol nem lesz DL. ahogy az elso peldaban, ami exct dobott, a hivo thread mar tartja a lockot, ezert sikerrel fogja reacqolni, pedig egy masik, conceptually unrelated oper eppen csinal vmit a lock altal guardolt dataval. egy ilyen failure kovetkezmenyei katasztrofalisak lehetnek. a lock lenyegeben nem azt csinalta amit vartunk tole. reentrant lockok leegyszerusitik a multithread OO prgk irasat, de uakkor liveness failureket safety failurekbe alakithatnak

szerencsere alt nem nehez az ilyen problemakat fixalni, ugy h kimozgatjuk az alien metodus invokolasokat a synchronized blokkokbol. a notifyElementAdded() metodus eseteben krealjunk egy "snapshotot" az observers listrol, amin aztan safely lehet traversalni, lock nelkul. ezzel a modositassal mindket elozo pelda exc v DL nelkul fut
private void notifyElementAdded(E element) { List<SetObserver<E>> snapshot = null; synchronized(observers) { snapshot = new ArrayList<>(observers); } for(SetObserver<E> observer: snapshot) observer.added(this, element);

van jobb mod is az alien metodus invocationok kimozgatasara a synchronized blockbol. libek nyujtanak egy CopyOnWriteArrayList nevu conc collt (item 81) amit pont erre talaltak ki. ez a List impl az ArrayList egy valtozata, amelyben minden modif oper ugy van impl h egy copyt kreal a teljes underlying arryrol. mivel igy az internal array sosem modifolodik, az iter nem igenyel lockingot es nagyon gyors. legtobb esetben a CopyOnWriteArrayList perfje rossz, de az observer listre kivalo, mivel ritkan van modifolva modif de gyakran traversalva

az ObservableSet add() es addAll() metodusait nem kell valt, ha CopyOnWriteArrayListet haszn. a class tobbi resze igy nez ki. vegyuk eszre h nincs explicit sync
private final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();
public void addObserver(SetObserver<E> observer) { observers.add(observer);
public boolean removeObserver(SetObserver<E> observer) { return observers.remove(observer);
private void notifyElementAdded(E element) { for(SetObserver<E> observer : observers) observer.added(this, element);

synchronized regionon kivul invokolt alien metodus un open call. failurek preventalasa mellett az open callok jelentosen novelhetik conct. alien metodus arbitrarily hosszu ideig futhat. ha az alien metodus synchronized regionbol lenne invokolva, akkor mas threadek szuksegtelenul nem tudnank hferni a guardolt rschez

okolszabaly: vegezzunk olyan keves workot synchronized regionon belul amennyit csak lehet. obtaineljuk a lockot, csekkeljuk a shared datat, vegezzuk el rajta a szukseges muveleteket, es dropoljuk a lockot. ha vmi idoigenyes activityt kell vegeznunk akkor mozgassuk ki vhogy a synchronized regionon kivulre, az item 78 guidelineok violalasa nelkul

eddig a correctnessrol volt szo, most nezzuk meg a perft. bar a sync ktge jelentosen csokkent a korai Java verziokhoz kepest, ma is fontos h ne oversynceljunk. multicore vilagban az excessive sync igazi ktge nem a lockok gettelesere koltott CPU time, hanem a contention: az elvesztett parh lehetosegek, es a delayek amiket az okoz h bizt h minden core konz mem viewt lasson. az oversync masik hidden ktge h limitalhatja a VM lehetosegeit a code exec optimizalasara

ha mutable classt irunk, akkor ket lehetoseg van: mellozhetjuk a syncet es a synceljen a client externally ha conc hasznalatot akar; v syncelhetunk internally, threadsafe teve a classt (item 82). akkor val a masodik lehetoseget ha jelentosen jobb conct tudunk elerni internal sync reven mint ha a client externally lockolna az egesz objt. a java.util colljai (az obsolete Vector es hashtable kivetelevel) az elso approachot haszn, mig a java.util.concurrent colljai a masodikat (item 81)

Java korai idoszakaban szamos class violalta ezeket a guidelineokat. pl. StringBuffer instanceokat gyak mindig csak egyetlen thread haszn, de megis internal syncet haszn. ezert hoztak be a StringBuildert ami egy unsync StringBuffer. hasonloan ez a fo oka h a java.util.Randomban levo threadsafe pseudornd generator helyettesitesere behoztak a java.util.concurrent.ThreadLocalRandom-ban levo unsync implt. ha ketelyeink vannak, akkor ne synceljuk a classunkat hanem docoljuk h nem threadsafe

ha internally sinceljuk a classunkat, akkor tobbfele techn van a magas conc eleresere, pl. lock splitting, lock striping es nonblocking conc control; ld. JCIP

ha egy metodus egy static fieldet modifol es van esely ra h tobb threadbol lesz hivva, akkor internally syncelnunk kell a field accessalasat (hacsak nem a class toleralni tudja a nondeterm behavot). multithreaded client nem tud external syncet vegrehajtani egy ilyen metoduson, mert unrelated clientek sync nelkul invokolhatjak a metodust. a field lenyegeben egy global var, meg ha private is, mert unrelated clientek readelhetik/writeolhatjak. a generateSerailNumber() metodus altal haszn nextSerialNumber field egy jo pelda erre

summary: DL es data corruption elkerules erdekeben sose hivjunk alien metodust synchronized regionbol. altalanosabban, probaljuk a synchronized regionban vegzett workot minimalizalni. ha mutable classt designolunk akkor gondoljuk vegig h szukseg van-e sajat syncet csinalni. a multicore eraban is fontos h ne oversynceljunk. csakkor synceljuk a classunkat internally ha jo ok van ra, es docoljuk le vilagosan (item 82)
