ITEM 80: PREFER EXECUTORS, TASKS, AND STREAMS TO THREADS

a konyv elso kiadasaban egy egyszeru work queue kodja volt. ez lehetove tette h a clientek wokot enqueoljanak, amelyet egy bg thread processalt. ha a work queuera mar nincs szukseg, a client invokolhatott egy metodust ami megkerte a bg threadet h gracefully terminalja magat miutan completelte a mar a queuen levo workot. az impl csak jatek volt, de meg igy is egy teljes oldalnyi kod volt, prone a safety es liveness failurekre. szerencsere mar nincs ok arra h ilyen jellegu kodot irjunk

a konyv masodik kiadasaban mar volt java.util.concurrent. ebben a packageben van az executor fw ami egy flex iface-based task exec facility. ezzel egy olyan work queue megkrealasa, ami minden szempontbol jobb mint az elso kiadasban levo; es csak egyetlen sor kodot igenyel: ExecutorSrevice exec = Executors.newSingleThreadExecutor();
runnable igy submittolhato execre: exec.execute(runnable);
es igy mondhato meg az executornak h gracefully terminaljon (ha ezt nem tesszuk meg akkor lehet h a VM nem fog exitelni): exec.shutdown();

executor service segitsegevel szamos mas dolgot is lehet csinalni. pl. waitelhetunk h egy adott task completeljen (get() metodus, ami item 79-ben is volt); waitelhetunk h egy collnyi task vmelyike v mindegyike completeljen (invokeAny() v invokeAll() metodusok); waitelhetunk az executorservice terminalasara (awaitTermination() metodus); egyenkent retrievelhetjuk taskok resultjait ahogy completelnek (ExecutorCompletionService); schedulalhatunk taskokat h egy adott idopontban v periodikusan fussanak (ScheduledThreadPoolExecutor) stb.

ha azt akarjuk h tobb mint egy thread processaljon requesteket a queuebol, akkor hasznaljunk egy masik static factorty, amely egy masfajta executor servicet, un thread poolt kreal. thread pool krealhato fixed v variable szamu threaddel. java.util.concurrent.Executors class tart static factorykat amelyek nyujtjak a legtobb fele executort amire szuksegunk lehet. ha megis vmi ezektol elterore van szuksegunk akkor haszn a ThreadPoolExecutor classt direktben. ennek segitsegevel egy thread pool mukodesenek szinte minden aspectjet configolni tudjuk

kival egy adott apphoz a megfelelo executor servicet trukos lehet. kis prghoz v kevesse loaded serverhez Executors.newCachedThreadPool() alt jo valasztas mert nem igenyel configot es alt "does the right thing". de cached thread pool nem jo valasztas heavy loaded prod serverhez. cached thread poolban a submitted taskok nem lesznek queuolva, hanem azonnal ki lesznek adva egy threadnek execelesre. ha nincsenek available threadek akkor uj thread krealodik. ha egy server annyira heavily loaded h minden CPUja fully utilized, es tovabbi taskok erkeznek, akkor meg tovabbi threadek krealodnak, amitol a helyzet csak meg rosszabb lesz. ezert egy heavily loaded prod serverben jobb valasztas az Executors.newFixedThreadPool() amely egy fix szamu threadet tart poolt nyujt, v haszn a ThreadPoolExecutor classt direktben a maximalis controlert

ne csak ne irjunk sajat work queukat, hanem altalaban ne haszn threadeket direktben. ha direktben haszn threadeket, akkor egy Thread egyszerre lesz a unit of work es az azt execelo mech. az executor fwben ez a ketto separate. a key abstraction a unit of work, ami a task. ketfele task van: Runnable es Callable (ami lyan mint a Runnable de valuet returnol es arbitrary exckat tud dobni). a task execeles mechja az executor service. ha taskokban gondolkozunk, es hagyjuk h egy executor service execelje oket a szamunkra, akkor megvan a flex h valasszunk egy megfelelo exec policyt az igenyeinknek megfeleloen, es h megvaltoztassuk a policyt has szukseges. lenyegeben az executor fw azt csinalja az executionra, amit a coll fw csinal az aggregationra

Java 7-ben az executor fw ki lett terjesztve h tam a fork-join taskokat, amelyeket egy spec executor service, az un fork-join pool futtat. egy fork-join task, amit egy ForkJoinTask instance repr, splittelheto tobb kisebb subtaskra es a ForkJoinPoolt alkoto threadek nem csupan processaljak ezeket a taskokat, de el is "lophatnak" taskokat egymastol, ezzel bizt h minden thread busy maradjon, amivel CPU util++, throughput++, latency--. fork-join taskok irasa es tunolasa trukkos. parallel streameket (item 48) fork join poolok tetejere irjak, ezaltal kis effortal kihaszn a perf benefitjeiket, felteve h a szoban forgo taskokhoz megfeleloek