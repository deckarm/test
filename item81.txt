ITEM 81: PREFER CONCURRENCY UTILITIES TO WAIT AND NOTIFY

konyv elso kiadasaban volt egy item a wait() es notify() helyes hasznalatarol. az ott irtak ma is valid, es az item vegen ossze lesz foglalva, de ma mar ez sokkal kevesbe fontos mint akkor volt. ma mar sokkal kevesebb ok van wait() es notify() haszn. Java 5 ota a platform higher level conc utilokat nyujt amelyekkel meg tudjuk csinalni azokat a dolgokat amiket korabban kezzel kellett wait() es notify() tetejere impl. wait() es notify() korrekt haszn nehezsegeit tekintve javasolt inkabb ezeknek a utiloknak a haszn

a java.util.concurrent-ben levo utilok 3 kategoriaba sorolhatoak: exec fw (item 80), conc collok es synchronizerek

conc collok a standard coll ifacek (List, Queue, Map) high perf conc impljai. high conc nyujtasahoz ezek az implk internally managelik a sajat syncjuket (item 79). ezert nem lehetseges conc activityt excludolni conc collbol; lockolasa csak lelassitja a prgt

mivel nem tudunk conc activityt conc collbol excludolni, ezert nem tudunk "atomically compose method invocations on them". emiatt conc coll ifaceket state-dependent modify operekkel "outfitteltek", amelyek tobb primitivet kombinalnak ossze egyetlen atomic operbe. ezek az operek eleg hasznosnak bizonyultak ahhoz h Java 8-ban default metodusok reven hozza lettek adva a coll ifacekhez (item 21)

pl. Map putIfAbsent(key,value) metodusa beinsertel egy mappinget egy keyhez ha meg nem volt benn, es returnoli a keyhez tartozo elozo valuet v nullt. igy egyszerubb threadsafe canonicalizing mapeket impl. az alabbi metodus a String.intern() behavjat szimulalja
private static final ConcurrentMap<String, String> map = new ConcurrentHashmap<>();
public static String intern(String s) { String previousValue = map.putIfAbsent(s,s); return previousValue == null ? s : previousValue;

mivel a ConcurrentHashMap a retrieval operekre van opt, ezert erdemes lehet eloszor get()-et hivni es csak ha ez azt jelzi h szukseges, akkor putIfAbsent()-et
public static String intern(String s) { String result = map.get(s); if(result == null) { result = map.putIfAbsent(s,s); if(result == null) result = s; } return result;

amellett h kivalo conct nyujt, a ConcurrentHashMap nagyon gyors. szerzo gepen ez az intern() metodus tobb mint 6x gyorsabb mint String.intern(); bar tartsuk eszben h az utobbinak gondoskodnia kell arrol is h hosszu eletu appokban megakadalyozza a mem leakinget. conc collok nagyjabol obsolette teszik a synchronized collokat. pl. hasznaljunk ConcurrentHashMapet Collections.synchronizedMap() helyett. ha lecsereljuk a sync mapeket conc mapekre, az dramaian meggyorsithatja a conc appok perfjet

egyes coll ifacek ki vannak bovitve blocking operekkel amelyek waitelni (blockolni) tudnak amig sikeresen vegre nem hajthatoak. pl. BlockingQueue extends Queue es szamos metodust ad hozza, pl. take(, amely removolja es returnoli a queue head elemet, es waitel ha a queue empty. ez lehetove teszi h a blocking queuekat work queuekent (P/C queuekent) haszn, amelyekbe egy v tobb P thread work itemeket enqueueol, egy v tobb consumer pedig dequeolja es processalja az available itemeket. a legtobb ExecutorService impl, beleertve ThreadPoolExecutort is, BlockingQueuet haszn (item 80)

a synchronizerek olyan objk amelyek lehetove teszik threadek szamara h waiteljenek egymasra, es koordinaljak az activityiket. leggyakrabban haszn synchronizerek a CountDownLatch es Semaphore. kevesbe gyakran haszn CyclicBarrier es Exchanger. a leginkabb powerful a Phaser

a countdown latchek single-use barrierek, amelyek lehetove teszik h egy v tobb thread waiteljen arra h egy v tobb thread csinaljon vmit. CountDownLatch konstr egy intet vesz at, ami megmondja h hanyszor kell a latch countDown() metodusat invokolni mielott az osszes waiting thread tovabbhaladhat

ennek az egyszeru primitivenek a tetejore meglepoen egyszeruen lehet hasznos dolgokat krealni. pl. tfh egyszeru fwt akarunk krealni egy action conc execjenek timingjere. a fw egyetlen metodusbol all ami atvesz egy executort ami execeli az actiont; egy conc levelt ami repr a conc execelendo actionok szamat; es egy runnablet ami az actiont repr. minden worker thread felkesziti magat az action futtatasara mielott a timer thread elinditja az orat. amikor az utolso worker thread is kesz az action futtatasara, a timer thread "meghuzza a ravaszt", ezzel lehetove teszi a worker threadek szamara az action vegrehajtasat. mihelyt az utolso worker thread befejezte az action vegrehajtasat, a timer thread megallitja az orat. ha ezt a logicot direktben a wait() es a notify() tetejere akarnank impl, az nehez lenne, CountDownLatch tetejere implva viszont meglepoen straightfwd
public static long time(Executor executor, int concurrency, Runnable action) throws InterruptedException {
  CountDownLatch ready = new CountDownLatch(concurrency); CountDownLatch start = new CountDownlatch(1); CountDownLatch done = new CountDownLatch(concurrency);
  for(int i = 0; i < concurrency; i++) {
    executor.execute(() -> { 
	  ready.countDown();  //jelezzuk a timernek h readyk vagyunk
	  try {
	    start.await(); //waitelunk amig a peerek readyk lesznek
		action.run(); } 
	  catch(InterruptedException e) { Thread.currentThread().interrupt(); } 
	  finally { done.countDown(); } } ); //jelezzuk a timernek h done vagyunk
  ready.await(); //varunk amig minden worker ready
  long.startNanos = System.nanoTime();
  start.countDown(); //indulhatnak
  done.await(); //varunk amig minden worker done
  return System.nanoTime() - startNanos();

harom countdown latchet haszn. a ready segitsegevel mondjak meg a worker threadek a timer threadnek h mikor readyk. a worker threadek ezek utan varnak a start latchre. mikor az utolso worker thread is invokolta a ready.countDown()-t, a timer thread invokolja a start.countDown()-t, ezzel lehetove teszi a worker threadek szamara h haladjanak. ezutan a timer thread a done latchre waitel, egesz addig amig az utolso worker thread is befejezi az action futtatasat, es meghivja a done.countDown()-t. ezutan a timer thread felebred es pl. loggolhatja az idot

a time() metodusnak atadott executornak legalabb annyi threadet kell tudni krealnia mint a megadott conc level, v a test sosem er veget. ez az un thread starvation DL. ha egy worker thread InterruptedExceptiont catchel, akkor reassertalja az interruptot es returnol a run() metodusabol. ez lehetove teszi az executor szamara h ugy kezelje az interruptot ahogy akarja. vegyuk eszre h az idobelyegeket a System.nanoTime()-al kerjuk le. intervallum meresre mindig ezt hasznaljuk es ne a System.currentTimeMillis()-t; pontosabb es nincs ra hatassal a sys realtime orajanak adjustolasa. vegul vegyuk eszre h ez a pelda nem fog tul pontos timinget szolgaltatni, hacsak az action nem vegez tobb workot, pl. 1 secnyit v tobbet. pontos microbenchmarking nehez feladat es jobb spec fw segitsegevel csinalni, pl. jmh

ez az item csak a felszint karcolja h mit lehet csinalni conc utilokkal. pl. az elozo peldaban levo 3 countdown latch helyett lehetett volna egy CyclicBarrier v Phaser. a kod igy valszeg tomorebb de nehezebben atlathato lett volna

wait() es notify() helyett mindig conc utilt javasolt haszn, de legacy kodban ezek tovabbra is lehetnek. a wait() metodussal varhat egy thread vmilyen conditionra. olyan sync regionon belul kell invokolni ami lockolja azt az objt amin invokolunk 
synchronized(obj) { 
  while(condition does not hold) obj.wait(); // releaseli a lockot, wakeupkor pedig reacqolja
  //conditionnak megfelelo action vegrehajtasa
mindig loopbol invokoljuk a wait() metodust, sose azon kivul. a loop segitsegevel csekkeljuk a conditiont a waiting elott es utan

waiting elott csekelni a conditiont, es skippelni a waitet ha a condition mar fennall, szukseges a liveness erdekeben. ha a condition mar fennall es a notify() v notifyAll() metodus mar azelott invokolodott, h a thread waitelni kezdett, akkor nincs garancia h a thread valaha is fel fog ebredni a waitbol

waiting utan csekkelni a conditiont, es ujra waitelni ha a condition nem all fenn, szukseges a safety erdekeben. ha a thread tovabbhaladna az actionnel amikor a condition nem all fenn, az destroyolhatna a lock altal guardolt invariantot. szamos oka lehet h egy thread felebred olyankor amikor a condition nem all fenn
- egy masik thread obtainelte a lockot es megvaltoztatta a guarded statet akozott h egy thread notify()-t invokolt es h a waiting thread felebredt
- egy masik thread veletlenul v mailciously notify()-t invokolt amikor a condition nem allt fenn. classok kiteszik magukat ennek a veszelynek ha publicly accessible objkra waitelnek. bmely wait() ami egy publicly accessible metodus synchronized metodusaban van, ki van teve ennek
- a notifying thread tulsagosan "nagylelku" a waiting threadek felebreszteseben. pl. a notifying thread akkor is invokolhat notifyAll()-t ha csak a waitelo threadek egy reszenek all fenn a conditionja
- waiting threadek (ritkan) notify nelkul is felebredhetnek. ez az un spurious wakeup

kapcs issue h notify() v notifyAll() haszn waiting threadek felebresztesere (notify() egy waiting threadet ebreszt fel, felteve h ilyen thread letezik, notifyAll() viszont az osszes waiting threadet). egyesek szerint mindig notifyAll() legyen. ez reasonable, konzervativ tanacs; mindig jo eredmenyt ad mert garantaltan felebreszti azokat a threadeket amelyeket fel kell ebreszteni. ezek mellett felebreszt mas threadeket is, de ez nem bef a prgunk helyesseget. ezek a threadek csekkelik a conditiont amire waitelnek, es mivel falsenak latjak, ezert folytatjak a waitelest

optimkent valaszthatjuk a notify()-t a notifyAll() helyett, ha a wait-setben elofordulhato minden thread uarra a conditionra waitel, es egyidejuleg csak egy thread benefitelhet abbol h a condition trueva valt

notifyAll() haszn masik oka h ez megved az unrelated threadek altali veletlen v malicios waitektol. az ilyen waitek "elnyelhetnek" krit notifot, ezzel azt okozva h az arra waitelok orokre waitelni fognak

summary: wait() es notify() direkt haszn olyan mintha "conc assembly" nyelven prgoznank, osszevethe a java.util.concurrent altal nyujtott magasabb szintu nyelvvel. ritkan van ok arra h uj kodban wait()/notify() haszn. ha olyan kodot maintainelunk ami wait()/notify() haszn akkor bizt h mindig while loopbol invokolja a wait()-et. notifyAll() alt pref notify()-al szemben, ha megis az utobbit haszn akkor figyelni kell a livenessre
