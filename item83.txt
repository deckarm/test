ITEM 83: USE LAZY INITIALIZATION JUDICIOUSLY

lazy init amikor delayeljuk egy field initjet addig amig a valuejara szukseg van. ha sosincs ra szukseg akkor a field sosem lesz initelve. static es instance fieldekre is muk. celja elsosorban optim, de lehet haszn arra h megszuntessunk karos circularityket a class es instance initelesekben

mint a legtobb optimnal, itt is az a tanacs h "don’t do it unless you need to" (item 67). lazy init ketelu kard. csokk egy class init v instance krealas ktget, de cserebe nov a lazily inited field accessalanak ktget. attol fuggoen h a fieldeket vegul milyen aranyban kell initelni, mennyi az init ktge es milyen gyakran lesznek init utan accessalva, a lazy init (csakugy mint sok mas "optim") akar perf-- is lehet

ha egy field a class instanceok csak egy toredekenel van accessalva, es a field initelese ktges, akkor a lazy init megerheti. az egyetlen mod errol megbizonyosodni ha megmerjuk a class perfjet lazy inittel es anelkul

tobb thread eseten a lazy init trukkos. ha ket v tobb thread sharel egy lazy initied fieldet akkor kritikus h legyen vmilyen synceles, v komoly bugok lehetnek (item 78). az ebben az itemben targyalt mindegyik init tech threadsafe

a legtobb esetben a normal init pref a lazy inittel szemben. normal inited instance field (vegyuk eszre h a final modifiert haszn, ld item 17)
private final FieldType field = computeFieldValue();

ha lazy initet haszn init circularity megszuntetesere, akkor haszn synchronizedet, mert az a legegyszerubb, legtisztabb
private FieldType field;
private synchronized FieldType getField() { if(field == null) field = computeFieldValue(); return field;

mindket fenti idiom (normal init es lazy init synchronized accessorral) uigy alkhato static fieldekre is

ha static field perfje miatt van szukseg lazy initre, akkor haszn a lazy init holder class idiomot. ez garantalja h egy class nem lesz initelve amig nincs haszn
private static class FieldHolder { static final FieldType field = computeFieldValue(); }
private static FieldType getField() { return FieldHolder.field;
amikor a getField() eloszor invokolodik, akkor FieldHolder.field elso alkalommal lesz readelve, es ez initeli a FieldHolder classt. az idiom szepsege h a getField() metodus nem synchronized es csak egy field accesst hajt vegre, tehat a lazy initeles lenyegeben semmit nem ad hozza az access ktgehez. egy tip VM csak a class initelesehez synceli meg a field accesst; es ha a class meg van initelve akkor a VM ugy patcheli meg a kodot h a field tovabbi accesselese ne jarjon semmilyen csekkelessel v syncelessel

ha instance field perfje miatt van szukseg lazy initre, akkor haszn a double check idiomot. ez elkeruli a locking ktget ha initelest kovetoen akarjuk accessakni a fieldet (item 79). az otlet h a field valuejat ketszer csekkeljuk (ezert double check): egyszer locking nelkul, es ha a field ugy tunik h meg nincs initelve, akkor lockinggal. csak ha a masodik csekk is azt mutatja h a field meg nincs initelve, akkor initeljuk. mivel a field initelese utan nincs lockolas, ezert kritikus h a field volatilekent legyen dekl (item 78)
private volatile FieldType field;
private FieldType getField() { FieldType result = field; if(result == null) { synchronized(this) { if(field == null) field = result = computeFieldValue(); } } return result;
a local result variable azert kell h a field csak egyszer legyen readelve abban a common esetben ha mar initelve van. ez nem feltetlenul szukseges, de perf++ lehet, es a low-level conc prging standardjei szerint elegansabb is. szerzo gepen 1.4x gyorsabb mint a local var nelkuli verzio

double check idiomot static fieldekre is lehet haszn de nincs ra ok: a lazy initi holder class idiom jobb

a double check idiom ket valtozatat erdemes megemliteni. neha arra van szukseg h lazy initeljunk egy instance fieldet ami toleralja az ismetelt initelest. ebben az esetben haszn a double check idiom egy olyan valtozatat amiben nincs masodik csekkeles; un. single check idiom. a field itt is volatile
private volatile FieldType field;
private FieldType getField() { FieldType result = field; if(result == null) field = result = computeFieldValue(); return result;

az ebben az itemben targyalt init technikak primitiv fieldekre es obj ref fieldekre is muk. ha a double check v single check idiomot numerical primitiv fieldre haszn, akkor a field valuet 0-ra csekkeljuk (numerical primitiv varok default valueja) es nem null-ra

ha nem erdekes h minden thread ujra kiszamolja a field erteket, es a field typeja primitiv (nem long es nem double) akkor donthetunk ugy h eltavolitjuk a single check idiom field dekljabol a volatile modifiert. ez az un racy single check idiom. egyes archokon felgyorsitja a field accesst, aminek ktge plusz initek (fieldet accessalo threadenkent max 1). ez nem mindennapi hasznalatra valo

summary: a legtobb fieldet normal modon kell initelni, nem lazy. ha egy fieldet lazykent kell initelnunk vmi perf cel erdekeben v elkerulendo init circularityt akkor haszn a megfelelo lazy init technt. instance fieldekre ez a double check idiom; static fieldekre a lazy init holder class idiom. instance fieldekre amelyek toleraljak az ismetelt initelest, hasznalhatjuk a single check idiomot is
