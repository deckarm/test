ITEM 84: DON’T DEPEND ON THE THREAD SCHEDULER

amikor szamos thread runnable, a thread scheduler donti el h melyik fog futni es milyen hosszan. bmely normalis OS fair modon hozza meg ezt a dontest, de a policy valtozhat. ezert jol megirt prgoknak nem szabad a policy detailjein depenadalniuk. bmely prg amely correctness/perf szempontbol a thread schedulertol fugg, valszeg nem lesz portable

robusztus, resp, portable prg irasanak legjobb modja ha abizt h a runnable threadek atl szama nem jelentosen nagyobb mint a procok szama. igy a thread schedulernek nem sok valasztasa van: futtatja a runnable threadeket addig amig mar nem runnablek. a prg behavje nem fog nagyon valtozni, meg radikalisan mas thread-scheduling policyk mellett sem. vegyuk eszre h a runnable threadek szama nem uaz mint a threadek total szama, ami lenyegesen tobb is lehet. a waiting threadek nem runnablek

runnable threadek szamanak alacsonyan tartasara fo techn ha minden thread vmi hasznos workot vegez, aztan pedig waitel. threadek ne fussanak, ha nem vegeznek hasznos workot. az executor fwben (item 80) ez azt jelenti h a thread poolokat megfeleloen kell meretezni, a taskok pedig legyen rovidek, de ne tul rovidek, mert kulonben a dispatching overhead miatt perf-- lesz

threadeknek ne busy-waiteljenek, ismetelten csekkelve h egy shared obj stateje mikor fog megvalt. amellett h ez vulnerable teszi a prgt a thread scheduler szeszelyeire, a busy waiting jelentosen noveli a proc loadjat, ezzel csokk a masok altal vegezheto hasznos workot. egy extrem pelda arra h mit ne csinaljunk, egy countdown latch impl
public void await() { while(true) { synchronized(this) { if(count == 0) return; 
szerzo gepen ez kb 10x lassabb mint a CountDownLatch, ha 1000 thread waitel a latchre. ez egy eleg mesterseges pelda, de nem ritkak az olyan sysek ahol 1 v tobb szuksegtelenul runnable thread van. perf es portability szempontbol sem jo

ha olyan prgot latunk, ami alig mukodik mert egyes threadek nem kapnak eleg CPU idot masokhoz kepest, ne akarjuk "megfixalni" Thread.yield() hivasokkal. lehet h mukodesre tudjuk birni, de nem lesz portable. uazok a yield() invocationok amelyek egy JVM impln perf++, egy masikon perf-- lehetnek, egy harmadikon pedig nincs hatasuk. Thread.yield()-nek nincsen tesztelheto semanticsje. jobb ha megprobaljuk atalakitani az appot, es csokk a conc runnable threadek szamat

hasonlo techn amire uez von, a thread priok allitgatasa. a thread priok a Java legkevesbe portable featurejei koze tart. app resp esetleg javithato a thread priok tweakelesevel, de ritkna szukseges, es nem portable. nem jo otlet egy komoly liveness problemat a thread priok modositasaval megprobalni javitani. a problema valszeg vissza fog terni amig az underlying okot nem fixaljuk

summary: ne dependaljunk a thread scheduleren a prg korrektsege erdekeben. a prg igy nem lesz se robosztus se protable. ne hagyatkozzunk Thread.yield()-re v thread priokra. ezek csak hintek a scheduler szamara. thread priok neha hasznalhatoak egy mukodo prg QoS-janak javitasara, de sose haszn arra h "fixaljunk" egy alig muk prgt
