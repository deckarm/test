ITEM 85: PREFER ALTERNATIVES TO JAVA SERIALIZATION

mikor serialization 1997-ben bekerult a Javaba, tudtak h risky. az approachot egy research nyelvben (Modula-3) mar kiprobaltak, de prod nyelvben meg nem. a csekely prgozoi kozremukodessel krealt distr objk igerete csabito volt, de ktg volt a lathatatlan konstrk, az API es az impl kozti elmosodott hatarok, vmint problemak a correctness, perf, secu es maint teren. tamogatok azt hittek h benefitek felulmuljak a ktgeket, de a tortenelem nem ezt bizonyitotta

konyv elozo kiadasaban leirt secu issuek komolynak bizonyultak. 2000-es evek elejen targyalt vulnerabilityk a kov evtizedben komoly exploitokka valtak; pl. hires san franciscoi ransomware tamadas 2016-ban ami 2 nap uzemkiesest eredmenyezett

alapveto problema h a serialization tul nagy tamadasi feluletet nyujt ahhoz h meg lehessen vedeni, es folyamatosan no: az obj grafok deserializationja egy ObjectInputStreamen valo readObject() invokolassal tortenik. ez a metodus lenyegeben egy magic konstr, amellyel a classpathon levo szinte bmilyen typeu obj instantialhato, ha a type impl a Serializable ifacet. egy byte stream deserializationja soran ez a metodus ezen typeok bmelyikebol futtathat kodot, tehat vmennyi erintett type kodja resze a tamadasi feluletnek

a tamadasi feluletbe beletart classok a Java platform libekbol, 3rd party libekbol mint pl. Apache Commons Collections, es magabol az appbol. meg ha betartjuk a relevant best practiceket, es sikerul olyan serializable classokat irnunk amelyek invuln a tamadasokra, az app akkor is vuln lehet
idezet: Java deserialization egy valos veszely, mert szeles korben van direktben haszn appok altal es indirekten olyan Java subsysek altal mint RMI, JMX, JMS. untrusted streamek deserializationja RCE (remote code exec), DoS es egyeb exploitokhoz vezethez. appok vuln lehetnek ezekre a tamadasokra meg ha nem is csinaltak semmi rosszat

researcherek tanulmanyoztak a serializable typeokat a Java libekben es common 3rd party libekben, olyan metodusokat keresve amelyek deserialization soran invokolva potencialisan veszelyes muveleteket hajtanak vegre. az ilyen metodusok az un gadgetek. tobb gadget egyuttes haszn un gadget chain. idorol idore felfedeznek olyan gadget chaineket amelyek kelloen powerfulok ahhoz h lehetove tegye h egy tamado arbitrary native kodot tudjon futtatni az underlying hwn, "given only the opportunity to submit a carefully crafted byte stream for deserialization". pontosan ez tortent az emlitett SF tamadasnal is. es ez nem elszigetelt eset, voltak masok is, es meg lesznek is

gadgetek haszn nelkul konnyen lehet DoS tamadast csinalni, egy rovid stream deserializationjaval, ami hosszu ideig tart. az ilyen streamek az un deserialization bombok
static byte[] bomb() {
  Set<Object> root = new HashSet<>(); Set<Object> s1 = root; Set<Object> s2 = new HashSet<>();
  for(int i = 0; i < 100; i++) {
    Set<Object> t1 = new HashSet<>(); Set<Object> t2 = new HashSet<>(); t1.add("foo"); //igy t1 unequal t2
	s1.add(t1); s1.add(t2); s2.add(t1); s2.add(t2); s1 = t1; s2 = t2; }
  return serialize(root);

az obj graf 201 HashSet instancebol all, amelyek mindegyike 3 v kevesebb obj reft tart. a teljes stream 5744 byte hosszu, de a deserializationja a vilag vegeig tartana. a problema h egy HashSet instance deserializationje megkivanja h az elementjeinek a hashcodejai ki legyenek szamolva. a root hash set 2 elementje maguk is hash setek, amelyek 2 hash set elementet tart, es igy tovabb 100 szint melysegig. ezert a set deserializationja soran a hashCode() metodus 2^100 alkalommal lesz invokolva. azt leszamitva h a deserialization orokke tart "the deserializer has no indication that anything is amiss". keves obj krealodik es a stack depth bounded

hogyan tudunk az ilyen problemak ellen vedekezni? ha untrusted byte stream deserializalunk azzal tamadasai feluletet nyitunk. exploitok elkerulesenek legjobb modja ha soha semmit nem deserializalunk. "the only winning move is not to play". nem indokolt Java serializationt haszn bmilyen ujonnan irt sysben. vannak mas mechk az objk es byte seqk kozti forditasra, amelyekkel a Java serialization veszelyeinek nagy resze elkerulheto, es szamos elonyt nyujtanak, mint cross-platform tam, jo perf, tool ecosys, es szeles expert community. ebben a konyvben ezekre ofogl neven cross-platform structured-data reprkent hiv; mashol serialization syseknek hivjak oket, de itt el akarja kerulni a Java serializationnel valo osszekevereset 

ezekben a reprkban kozos h sokkal egyszerubben mint a Java serialization. nem tam arbitrary obj grafok autom serializationjet es deserializationjat. helyette egyszeru, strukturalt data objkt tam, amelyek attr-value parokbol allnak. csak nehany primitiv es array data typeot tam. ez az egyszeru abstraction elegendo extrem powerful distr sysek felepitesehez es a Java serializationt jell komoly problemak elkerulesehez

a vezeto cross-platform structured-data reprk a JSON es a Protocol Buffers (protobuf). JSONt browser-server kommra designoltak, protobufot pedig serverek kozti structured data storeolasra/interchangera. bar ezeket a reprkat gyakran language-neutralnak mondjak, a JSONt eredetileg JSre fejlesztettek, protobufot pedig C++ra; mindket reprban maradtak is nyomai ennek

a legnagyobb kul JSON es protobuf kozt h a JSON text-based es emberek szamara olvashato, mig protobuf binary es lenyegesen hatekonyabb; JSON kizarolag data repr, protobuf viszont schemakat (typeokat) nyujt "to document and enforce appropriate usage". bar protobuf hatekonyabb mint JSON, JSON extrem hatekony text-based repr celjara. es bar protobuf binary repr, nyujt egy alternativ text reprt is olyan hasznra ahol az emberi olvashatosag szukseges (pbtxt)

ha nem tudjuk teljesen elkerulni a Java serializationt, pl. mert vmi legacy sysben dolgozunk, akkor a masodik legjobb alternativa ha sosem deserializalunk untrusted datat. kulonosen sosem szabad acceptalnunk RMI trafficot untrusted forrasbol. Java hivatalos secu coding guidelineja szerint: "Deserialization of untrusted data is inherently dangerous and should be avoided"; ez az egyetlen mondat ami nagy, vastag, dolt piros betukkel van szedve

ha nem tudjuk elkerulni a serializationt es nem vagyunk teljesen biztosak a deserializalt data safetyjet illeten, akkor haszn az obj deserialization filteringet ami Java 9 ota van es backportoltak a korabbi releasekbe is (java.io.ObjectInputFilter). ezzel a facilityvel specelhetunk egy filtert ami deserialization elott vegrehajtodik a data streameken. class granularity szinten muk, classok acceptalasat es rejectalasat teszi lehetove. defaultbol acceptalva az osszes classt es rejectalva potencialisan veszelyes classok egy listajat un blacklisting; defaultbol rejectalva az osszes classt es acceptalva safenek feltetelezett classok egy listajat un whitelisting. whitelisting a preferalt, mivel a blacklisting csak az ismert threatek ellen ved. Serial Whitelist Application Trainer (SWAT) nevu toollal tudunk az appunkhoz autom whitelistet preparalni. filtering facility szinten ved az excessive mem haszn es excessive mely obj grafok ellen, de nem ved a serialization bombok ellen mint a fenti peldaban

sajnos a serialization tovabbra is erosen jelen van a Java ecosysben. ha olyan syst maintainelunk ami Java serializationon alapul, akkor fontoljuk meg h migraljunk egy cross-platform structured-data reprra, meg ha ez idobe is kerul. az ma is elofordulhat h serializable classt kell irnunk v maintainelnunk.helyes, safe es hatekony serializable classt nehez irni. fejezetben levo tovabbi itemek ehhez nyujtanak tamacsokat

summary: serialization veszelyes es elkerulendo. ha scratchbol designolunk syst, akkor haszn cross-platform structured-data reprt mint JSON v protobuf. ne deserializaljunk untrusted datat. ha meg kell tennunk, akkor haszn obj deserialization filteringet, de tudjunk rola h ez nem garantal vedelmet minden tamadas ellen. keruljuk a serializable classok irasat. ha megis meg kell tennunk, legyunk nagyon ovatosak