ITEM 86: IMPLEMENT SERIALIZABLE WITH GREAT CAUTION

egy class instanceait serializalhatova tenni mindossze az implements Serializable hozzaadasat igenyli a deklhoz. mivel ezt konnyen oda lehet irni, common felreertes volt h a serialization nem igenyel effortot a prgozo reszerol. az igazsag ennel sokkal komplexebb. mig a class serializableve tetelenek azonnali ktge elhanyagolhato, a hosszu tavu ktgek gyakran jelentosek

Serializable impl jelentos ktge h csokk a class impl valtoztathatosagat miutan releaselve lett. ha egy class impl Serializable, a byte-stream encodingja (serialized form) reszeve valik az exported APIjanak. ha a class szeles korben distr, akkor serialized formot orokke supportolnunk kell, ugy ahogy az exported API mas reszeit. ha nem designolunk egy custom serialized formot hanem elfogadjuk a defaultot, akkor a serialized form orokkre hozza lesz kotve a class orig internal reprjahoz. maskent, ha elfogadjuk a default serialized formot akkor a class private es package private fieldjei reszei lesznek az exported APIjanak es a field access minimalizalasi practice (item 15) elveszti a hatekonysagat mint info hiding tool

ha elfogadjuk a default serialized formot es kesobb megvalt a class internal reprjat, akkor a serialized formban egy inkompat valt lesz. clientek amelyek a class regi verziojaval probalnak serializalni egy instanceot es az uj verzioval probaljak deserializalni (vagy forditva) prg failurekbe fognak futni. lehetseges megvalt az internal reprt es megorizni az orig serialized formot (ObjectOutputStream.putFields() es ObjectInputStream.readFields() segitsegevel) de ez nehez lehet es lathato csomokat (wart) hagy a src kodban. ha ugy dontunk h serializableve teszunk egy classt, akkor egy high-qual serialized formot kell designolnunk, ami hosszu tavra szol (item 87, item 90). igy lesz egy initial dev ktg, de megeri az effortot. meg egy jol designolt serialized form is constrainteket rak egy class evolutionjara; egy rosszul designolt serialized form viszont benito lehet

egy egyszeru pelda a serializability altal az evolutionra rakott constraintekre a stream unique identifierekkel, mas neven serial version UIDkel kapcs. minden serializable classhoz kapcs egy unique id nr. ha nem speceljuk ezt a szamot deklva egy serialVersionUID nevu static final long fieldet, akkor a sys autom generalja runtimeban, egy crypto hash funct (SHA-1) applyolva a class structra. ezt a valuet affectalja a class neve, az impl iface neve, es a legtobb member neve, beleertve a compiler altal gen synthetic membereket is. ha ezek bmelyiket megvalt, pl. egy convenience metodus hozzaadasaval, akkor a generalt serial UID megvalt. ha nem dekl serial version UIDt, akkor a kompat eltorik, es runtime InvalidClassException lesz

Serializable impl masik ktge h noveli a bugok es secu holeok vget (item 85). normal esetben az objk konstrkal krealodnak; a serialization egy extralinguistic mech az obj krealasra. akar elfogadjuk a default behavot, akar overridoljuk, a deserialization egy "hidden konstr" uazokkal az issuekkal mint a tobbi konstrnal. mivel a deserializationhoz nem kapcs expl konstr, konnyu elfelejteni h bizt kell h garantalja a konstrk altal nyujtott invarokat es h nem szabad engedje h egy tamado accesst nyerjen a krealas alatt levo obj internaljaihoz. ha a default deserialization mechre relyolunk az konnyen invar corruptionhoz es illegal accesshez vezethet (item 88)

Serializable impl harmadik ktge h noveli a class egy ujabb verziojanak releaselesehez tart testing burdent. ha egy serializable classt revisolunk, akkor fontos csekkelni h lehetseges-e serializalni egy instanceat az uj releaseben es deserializalni a regi releaseben, es forditva. a testing ktge ezert aranyos a serializable classok es a releasek szamaval, ami nagy is lehet. bizt kell h a serialization-deserialization process sikeres lesz, es az orig obj pontos masolatat eredmenyezi. a testing ktge csokken ha a custom serialized formot jol megdesignoljuk amikor eloszor megirjuk a classt (item 87, item 90)

Serializable impl dontest komolyan kell venni. alapveto ha a classnak reszt kell vennie egy olyan fwben ami Java serializationon relyol obj transmission v pers szempontbol. szinten jelentosen megkonnyiti egy class felhasznt componentkent egy masik classban ami impl Serializablet. de a Serializable implnak szamos ktge van. mindig ha classt designolunk, merlegeljuk a ktgeket es benefiteket. tortenelmileg a value classok mint BigInteger v Instant impltak Serializablet, csakugy mint a coll classok. active entityket repr classoknak, mint thread poolok, ritkan kell Serializablet impl

inheritancere designolt classoknak (item 19) ritkan kell impl Serializablet, ifaceknek pedig ritkan kell extendalniuk. ha violaljuk ezt a szabalyt, azzal jelentos burdent rakunk mindenkire aki extendalja a classt v implja az ifacet. vannk esetek amikor lehet violalni a szabalyt. pl. ha egy class v iface elsosorban azert letezik h reszt vegyen a fwben amely minden resztvevojetol megkivanja h impl Serializablet, akkor van ertelme h a class v iface implja v extendalja a Serializablet

a Serializablet impl, inheritancere designolt classok kozt van a Throwable es Component. Throwable impl Serializablet h az RMI tudja kuldeni az exckat serverrol clientnek. Component impl Serializablet h GUIk sendelhetoek, savelhetoek es restorolhatoak legyenek, de ezt a facilityt meg az AWT es Swing fenykoraban se nagyon hasznaltak

ha egy olyan classt keszitunk aminek vannak instance fieldjei es serializable es extendable is, akkor szamos risk van. ha az instance field valuekra vannak invarok, akkor krit h preventaljuk h a subclassok overridoljak a finalize() metodust, ami megoldhato ha overridoljuk a finalize()-t es finalkent dekl. egyebkent a class finalizer tamadasoknak lesz kiteve (item 8). vegul, ha a classnak vannak invarjai amelyek violalodnak ha az instance fieldek a default valueikra vannak initelve (0 az integral typeokra, false booleanra, null az obj ref typeokra) akkor hozza kell adnunk az alabbi readObjectNoData() metodust
private void readObjectNoData() throws InvalidObjectException { throw new InvalidObjectException("stream data required");
ezt a metodust Java 4-ben hoztak be, h lefedjenek egy corner caset ami egy serializable superclassnak egy existing serializable classhoz valo hozzaadasara vonatkozott

ha ugy dontunk h nem impl Serializablet, akkor caveat. ha egy inheritancere designolt class nem serializable, akkor extra effortot igenyelhet ha serializable subclasst akarunk irni. egy ilyen class normal deserializalasa azt igenyli h a superclassnak legyen egy accessible param nelkuli konstrja. ha nem nyujtunk ilyen konstr akkor a subclassoknak a serialization proxy patternt kell haszn (item 90)

inner classok (item 24) ne impljak Serializablet. ezek compiler altal generalt synthetic fieldeket haszn h reft taroljanak az enclosing instanceokra es az enclosing scopeokban levo local varok tarolasara. hogy ezek a fieldek hogyan correspondalnak a class defhez az unspecified, akarcsak az anonymous es local classok nevei. ezert egy inner class default serialized formja ill-defined. static member class viszont implhatja Serializablet

summary: Serializable implementalhatosaganak egyszerusege megteveszto. hacsak a classt nem egy vedett envben haszn ahol a versionoknak sosem kell interoperalniuk es a serverek sosem lesznek untrusted datanak exposolva, a Serializable implementalasa komoly commitment amit ovatosan kell vegrehajtani. kulon ovatossag szukseges ha egy class inheritalhato
