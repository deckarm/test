ITEM 87: CONSIDER USING A CUSTOM SERIALIZED FORM

ha idonyomas alatt irunk egy classt akkor alt celszeru az effortot a legjobb API megdesignolasara osszpontositani. ez neha egy "eldobhato" impl releaseleset jelenti, amirol tudjuk h kesobbi implkban ki fogjuk cserelni. normal esetben ez nem problema, de ha a class impl Serializablet es a default serialized formot haszn, akkor sosem fogunk tudni teljesen mgszabadulni az eldobhato impltol. az fogja diktalni a serialized formot orokre. ez nem csak elmeleti problema, szamos Java lib classal megtortent, pl. BigInteger

ne fogadjuk el a default serialized format mielott atgondolnank h megfelelo-e. a default serialized form elfogadasanak egy tudatos dontesnek kell lennie, h ez az encoding megfelelo-e flex, perf es correctness szempontbol. alt mondva, a default serialized formot csakkor fogadjuk el, ha nagyban identical ahhoz az encodinghoz amit akkor valasztanank ha custom serialized formot designolnank

egy obj default serialized formja az objbol rootolodo obj graf fiz reprjanak egy reasonably hatekony encodingja. maskent, leirja a datat amit az obj es a belole elerheto osszes obj tart. leirja tovabba a topologyt ami szerint ezek az obj interlinkedek. egy obj idealis serialized formaja csak az obj altal repr logical datat tart. fgtl a fiz reprtol

default serialized form akkor appropriate ha az obj fiz reprja identical a logical contentjevel. pl. az alabbi classra
public class Name implements Serializable { private final String firstName, middleName, lastName
logikailag a nev harom stringbol all, amelyek a first, middle, last neveket repr. a Name instance fieldjei pontosan ezt a logical contentet tukrozik

ha ugy dontunk h a default serialized form approriate, akkor gyakran nyujtanunk kell egy readObject() metodust az invarok es secu bizt miatt. Name eseteben a readObject() metodusnak azt kell bizt h a lastName es firstName fieldek non-nullok. reszletesen ld. item 88, item 90

vegyuk eszre h a firstName, middleName, lastName fieldekhez van doc comment bar privateok (en nem irtam ki oket). ez azert van mert ezek a private fieldek egy public APIt def, ami a class serialized formja, es ezt a public APIt docolni kell. @serial tagek jelzik a Javadocnak h ezt a docot egy kulon pagere rakja, ami a serialized formokat docolja

a Namehez kepest a spektrum masik vegen van az alabbi class, ami stringek listajat repr (csak pelda, egyebkent standard List implkat kellene haszn)
public final class StringList implements Serializable {
  private int size = 0; private Entry head = null;
  private static class Entry implements Serializable { String data; Entry next; Entry previous;
logikailag ez a class stringek seqjet repr. fizikailag doubly linked listkent repr a seqt. ha elfogadjuk a default serialized formot, az husegesen le fog tukrozni minden entryt a linked listben, es az entryk kozti osszes linket, mindket iranyban

default serialized formot haszn amikor egy obj fiz reprja lenyegesen kul a logical data contenttol, negy hatrany
- permanensen hozzakoti az exported APIt a jelenlegi internal reprhoz. a fenti peldaban a private StringList.Entry a public API resze lesz. ha a repr megvalt egy jovobeli releaseben, a StringList classnak tovabbra is el kell fogadnia a linked list reprt inputkent, es generalnia outputkent. a class sosem fog megszabadulni a linked list entryket kezelo kodtol, meg ha mar nem is haszn azt
- excessive space haszn lehet. a fenti peldaban a serialized form szuksegtelenul repr a linked listben levo osszes entryt es az osszes linket. ezek az entryk es linkek csupan impl detailek, es nem kellene benne lenniuk a serialized formban. mivel a serialized form nagyon nagy, ezert diskre irni v nwn atkuldeni nagyon lassu
- excessive time consume lehet: serialization logicnak nincsenek ismeretei az obj graf topologiajarol, ezert egy ktges graf traverzalast kell csinalnia. fenti peldaban eleg lenne egyszeruen a next refeket kovetni
- stack overflowkat okozhat: a default serialization eljaras rekurzivan traverzal az obj grafon, ami meg mersekelt meretu obj grafoknal is SOt okozhat. szerzo gepen egy 1000-1800 elementet tart StringList instance StackOverflowErrort general. meglepo modon, a min list size amelyre a serialization SOt okoz, futtatasonkent valt. a min list size amire elojon a problema, fugghet a platform impltol es command-line flagektol; egyes implknal lehet h ez nem is problema

StringList egy reasonable serialized formja a listben levo stringek szama, majd pedig maguk a stringek. ez alkotja a StringList altal repr logical datat, de nincsenek benne a fiz repr detailjei. alabb a StringList ennek megfelelo valtozata, writeObject()/readObject() metodusokkal egyutt. emlekeztetoul, transient modifier azt jelzi h egy instance field omittalodik a class default serialized formjabol
public final class StringList implements Serializable {
  private transient int size = 0; private transient Entry head = null;
  private static class Entry { String data; Entry next; Entry previous; }
  public final void add(String s) { //hozzaadja a megadott stringet a listhez
  private void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); s.writeInt(size); for(Entry e = head; e != null; e = e.next) s.writeObject(e.data);
  private void readObject(ObjectInputStream s) throws IOException , ClassNotFoundException { s.defaultReadObject(); int numElements = s.readInt(); for(int i = 0; i < numElements; i++) add((String) s.readObject());

writeObject() legeloszor meghivja defaultWriteObject()-et, readObject() pedig legeloszor meghivja defaultReadObject()-et, bar a StringList osszes mezoje transient. halhattunk olyat h ha egy class minden instance fieldje transient, akkor nem kell a default- metodusokat meghivni, de a serialization spec szerint ekkor is kell. ha ezek a hivasok ott vannak, az lehetove teszi h kesobbi releasekben nontransient fieldeket adjunk hozza, mikozben megmarad a bwd es fwd kompat. ha egy instancet egy kesobbi versionnal serializalunk es egy korabbi versionnal deserializalunk, akkor a hozzaadott fieldek ignoralva lesznek. ha a korabbi version readObject() metodusa nem invokolta volna a defaultReadObject()-et, akkor a deserialization StreamCorruptedExceptiont dobna

vegyuk eszre h a writeObject() metoduson van doc comment (nem irtam ki) bar private. ez analog eset mint a Name class private fieldjein levo doc commentek. ez a private metodus egy public APIt def, ami a serialized form, es a public APIt docolni kell. mint a fieldeknel a @serial tag, metodusoknal a @serialData tag jelzi a Javadoc utilnak h ezt a docot tegye a serialized forms pagere

h osszevessuk a korabbi perffel, ha az atlagos string hossz 10 char, akkor a StringList ezen valtozatanak serialized formja kb fele annyi spacet foglal mint az orig valtozat serialized formja. szerzo gepen az uj StringList version serializalasa tobb mint 2x gyorsabb mint az orig version serializalasa, 10 hosszu listanal. vegul, az uj valtozatnak nincs SO problema, es igy gyak nincs felso limit a StringList sizera ami meg serializalhato 

default serialized form rossz lenne a StringListhez, de vannak classok amelyekhez meg rosszabb. StringListnel a default serialized form inflex es rossz perf, de correct abban az ertelemben h egy StringList serializalasa es deserializalasa az orig obj egy pontos copyjat eredmenyezi, megtartott invarokkal. nincs ez igy viszont olyan clqassoknal amelyek invarjai impl-spec detailekhez vannak kotve

pl. hashtable. fiz repr hash bucketek seqje, amelyek key-value entryket tart. a bucket amelybe egy entry tart, a keye hashcodejanak egy functionja, amely alt nem garantalt h minden implban uaz lesz. meg az sem garantalt h futasonkent uaz lesz. ezert hashtablere elfogadni a default serialized formot sulyos bughoz vezethet. hashtable serializalasa es deserializalasa egy olyan objt eredmenyezhet amelynek invarjai komolyan corruptedek

akar elfogadjuk a default serialized formot akar nem, minden instance field, amely nem transient, serializalva lesz amikor a defaultWriteObject() invokolodik. ezert minden instance fieldet, amit transientte lehet tenni, tegyunk azza. ide tart a derived fieldek, amelyek valueja a primary data fieldekbol szamithato, pl. cached hash value. ide tart azok a fieldek is, amelyek valuejai a JVM egy biz futasahoz tart, pl. egy long field ami egy native data structra mutato pointert repr. mielott ugy dontunk h nontransientte teszunk egy fieldet, gyozodjunk meg rola h a valueja az obj logical statejenek resze. ha custom serialized formot haszn, akkor a legtobb v az osszes fieldet transientte kell tennunk, mint a fenti StringList peldaban

ha a default serialized formot haszn es egy v tobb fieldet transientte tettunk, akkor emlekezzunk ra h ezek a fieldek a default valuejukra lesznek initelve amikor az instance deserializalva lesz; ref fieldekre null, numeric primitive fieldekre 0, boolean fieldekre false. ha ezek a valuek bmely transient fieldre nem elfogadhatoak, akkor nyujtanunk kell egy readObject() metodust amely invokolja a defaultReadObject() metodust, aztan pedig restorolja a transient fieldeket elfogadhato valuekra (item 88). alternativakent, ezek a fieldek initelhetok lazily, elso alkalommal amikor haszn oket (item 83)

akar haszn a default serialized formot, akar nem, obj serializationra uazt a syncet kell alk, amelyet bmely mas metodusok is alkalmaznank, ami az obj teljes statejet readeli. tehat pl. ha van egy threadsafe objunk (item 82) amely a threadsafetyjet ugy eri el h synceli minden metodusat, es ugy dontunk h a default serialized formot haszn, akkor az alabbi writeObject() metodust kell haszn
private synchronized void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject();
ha syncet rakunk a writeObject() metodusba akkor bizt kell h uazokat a lock-ordering constrainteket koveti mint a tobbi activity, kulonben rsc-ordering DL risk

fgtl h milyen serialized formot valasztunk, dekl egy expl serial version UIDt minden serializable classba amit irunk. ez eliminalja a serial version UIDt mint potencialis inkompat forrast (item 86). emellett kis perf benefit. ha nem nyujtunk serial version UIDt akkor egy ktges szamitas fut le runtime a generalasara

serial version UID dekl egyszeru
private static final long serialVersionUID = randomLongValue;
ha uj classt irunk akkor nem szamit h milyen valuet val randomLongValuekent. generalhatjuk a valuet ugy h lefuttatjuk a serialver utilt a classon, de akar hasbol is mondhatunk egy szamot. nem elvaras h a serial version UID unique legyen. ha modifolunk egy olyan existing classt amelyben nincs serial version UID, es azt akarjuk h az uj version elfogadja az existing serialized instanceokat, akkor azt a valuet kell haszn, ami autom generalodott a regi versionhoz. ezt meg tudjuk nezni ha lefuttatjuk a serialver utilt a class regi versionjan, amelyhez leteznek serialized instanceok

ha olyan uj versiont akarunk csinalni egy classbol ami inkompat az existing versionokkal, akkor csak valt meg a valuet a serial version UID deklban. ennek hatasara a korabbi versionokkel serialized instanceok deserializalasi kiserletei InvalidClassExceptiont fognak dobni. ne valt meg a serial version UIDt, hacsak nem akarjuk eltorni a kompatot a class vmennyi existing serialized instanceaval

summary: ha ugy dontunk h egy class serializable legyen (item 86) akkor alaposan gondoljuk meg h mi legyen a serialized form. hasz a default serialized formot csakkor ha az az obj logical statejenek egy reasonable leirasa; egyebkent designoljunk egy custom serialized formot amely megfeleloen leirja az objt. uannyi idot allokaljunk egy class serialized formjanak megdesignolasara mint egy exported metodus megdesignolasara (item 51). ahogy az exported metodusokat nem tudjuk eliminalni a jovobeli versionokbol, ugy a serialized formbol sem tudjuk eliminalni a fieldeket; orokre meg kell orizni oket a serialization kompat bizthoz. nem megfelelo serialized form valasztasanak permanent, negativ hatasa lehet a class complexityjere es perfjara

