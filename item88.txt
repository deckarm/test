ITEM 88: WRITE READOBJECT METHODS DEFENSIVELY

item 50 pelda immut date-range Period class mutable private Data fieldekkel. a class az invarjai es az immut megtartasat a Date objk def copyzasaval oldja meg a konstrban es accessorokban

tfh azt akarjuk h ez a class legyen Serializable. mivel egy Period obj fiz reprja pontosan tukrozi a logical data contentjet, indokolt lehetne a default serialized form haszn (item 87). ezert ugy tunik mintha eleg lenne hozzaadni az implements Serializablet a class deklhoz. de ha igy tennenk akkor a class a tovabbiakban nem garantalna a krit invarjait

a problema h a readObject() metodus gyak egy uj public konstr, es uazt az ovatossagot igenyli mint bmely mas konstr. ahogy egy konstrnak validity csekkelnie kell az argjait (item 49) es def copykat kell krealnia a paramjairol ha szukseges (item 50) uugy a readObject() metodusnak is. ha nem teszi meg akkor egy tamado szamara viszonylag egyszeru dolog violalni egy class invarjait

lazan fogalmazva a readObject() egy konstr amelynek egyetlen paramja egy byte stream. normal haszn esetebn a byte stream egy normal instance serializalasa soran generalodott. problema akkor van ha a readObject() egy olyan byte streamet kap, amit mestersegesen konstrualtak h egy olyan obj generalodjon ami violalja a class invarjait. ilyen byte streammel lehet un impossible objt krealni, amit normal konstral nem lehetne

tfh egyszeruen hozzaadjuk implements Serializablet a Period class deklhoz. az alabbi prg egy olyan Period instanceot general amelynek az endje megelozi a startjat (a serializedFormban vannak castolasok az olyan byte valueokon amelyeknek a high-order bitje set, mert a Javaban nincsenek byte literalok, a byte type pedig signed)
public class BogusPeriod {
  private static final byte[] serializedForm = { ... } //olyan byte stream, amely nem johet valodi Period instancebol
  main() { Period p = (Period) deserialize(serializedForm); sout(p);
  static Object deserialize(byte[] sf) try { return new ObjectInputStream(new ByteArrayInputStream(sf)).readObject(); } catch(IOException | ClassNotFoundException e) { throw new IllegalArgumentException(e);  //returnoli az objt aminek ez a serialized formja

a serializedForm byte array literal ugy keszult h serializaltak egy normal Period instanceot es aztan kezzel editaltam a byte streamet. a stream reszletei a pelda szempontjabol nem lenyegesek, de a  Java Object Serialization Specification leirja a serialization byte-stream formatot. ha lefuttatjuk a prgt, akkor a kiiras "Fri Jan 01 12:00:00 PST 1999 - Sun Jan 01 12:00:00 PST 1984" lesz. azzal h a Periodot egyszeruen serializablekent dekltuk, krealni tudtunk olyan objt ami violalja a class invarokat

problema fixalasahoz nyujtsunk egy readObject() metodust ami meghivja a defaulReadObject()-et es aztan csekkeli a deserialized obj validityjet. ha a validity csekk failel, a readObject() metodus InvalidObjectExceptiont dob, es preventalja h a deserialization befejezodjon
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); if(start.compareTo(end) > 0) throw new InvalidObjectException("start after end");

ez preventalja h egy tamado invalid Period instanceot krealjon, de van egy masik problema ami meg mindig fennall. lehet krealni egy olyan mut Period instanceot, h gyartunk egy byte streamet ami egy valid Period instanceszal kezdodik es aztan extra refeket appendal a private Date fieldekre. a tamado kiolvassa a Period instanceot az ObjectInputStreambol, aztan pedig kiolvassa a "csalo" obj refeket amik a streamhez lettek appendalva. ezek a refek accesst nyujtanak a tamadonak a private Date fieldek altal refelt objkhoz. ezen Date instanceok mutalasa reven a tamado mutalni tudja a Period instanceot
public class MutablePeriod {
  public final Period period; public final Date start, end;
  public MutablePeriod() {
    try { 
	  ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos);
	  out.writeObject(new Period(new Date(), new Date()))); //valid Period instance serializalasa
	  byte[] ref = { //4 byte }; bos.write(ref); ref[4] = 4; bos.write(ref); //"csalo" previous obj refek appendalasa az internal Date fieldekre
	  ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));
	  period = (Period) in.readObject(); start = (Date) in.readObject(); end = (Date) in.readObject(); //Period es a "stolen" Date refek deserializalasa
	} catch(IOException | ClassNotFoundException e) { throw new AssertionError(e);

a tamadas
MutablePeriod mp = new MutablePeriod(); Period p = mp.period; Date pEnd = mp.end;
pEnd.setYear(78); sout(p); //ora visszallitasa
pEnd.setYear(69); sout(p);

szerzo gepen a kimenet
Wed Nov 22 00:21:29 PST 2017 - Wed Nov 22 00:21:29 PST 1978
Wed Nov 22 00:21:29 PST 2017 - Sat Nov 22 00:21:29 PST 1969  

bar a Period instance erintetlen invarokkal krealodott, de az internaljai tetszes szerint modosithatoak. egy mut Period instance birtokaban egy tamado jelentos kart tud okozni ha atadja ezt az instanceot egy olyan classnak ami secu szempontbol a Period immuton dependal. ez nem is valosagtol tavoli pelda: vannak classok amik secu szempontbol String immuton dependalnak

a problema forrasa h a Period readObject() metodusa nem csinal eleg def copyzast. amikor egy obj deserializalodik, krit def copyzni bmely olyan obj refet amit client nem birtokolhat. ezert minden serializable immut classnak, amelyben private mut componentek vannak, def copyznia kell ezeket a componenteket a readObject() metodusaban. az alabbi readObject() metodus megfelelo a Period invarok biztra es az immut megtartasara
private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); start = new Date(start.getTime()); end = new Date(end.getTime()); if(start.compareTo(end) > 0) throw new InvalidObjectException("start after end");

vegyuk eszre h a def copy a validity csekk elott tortenik es nem haszn a Date clone() metodusat a def copyzashoz. ezek azert vannak h vedjuk a Periodot a tamadasoktol (item 50). vegyuk eszre h def copyzas nem lehetseges final fieldekre. readObject() metodus hasznhoz a start es end fieldeket nonfinalla kell tennunk. ez nem szerencses, de a kisebbik rossz. ezzel a readObject() metodussal es a start,end mezok nonfinalla tetelevel a MutablePeriod class immar hatastalan. a fenti tamado prg kimenete
Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017
Wed Nov 22 00:23:41 PST 2017 - Wed Nov 22 00:23:41 PST 2017

lakmusz teszt annak eldontesere h a default readObject() metodus elfogadhato-e a classhoz: nyugodtan csinalnank olyan konstr ami paramkent atveszi vmennyi nontransient field valuejat es validation nelkul eltarolna ezeket a valuekat a fieldekbe? ha nem, akkor nyujtanunk kell egy readObject() metodust, es annak vegre kell hajtania minden validity csekkelest es def copyzast amit a konstrol elvarunk. alternativakent haszn serialization proy patternt (item 90). ez egy erosen ajanlott pattern, mivel a safe deserializationra forditott effort nagy reszet kiveszi

egy hasonlosag a readObject() metodusok es a konstrk kozt nonfinal serializable classoknal. amint konstrnak, readObject() metodusnak sem szabad overridolhato metodust invokolnia, se direkten se indirekten (item 19). ha ezt a szabalyt violaljuk, es a kerdeses metodust overridoljak, az overridolo metodus le fog futni mielott a subclass stateje deserializalodna. az eredmeny valszeg prg hiba lesz

summary: valahanyszor readObject() metodust irunk, tekintsuk ugy mintha public konstrt irnank amelynek valid instanceot kell krealnia, fgtlul a kapott byte streamtol. ne felt azt h a byte steram egy tenyleges serialized instanceot repr. a peldak ebben az itemben olyan classra von, amelyek a default serialized formot haszn, az emlitett problemak uugy von classra ami custom serialized formot haszn. readObject() metodus iras guidelineok
- classok amelyeknek obj ref fieldjei vannak amelyek privateok kell maradjanak, def copyzzunk minden objt ami ilyen fieldben van. immut classok mut componentjei ide tart
- csekkeljunk minden invart es dobjunk InvalidObjectExceptiont ha csekkeles failel. a csekkeknek a def copyzasok utan kell kov
- ha egy teljes obj grafot kell validalnunk miutan deserializaltuk, haszn az ObjectInputValidation ifacet (konyv nem targyalja)
- ne invokoljunk overridolhato metodusokat a classban, se direkt se indirekt