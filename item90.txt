ITEM 90: CONSIDER SERIALIZATION PROXIES INSTEAD OF SERIALIZED INSTANCES

ahogy item 85 es 86 emlitette, es a fejezetben vegig szo volt rola, ha ugy dontunk h impl Serializablet, az noveli a bugok es secu problemak eselyet mert lehetove teszi h egy extralinguistic mech segitsegevel krealjunk instanceokat normal konstrk helyett. de van egy techn amivel ezek a riskek csokkenthetoek, az un serialization proxy pattern

ez a pattern meglehetosen straightfwd. eloszor, designoljunk egy private static nested classt ami tomoren repr az enclosing class egy instanceanak logical statejet. ez a nested class az enclosing class un serialization proxyja. egy single konstra lehet, amelynek paramja az enclosing class. a konstr csak atmasolja az argjaban levo datat: nem kell konz csekket v def copyzast csinalnia. by design, a serialization proxy default serialized formja az enclosing class tokeletes serialized formja. az enclosing classnak es a serialization proxyjanak is impl kell Serializablet

pl. item 88-ban serializableve tett immut Period class serialization proxyja. a Period olyan egyszeru h a serialization proxyjanak pontosan uazok a fieldjei mint a classnak
private static class SerializationProxy implements Serializable {
  private final Date start; private final Date end;
  SerializationProxy(Period p) { this.start = p.start; this.end = p.end;
  private static final long serialVersionUID = ...; //bmi lehet, ld. item 87
  
ezutan adjuk hozza az alabbi writeReplace() metodust az enclosing classhoz. ez a metodus szo szerint atmasolhato bmely classban amelynek van serialization proxyja
private Object writeReplace() { return new SerializationProxy(this);

ennek a classnak a jelenlete az enclosing classban azt okozza h a serialization sys egy SerializationProxy instanceot emittal egy enclosing class instance helyett. maskent, a writeReplace() metodus az enclosing class egy instanceat a serialization proxyjaba forditja a serialization elott

ha ez a writeReplace() metodus ott van, a serialization sys sosem fogja az enclosing class egy serialized instanceat generalni, de egy tamado gyarthat egyet a class invarjainak violalasa celjabol. h egy ilyen tamadas faileljen, adjuk hozza az alabbi readObject() metodust az enclosing classhoz
private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("proxy required");

vegul nyujtsunk egy readResolve() metodust a SerializationProxy classban ami az enclosing class egy logically equivalent instanceat returnoli. ha ez a matodus ott van, a serialization sys visszaforditja a serialization proxyt az enclosing class egy instanceaba a deserialization soran

ez a readResolve() metodus az enclosing class instanceot kizarolag a public APIja segitsegevel krealja, es ebben rejlik a pattern szepsege. nagyreszt eliminalja a serialization extralinguistic jelleget, mivel a deseializalt instanceot uazok a konstrk, static factoryk es metodusok segitsegevel krealjuk mint bmely mas instanceot. ez mentesit minket attol is h kulon kelljen bizt h a deserializalt instanceok megtartsak a class invarjait. ha a class static factoryjai v konstrjai letrehozzak ezeket az invarokat az instance metodusok pedig megtartjak oket, akkor ezzel bizt h a serialization is megtartja az invarokat

Period.SerializationProxy readResolve() metodusa
private Object readResolve() { return new Period(start, end);

mikent a def copy approach, a serialization proxy approach is kivedi a hamis byte-stream tamadast, es az internal field theft tamadast. az emlitett ket approachal szemben ez megengedi h a Period fieldjei finalok legyenek, ami szukseges ahhoz h a Period class tenylegesen immut legyen (item 17). es ezekkel az approachokkal ellentetben, nem is kell sokat gondolkozni hozza. nem kell kitalalnunk h mely fieldek serulhetnek serialization tamadasok soran, es nem kell expl validity csekkelest vegrehajtanunk a deserialization reszekent

meg egy dolog van amelyben a serialization proxy pattern hatasosabb mint a readObject()-ben levo def copyzas. a serialization proxy pattern lehetove teszi h a deserializalt instance classa mas legyen mint az originally serialized instance. nem gondolnank h ez gyakban hasznos, de az

pl. EnumSet (item 36). ennek a classnak nincsenek public konstrjai, csak static factoryjai. client perspektivajabol EnumSet instanceokat returnolnek, de a jelenlegi OpenJDK implban ket subclass vmelyiket returnolik, fuggoen az underlying enum type meretetol. ha az underlying enum typenak 64 v kevesebb elementje van, a static factoryk RegularEnumSetet, egyebkent JumboEnumSetet returnolnek

gondoljuk vegig mi tortenik ha egy olyan enum setet serializalunk, amely enum typejanak 60 elementje van, aztan adjunk hozza meg 5 elementet az enum typehoz, aztan deserializaljuk az enum setet. amikor serializaltuk, akkor RegularEnumSet instance volt, de amikor deserializaltuk akkor mar JumboEnumSet kellene legyen. es valoban ez is tortenik mert az EnumSet a serialization proxy patternt haszn. igy nez ki az EnumSet serialization proxyja
private static class SerializationProxy<E extends Enum<E>> implements Serializable {
  private final Class<E> elementType;
  priavet final Enum<?>[] elements;
  SerializationProxy(EnumSet<E> set) { elementType = set.elementType; elements = set.toArray(new Enum<?>[0]);
  private Object readResolve() { EnumSet<E> result = EnumSet.noneOf(elementType); for(Enum<?> e : elements) result.add((E)e); return result;
  private static final long serialVersionUID = ....;
  
a serialization proxy patternnek ket limitationja van. nem kompat olyan classokkal amelyeket a usereik extendalhatnak (item 19). es nem kompat egyes classokkal amelyek obj grafja circularityt tart: ha egy ilyen objn probalunk metodust invokolni a serialization proxyjanak a readResolve() metodusabol, az ClassCastException lesz mert meg nincs meg az obj, csak a serialization proxyja

vegul a serialization proxy pattern altal hozzaadott power es safety nem ingyen van. szerzo gepen 14%-al dragabb Period instanceokat serialization proxyval serializalni es deserializalni Period instanceokat mint def copyzassal

summary: akkor gondolkodjunk a serialization proxy patternen ha readObject() v writeObject() metodust kell irnunk egy olyan classon amelyet a clientjei nem extendalhatnak. ez talan a legegyszerubb modja robust modon serializalni objkat amelyeknek nontrivial invarjai vannak