From Collections to Streams in Java 8 Using Lambda Expressions (Jose Paumard)

[Lambda Expressions and Functional Interfaces]

lambda expr
pl. basic Comparator
iface egy methoddal, compare()
anonymous class instance: Comparator<String> comparator = new Comparator<String>() { public int compare(String s1, String s2) { return Integer.compare(s1.length(), s2.length());}};
Arrays.sort(tabStrings, comparator)

pl. Runnable r = new Runnable() { public void run() { while(...) { sout(...); } } };
Executors.newSingleThreadExecutor().execute(r);

code in anon class instance; passed it to another piece of code; executed it "later" (sort, execute) and in another context (thread)
passed code as parameter; ennek javaban az anon class az egyetlen modja (pl. Swing callbacks)

atiras lambda expr-re
Comparator<String> comparator = (String s1, String s2) -> Integer.compare(s1.length(), s2.length()); //{} es return itt nem kell a jobb oldalon!
Runnable r = () -> { while(...) { sout(...); } };
ha tobb sorbol all, akkor kell a {} es a return: (String s1, String s2) -> { sout(...); return Integer.compare(...); } //ez igy olyan mintha iface methodot impl

bizonyos modifierek hasznalhatoak a parametereken: final, annotations
lambda expr returned typejat nem lehet specifyolni (ld.kesobb)
paramok typeja omitolhato: (s1, s2) -> { ... }

---
method references
alternative syntax a lamba exprkhez
Function<Person,Integer> f = person -> person.getAge(); //compiler guesselni tudja a person tipusat; returnt nem kell kiirni mert csak egy stmt van es nincs {}
ez egy Function tipusu lambda expr
uez method reffel: Function<Person,Integer> f = Person::getAge;

BinaryOperator<Integer> sum = (i1, i2) -> Integer.sum(i1,i2); //i1 + i2
uez method reffel: BinaryOperator<Integer> sum = Integer::sum;
ne keverjuk ossze a method refet a static hivassal (sum() static, de pl. az elozo getAge() instance volt)

Consumer<String> printer = s -> System.out.println(s); //van egy argja es nem returnol semmit
uez method reffel: Consumer<String> printer = s -> System.out::println;

tehat a lambda expr egy new syntax; anon class instanceok leirasanak egy masik modja (pass code as parameter to method/process). a method ref a lambda expr alternativ syntaxa

---
live coding
existing API atirasa java8 lambda + iface default methodok + iface static methodok segitsegevel

sajat comparator iface
@FunctionalInterface
public interface Comparator<T> {
  public int compare(T t1, T t2);
  
Comparator<Person> cmpAge = (p1,p2) -> p2.getAge() - p1.getAge();
Comparator<Person> cmpFirstName = (p1,p2) -> p1.getFirstName().compareTo(p2.getFirstName());
Comparator<Person> cmpLastName = (p1,p2) -> p1.getLastName().compareTo(p2.getLastName());

Function<Person,Integer> f1 = p -> p.getAge();
Function<Person,String> f2 = p -> p.getLastName();
Function<Person,String> f3 = p -> p.getFirstName();

Comparator<Person> cmpPersonAge = Comparator.comparing(f1);
ahol 
public static Comparator<Person> comparing(Function<Person, Integer> f) { return (p1,p2) -> f.apply(p1) - f.apply(p2); }
uj static metodus a sajat Comparator ifaceben

syntax lehet igy is
Comparator<Person> cmpPersonAge = Comparator.comparing(p -> p.getAge());
Comparator<Person> cmpPersonAge = Comparator.comparing(Person::getAge);

ha uezt pl lastName-el is akarjuk
Comparator<Person> cmpPersonLastName = Comparator.comparing(f2);
akkor kellene egy Function<Person,String>-et atvevo comparing() metodus is az ifacebe, de az azonos signature lenne mint a Function<Person,Integer> es nem fordul le
helyette kozos
public static Comparator<Person> comparing(Function<Person, Comparable> f) { return (p1,p2) -> f.apply(p1).compareTo(f.apply(p2)); }
ami OK, mert a getAge() altal returnolt int autoboxolodik Integer-be ami Comparable

iface meg tovabb generalizalhato Person-rol
public static <U> Comparator<U> comparing(Function<U, Comparable> f) { return (p1,p2) -> f.apply(p1).compareTo(f.apply(p2)); }

comparatorok chainelese
Comparator<Person> cmp = cmpPersonAge.thenComparing(cmpPersonLastName);
ahol
public default Comparator<T> thenComparing(Comparator <T> cmp) { return (p1,p2) -> compare(p1,p2) == 0 ? cmp.compare(p1,p2) : compare(p1,p2); }
uj default metodus a sajat Comparator ifaceben

Comparator<Person> cmp = Comparator.comparing(Person::getLastName).thenComparing(Person::getFirstName).thenComparing(Person::getAge);
ez igy nem OK, mert a thenComparing nem Functiont vesz at
masoljuk le a metodust az ifaceben egy masik signature-al
public default Comparator<T> thenComparing(Function<T, Comparable> f) { return thenComparing(comparing(f)); }

===
[Writing Data Processing Functions with Lambdas in Java 8]

func ifaces
egy lambda expr egy func iface egy instance-a
func iface: iface egy db abstract metodussal (Comparator, Runnable, Predicate stb)

func iface implja JDK7-ben anon classal
JDK8-ban lambdaval: Predicate<String> p = (String s) -> s.length() < 20; //vagy csak s -> ...
ezt nem lehet method refre konvertalni mert argja van!

compiler tudja h az iface func tehat csak egy db metodus van benne, tehat annak az implja tortenik
a var typeja megadja a lambda expr typejat (itt Predicate)
metodus paramoknak, return typenak, exceptionoknek matchelniuk kell
ezek alapjan a compiler ki tudja guesselni a lambda syntaxbol ami szukseges

lambda expr tehat egy iface implja, es ra tudunk hivni: p.test("Hello World");

func ifaceben egy db abstract metodus
emellett lehet benne tetszoleges szamu default es static metodus
az Object classbeli metodusok (toString(), equals() stb.) nem szamitanak bele, meg ha abstractkent is vannak deklaralva. mert minden obj az Object classt extendalja (explicit v implicit) tehat a metodusai minden obj szamara hferhetoek; ifacekbe ezeket csakkor szoktak belerakni ha a docot akarjak pontositani (ld. pl. Collection iface equals(), mikor egyenlo ket coll). uezert nem lehet az Object metodusaibol defaultot letrehozni a sajat func ifaceunkben (tehat pl. siman int hashCode() lehet, de default int hashCode() nem)
@FunctionalInterface optional (ha mandatory lenne akkor a sajat Java 8 elotti egymetodusos ifaceinket fel kellene ezzel annotalnunk es ujracompilolnunk). ujonnan letrehozott ifacekre javasolt felrakni, mert compile timeban ellenoriz (esetleges nagyszamu default es static metodus eseten nem feltetlenul egyszeru atlatni h tenyleg func-e az iface)

---
java.util.function
- Consumers
--Consumer: egy objt vesz at es nem returnol semmit
public void accept(T t); 
Consumer<String> printer = s -> System.out.println(s);
--BiConsumer: ket objt consumal es nem returnol semmit. 
public void accept(T t, V,v);

- Supplier
nincs paramja, objt returnol
public T get(); 
Supplier<Person> s = () -> new Person(); //vagy method reffel Person::new; (mert van arg nelkuli konstruktora)

- Functions
-- Function: objt vesz at es masik objt returnol
public R apply(T t);
Function<Person, Integer> f = person -> person.getAge(); //vagy method reffel Person::getAge;
-- BiFunction: ket objt vesz at es egy harmadikat returnol
public R apply(T t, V v);
-- UnaryOperator<T> extends Function<T,T>: nem def uj metodust. uolyan tipusu objt returnol (uazt az objt v egy masikat)
-- BinaryOperator<T> extends BiFunction<T,T,T>: nem def uj metodust. ket egyforma tipusu objt vesz at es egy uolyan tipusu objt returnol

- Predicates
-- Predicate: objt vesz at es booleant returnol
public boolean test(T t);
map-filter-reduce algo filter lepeseben haszn
Predicate<Person> p = person -> person.getAge() > 20;
-- BiPredicate: ket objt vesz at es booleant returnol
public boolean test(T t, U u);

func ifacek primitiv typeokra
fenti generikusokba nem helyettesitheto primitiv
IntPredicate (int -> boolean), IntFunction (int -> T), IntToDoubleFunction (int -> double) stb.

---
live coding
sajat Predicate func iface: public boolean test(T t);
Predicate<String> p1 = s -> s.length() < 20; 
boolean b = p1.test("Hello");

ket Predicate chaineleset szeretnenk: Predicate<String> p3 = p1.and(p2);
public Predicate<T> and(Predicate<T> other);
ez igy a masodik abstract metodus az ifaceunkben; defaultta kell tennunk
impl: Predicate<T>-t kell returnolnunk, ami ugye func iface, tehat a test() metodusanak az impljat kell providolnunk, amit pedig lambda expr-al csinalhatunk (!!)
return t -> test(t) && other.test(t);

uez OR-ra uugy: Predicate<String> p4 = p1.or(p2);

uj static metodus: Predicate<String> p5 = Predicate.isEqualsTo("Yes");
public static Predicate<String> isEqualsTo(String string) { return s -> s.equals(string); }
p5.test("Yes") true, p5.test("No") false
generikusan uez: public static <U> Predicate<U> isEqualsTo(U u) { return s -> s.equals(u); }
ekkor mehet ez is: Predicate<Integer> p6 = Predicate.isEqualsTo(1);

===
[Data Processing Using Lambdas and the Collection Framework]

- Iterable: boolean forEach(Consumer)
people.forEach(System.out::println)

- Collection: boolean removeIf(Predicate). 
people.removeIf(person -> person.getAge() < 20)

- List: boolean replaceAll(UnaryOperator). boolean sort(Comparator)
names.replaceAll(name -> name.toUpperCase()) vagy names.replaceAll(String::toUpperCase)
names.sort(Comparator.comparing(Person::getName).thenComparing(Person::getAge))

- Map: 
-- void forEach(BiConsumer)
map.forEach( (city,list) -> System.out.println(city + list.size()));
-- V getOrDefault(Object key, V defaultValue)
sima get() return null, ami nem a legjobb mert nem tudjuk h a value-e a null, vagy nincs benne a key a mapben. contains()-t kell haszn. vagy ezt az uj metodust
Map<City, List<Person>> map
map.getOrDefault(boston, Collections.EMPTY_LIST);
-- V putIfAbsent(K key, V value)
ha a key mar benne van a mapben, akkor nem csinal semmit. ha nincs benne akkor hozzaadja a (key,value)-t
mar a mapben levo valuet returnoli. ha a key nincs benne akkor nullt
map.putIfAbsent(boston, new ArrayList<>()); //igy garantaljuk h map.get(boston).add(maria) hivasnal a get() legalabb egy ures listat returnoljon amibe aztan addolni lehet. de ez a ketto ossze is vonhato a computeIfAbsent() segitsegevel, ld. lentebb
-- V replace(K key, V newValue); boolean replace(K key, V existingValue, V newValue)
az elso akkor replacel ha mar benne van a key; a masodik akkor ha az atadott existingvalue megegyezik a mapben benne levo valueval
-- void replaceAll(BiFunction(K,V,V))
bifunction a key-value part veszi at es a kiszamolt uj valuet returnoli amivel aztan a mapbeli value replacelve lesz
-- void remove(Object key, Object value)
ellentetben a JDK7-el ez nem csak a keyt hanem a key-value part removolja. csekkeli h a key-hez tenyleg a megadott value tartozik es ha nem, akkor nem removol

-- V compute(K key, BiFunction(K,V,V) remapping)
BiFunction uj valuet szamol az atadott keybol (ami vagy benne van a mapben vagy nem) ES a valuebol ami vagy egy existing value ha a key benne van a mapben vagy null ha a key nincs benne a mapben
-- V computeIfAbsent(K key, Function(K,V) mapping)
a function csakkor hivodik ha a key nincs benne a mapben (absent)
-- V computeIfPresent(K key, BiFunction(K,V,V) remapping)
ugy mukodik mint a sima compute(), de a BiFunction csakkor hivodik ha a key benne van a mapben. az existing value ilyenkor nem lehet null

a compute valtozatok mind returnolik a valuet ami vagy most lett kiszamolva a mapping func altal vagy mar benne volt a mapben
map-of-mapsre nagyon jo
Map<String, Map<String,Person>> map; map.computeIfAbsent("one", key -> new HashMap<String,Person>()).put("two", john);
ha az "one" benne van a mapben akkor a lambda nem fut le; ekkor mar tartozik az "one"-hoz egy belso HashMap es a computeIfAbsent() hivas ezt adja vissza, es ebbe bele lehet rakni a ("two",john) part. ha a "one" nincs benne a mapben akkor lefut a lambda, es kreal egy ("one", uj hashmap) part, es ebbe az uj belso hashmapbe lesz aztan belerakva a ("two",john) par
hasonloan map-of-listre: Map<String, List<Person>> map; map.computeIfAbsent("one", key -> new ArrayList<Person>()).add(john);

-- V merge(K key, V newValue, BiFunction(V,V,V) returning)
BiFunction ezuttal value-part vesz at! ha az atadott key nincs a mapben akkor key-value part hozzaadja a maphez. ha benne van a mapben, akkor a mar mapben levo, hozzatartozo valuet mergelni kell az atadott valueval (a BiFunction segitsegevel ami a kiszamolt uj valuet returnoli)
Map<City,List<Person>> map1, map2; map2-beli key,value parokat bele akarjuk mergelni map1-be
map2.forEach((city,people) -> map1.merge(city, people, (existingPeople, newPeople) -> { existingPeople.addAll(newPeople); return existingPeople; }));
vegigloopolunk a map2 key-value parjain es egyesevel bemergeljuk oket map1-be. ha city nincs benne map1-ben akkor a city,people part berakjuk map1-be. ha city benne van map1-ben akkor osszemergeljuk a hozzatartozo existing peoplet a map2-bol loopolt new people-al

live coding
(elobbiekben bemutatott metodusok hasznalata csak azt irom le, ahol vmi uj/eltero van a peldakhoz kepest)
List<Person> people;
people.replaceAll(person -> new Person(person.getName().toUpperCase(), person.getAge()));
people.sort(Comparator.comparing(Person::getAge).reversed());

===
[Implementing Map Filter Reduce Using Lambdas and Collections]

map-filter-reduce pelda: 20 evnel idosebb emberek age atlaga, JDK7-ben hosszu iteralos mo
people -> [map] -> age -> [filter] -> (age > 20) -> [reduce] -> avg
map: List<Person>-bol List<Integer>-t csinal, size nem valt
filter: nem valt a tipust (List<Integer>). size valt, kifilterezi azokat amelyek nem teljesitik a predicatet
reduce: valt a tipust. List<Integer> -> Integer (~SQL aggregation)

API design: egy kepzeletbeli Lists class static metodusaival
List<Person> people;
List<Integer> ages = Lists.map(people, person -> person.getAge());
List<Integer> agesGT20 = Lists.filter(ages, age -> age > 20);
int sum = Lists.reduce(agesGT20, (a1, a2) -> a1 + a2);

reduce bovebben
int sum = Lists.reduce(agesGT20, (a1, a2) -> a1 + a2);
int list. elso ket elem a1, a2. elso lepes a1 + a2. masodik lepesben ez lesz az a1 az a2 pedig a lista harmadik eleme. es igy vegig a listan
parhuzamosithato is. szetvagjuk a listat annyi reszre ahany CPU van, es mindegyik reszen vegrehajtjuk a fenti algot, es a vegen osszeadjuk a reszosszegeket

caveat1
Red(a,Red(b,c)) = Red(Red(a,b),c) teljesulnie kell (associativity). i1 + i2 OK, Integer.max(i1,i2) OK, i1*i1 + i2*i2 NOK, i1 OK (i1,i2 kozul az elsot adjuk vissza; vegeredmenyben mindig a lista elso elemet. hasonloan i2 a lista utolso elemet), (i1+i2)/2 NOK (tehat listaatlagot nem tudunk ezzel szamolni; az osszes listaelemet ossze kell adni es elosztani a lista size-al)
mi van ha a reduceban hasznalt lambda nem asszociativ? compile/execute hiba nelkul, de az eredemeny nem lesz jo (jo esellyel minden futas eredmenye mas lesz)

caveat2
List<Integer> ints; int sum = 0; BinaryOperator<Integer> op = (i1,i2) -> i1 + i2; for(int i : ints) sum = op.apply(sum, i);
+ operatornak 0 az identity elementje tehat itt jo ha ezzel initeljuk a sum-ot
de ha op = Integer.max(i1,i2) avagy Integer::max, akkor nem jo; pl. ha az ints egy db -1 elemet tart akkor max(0,-1) 0 lesz ami nem jo. ugyanigy pl. ha ints tartalma (-1,-2,-3). mert a max-nak nem a 0 az identity elementje
nem minden opernek van identity elementje (pl. max-nak nincs)

live coding
List<Integer> ints = 1...9; BinaryOperator<Integer> op = (i1,i2) -> i1 + i2; int red = reduce(ints, 0, op); //reduce()-ban a fenti sum = 0, for/apply logika
parh szimulalasa: ints elemei szetbontva ints1, ints2-be. int red1 = reduce(ints1, 0, op); int red2 = reduce(ints2, 0, op); red = reduce(Arrays.asList(red1, red2), 0, op); uaz lesz a vegeredmeny
op = Integer.max(i1, i2)-ra is uazt az eredmenyt adja a parh futtatas, de (i1+i2)*(i1+i2)-re NOK mert az nem asszoc (pl. valtoztassuk futtatasonkent az ints1,ints2 bontast es mindig mas lesz a vegeredmeny). (i1, i2) -> i1 OK mert asszoc, de (i1 + i2)/2 NOK mert nem asszoc
op = Integer.max(i1, i2) ugy h ints-ben negativ elemek is vannak. ints1,ints2 bontastol fuggoen akar az elvart vegeredmeny is kijohet a parh futasbol, pl. ha ints1-ben vannak a poz, ints2-ben pedig a neg elemek, de ha megnezzuk kozelebbrol akkor az ints2-re futtatott reduce eredmenye nem -1 hanem 0 lesz, tehat ez csak veletlen

JDK8 Optional segitsegevel lehet kezelni h a reducenak nem biztos h van identity elementje: wrapper type ami empty is lehet (tehat nem olyan mint az Integer, Double stb wrapperek)

vissza a fenti API designhoz
ha people Listben 10 millio elem van akkor a map lepes eredmenye egy szinten 10 millio elemu Integer lista. majd a filter letrehoz egy ujabb Integer listat mondjuk 5 millio elemmel. vegul a reduce vegeredmenye egyetlen int, es a sok millio koztes elem megy a GC-be. ez oriasi CPU load/mem footprint
de lehet meg rosszabb is; pl. a reduce nem atlag hanem boolean namesLT20 = Lists.allMatch(names, name -> name.length() < 20); allMatch() implja: for(names) { if(name.length() > 20) return false; } return true; ha mondjuk az elso elemnel kiderul h NOK akkor azonnal shortcut falset returnolhetunk, de ha az osszes elem OK akkor az egesz tobbmillios listat vegig kell nezni h a vegen truet returnolhessunk
ki lehetett volna hasznalni h a names listanak a people listabol valo, a map lepes soran torteno eloallitasa soran elemenkent vegrehajthattuk volna ezt a csekkelest, es nem kellett volna a reduce lepes soran megint vegigmenni az egesz listan
tehat ez nem igazan jo modja a map-filter-reduce API designnak. valojaban az elejen latott JDK7-es iteralos mo is performantosabb (az nem krealgat oriasi intermediate tarolokat hanem egy loopban kiszamolja az atlagot)
egyebkent az int average = people.map(p->p.getAge()).filter(age -> age > 20).average(); syntax egyebkent nagyon kellemes lenne, de nem akarjuk a CPU/mem ktget megfizetni => JDK8 Stream API: people.stream().map...

===
[The Stream API, How to Build Streams, First Patterns]

Stream: typed iface (stream of T)
IntStream, LongStream, DoubleStream: ifacek a primitive tipusokhoz
map-filter-reduce algo soran krealt nagy intermediate tarolok elkerulesere

stream nem tarol datat; csak processalja a sourcebol pullozott datat
stream nem modifyolja a processalt datat (contract, ha sajat streamet implementalok akkor be kell tartani); mert parh akarjuk a datat processalni tobb coreon, visibility/sync issuek nelkul amik perf-- okozhatnanak
source unbounded lehet; ez nem biztos h azt jelenti h infinite; jelentheti azt is h finite, de nem tudjuk h mennyi elemet fog producolni. pl. ismert sizeu textfile, es az elementek a sorai: a file sizeot ismerjuk, de a sorok szamat csakkor ha megnyitjuk a filet es megszamoljuk
(vs collection: tarolja az adatot, modifyolhatja az adatot, ismert es finite szamu adatot tart)

stream building
List<Person> people; people.stream();

Stream.empty(); //ures stream
Stream.of("one"); //singleton stream
Stream.of("one", "two", "three"); //tobb element
(empty, of a Stream iface static metodusai)

Stream.generate(() -> "one"); //constant stream (i.e. konstans "one" elemekbol all). suppliert vesz at
Stream.iterate("+", s -> s + "+"); //growing stream (+, ++, +++....). az elso elemet es a tovabbi elemeket kepzo unaryoperatort vesz at 
ThreadLocalRandom.current().ints(); //random int valuek streamje (IntStream)
infinitek, limit() metodussal limitelhetoek ld. live coding

IntStream stream = "hello".chars(); //stream a String charjaibol
Stream<String> words = Pattern.compile("...").splitAsStream(book); //stream a regexp szerint splittelt stringekbol 
Stream<String> lines = Files.lines(path); //stream a textfile soraibol (autocloseable, try-with-resourcenak atadhato, vegen bezarja a streamet es az underlying textfilet)

stream buildeles elemenkent
Stream.Builder<String> builder = Stream.builder();
builder.add("one").add("two")...
builder.accept("three"); //uugy mukodik mint az add() csak nem returnol semmit tehat nem chainelheto
Stream<String> stream = builder.build(); //vegen megbuildeljuk a streamet az addelt elemekbol
stream.forEach(System.out::println); //hozzaadas sorrendjeben traversal
egy mar megbuildelt stream add/accept-re exceptiont dob

map-filter-reduce
people.stream().map(p->p.getAge()).filter(age -> age > 20).forEach(System.out::println);
stream(): Stream<Person>, map(): Stream<Integer>, filter(): Stream<Integer>, forEach() kiiras. tehat 3 uj streamet krealtunk, ezek nem tarolnak datat, lightweight
a filter letrehoz egy uj, azonos tipusu streamet, nem uazt hasznalja ujra

intermediate/terminal calls
forEach()-et nem rakhatjuk a map() utan es a filter() ele, mert nem returnol semmit. helyette peek(), ami lenyegeben uazt a streamet returnoli, tehat folytathato a chain
people.stream().map(p->p.getAge()).peek(System.out::println).filter...
debuggolasra OK, prodban ne hasznaljuk
ha peek() lenne a forEach() helyett a stream vegen: lefordul, csak nem ir ki semmit. peek intermediate oper, forEach terminal oper
terminal triggereli a stream processalasat. ha nincs a vegen terminal oper akkor nem lesz a data processalva. az intermediate nem triggerel semmit
mi terminal oper? nezzuk meg a javadocot, ill el lehet donteni arrol h a Streamet returnolo operek intermediatek, ami pedig mast returnol v void az terminal (ez kovetkezik abbol h a stream nem tart datat; tehat egy olyan oper ami vmi datat returnol v consumal, annak triggerelnie kell a processinget, tehat terminal)

stream data ranges (intermediate)
people.stream().skip(2).limit(3).filter...
stream ket elso elemet (A,B) skippeli, kov harmat (C,D,E) megtartja, az utana kovetkezokkel (F...) nem foglalkozik

simple reductions (terminal)
anyMatch(), allMatch(), noneMatch(): predicatet vesznek at es booleant returnolnek, pl. ...allMatch(p-> p.getAge() > 20);
shortcircuit operatorok, azaz nem biztos h minden stream elementre kiertekelik a predicatet

find reduction
findFirst(), findAny(): predicatet vesznek at es elementet kellene returnolniuk, de lehet h semmit nem returnolnek; ha a stream empty vagy ha nincs a predicatet matchelo element; ezert Optionalbe wrappelt elementet returnolnek
Optional<Person> opt = people.stream().findFirst(p->p.getAge() > 20); ha a streamnek van orderje (pl. ha a stream egy ArrayListre epul) akkor az elso persont returnoli. ha a streamnek nincs orderje (pl. ha a stream egy HashSetre epul) akkor bmely persont returnolheti
findAny() uigy mukodik, de bmely persont returnolheti

reduce reduction
ha nem adunk meg identity elementet a reducenak akkor Optionalt returnol (mert identity elem nelkul az empty stream reducejanak eredmenye undefined)
associativity assumed but not enforced
int sumOfAges = people.stream().reduce(0, (p1,p2) -> p1.getAge() + p2.getAge()); //mivel megadtunk identity elementet, ezert uazt a tipust returnoli (int)
int maxOfAges = people.stream().reduce(0, Integer.max(p1.getAge(), p2.getAge())); //poz intekre a 0 max identity elementje, ugyh ha tudjuk h csak ilyenek vannak (mint pl. eletkoroknal) akkor OK
Optional<Integer> opt = people.stream().reduce(Integer.max(p1.getAge(), p2.getAge())); //nem adtunk meg identity elementet ezert a result Optionalbe wrappelve
List<Integer> ages = people.stream().reduce(new ArrayList<Integer>(), (list,p) -> {list.add(p.getAge()); return list;}, (list1, list2) -> { list1.addAll(list2); return list1; } ); //parh operekhez. paramjai: identity element, accumulator (hogy tudok hozzaadni egy elemet a listahoz amit eppen epitunk), combiner (ket kulonbozo CPUn epitett listet mergel ossze)

live coding
Stream.generate(() -> "one").limit(5).forEach(System.out::println); //5x "one"
Stream.iterate("+", s -> s + "+").limit(5).forEach(System.out::println); //+, ++, +++, ++++, +++++
ThreadLocalRandom.current().ints().limit(5).forEach(System.out::println); //5 db random int