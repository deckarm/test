Java Concurrency in Practice

[Chapter 1. Introduction]

[[1.1. A (VERY) BRIEF HISTORY OF CONCURRENCY]]

OS a prgkat processekben futtatja; rscket allokal nekik, pl. mem, file handles, security credentials
process interkomm: socket, signal handler, shared mem, semaphore, file

tobb prg parh futtatasa OS altal
- rsc utilization: amig egy prg var (pl IO-ra) addig egy masik prg futhat
- fairness: minden prgnak joga van futni
- convenience: gyakran jobb tobb prgot irni ahol mindegyiknek megvan a sajat taskja, mint egyetlen prgra bizni minden taskot

seq prging model: pontosan def hogy "what comes next" (~IRL tevekenysegek)
+ async: mikozben a furdovizre varunk, csinalhatunk reggelit

threads: tobb control flow egy processen belul (lightweight processes)
threadek osztoznak a process-szintu rscken (mem, file handles) de mindegyiknek sajat prg counterje, stackje, local varjai
egy prgban levo kulonbozo threadek egyszerre futhatnak tobb kulonbozo CPU-n
egy process kulonbozo threadjei a osztoznak a process memjen, ami varatlan problemakat okozhat, ha az egyik thread felulir egy olyan vart amit a masik epp olvas

[[1.2. BENEFITS OF THREADS]]
dev/maint cost--, async workflowk seq-be alakitasa, GUI responsiveness++, server rsc kihasznalas/throughput++, JVM egyszerusites (pl. GC)

[[[1.2.1. Exploiting Multiple Processors]]]
ha egy prgban csak egy thread van az egyidejuleg csak egy CPU-n futhat. ha ugyanez 2 CPU-n fut akkor lemondunk a CPU rsck felerol, ha 100 CPU-n akkor 99%-rol
ha viszont egy prgban tobb thread van az jol kihasznalhatja a tobb CPU-t; throughput++. sot ez meg 1 CPU-n is lehet, mert amig pl. az egyik thread IO-ra var, egy masik addig is futhat a CPU-n (ld. furdoviz/piritos)

[[[1.2.2. Simplicity of Modeling]]]
egy olyan prg ami csak egyfele taskot csinal, egyszerubb mintha sokfelet. ha a kulonbozo taskokat kulon threadekre bizzuk az a seq illuziojat tudjuk kelteni: egy async workflow helyett egymassal kommunikalo sync workflowk
ezt hasznaljak fwknel pl. servlet v RMI. a fw kezeli a req mgmtet, thread krealast, load balancingot stb; a servletek iroinak nem kell ezekkel fogl, ok a sajat service() metodusukat single-threaded prgkent irhatjak

[[[1.2.3. Simplified Handling of Asynchronous Events]]]
tobb remote client conn reqjeit socketen fogado server app egyszerubb ha minden connhoz kulon threadet alloc, es sync IO-t hasznal
ha az app akkor olvas a socketrol amikor azon nincs adat, akkor a read() blokkol. single thread app eseten ez nem csak az adott req hanem az OSSZES req processalasanak a blokkolasat is jelenti; single thread appoknal ezert alt nonblocking IOt haszn, de az komplikalt. sokkal jobb ha minden reqhez kulon threadet indit az app igy egy req blokkolasa nem zavarja a tobbit
regebben az OS-ek eleg keves threadet engedtek egy processnek inditani (max nehany 100); ezt kompenzalando OS szintu tamogatast fejlesztettek multiplexed IO-hoz (unix select, poll) ezeknek az accessalasahoz pedig java NIO; de ma mar joval magasabb ez a limit (linux NPTL 100 ezres nagysagrend)

[[[1.2.4. More Responsive User Interfaces]]]
1 threades GUI appoknal folyamatosan pollozni kell h van-e input event, vagy mindent a main event loopbol hivogatni. ha egy hivas tul sokaig tart akkor ugy tunik mintha a GUI megfagyna, mert a kovetkezo eventek nem processalodnak amig a vezerles vissza nem ter a main loopba
modern GUI fwkben (AWT/Swing) main loop helyett event dispatch thread van. UI event (pl. gombnyomas) eseten event handlereket hiv. a legtobb GUI fwben lenyegeben van main loop, de a sajat threadjeben fut, a GUI toolkit es nem az app felugyelete alatt

[[1.3. RISKS OF THREADS]]

[[[1.3.1. Safety Hazards]]]
class UnsafeSequence { private int value; public getNext() {return value++;}
unsafe. a ++ nem atomic, ha ket thread is futtatja, akkor elkepzelheto hogy mindketto epp uazt az erteket latja, es az egyik inkrementacio elveszik. race cond
a threadek uazt a mem areat hasznaljak, ami megkonnyiti az interthread kommt; de risk is mert nonseqt visz a seq prg modelbe => sync kellhet. pl. sync getNext()
ha nincs sync akkor a compiler, hw es runtime modosithatja a timinget/orderinget (pl. registerek, cachek hasznalata), ami perf++, de a safety megorzese a dev felelossege 

[[[1.3.2. Liveness Hazards]]]
safety: nothing bad ever happens
liveness: sg good eventually happens
liveness failure: nem tud tovabblepni. pl. vegtelen loop
threadek hasznalatanal liveness risk++, pl. DL, starvation, livelock

[[[1.3.3. Performance Hazards]]]
liveness: sg good eventually happens => az eventually nem eleg, quickly kell. perf issue sokfele lehet, pl. service time, responsiveness, throughput stb
jol designolt conc appok alapbol perf++ jelentenek, de vannak perf-- tenyezok, pl. context switch, sync

[[1.4. THREADS ARE EVERYWHERE]]
minden java appban vannak threadek under the hood. JVM housekeeping threadek (GC, finalize); GUI fwk event handler threadjei; servlet,RMI thread pooljai stb.
fwk threadjei behivhatnak az appunkba; thread safetyrol gondoskodnunk kell
- Timer: a TimerTaskok a Timer es nem az app altal managelt threadben futnak; ha a TimerTask olyan datat accessel amit mas app threadek is, akkor azt threadsafe modon kell tennie (leggyakrabban a shared objket teszik threadsafe-e)
- servlet/JSP: tobb client thread is hivhatja parh uazt a servletet. ezenkivul tobb servlet is accessalhatja uazt a datat (app-scoped: ServletContext, session scoped: HttpSession per client). servleteknek/JSPknek, servlet filtereknek, scoped containerekben tarolt objknak threadsafenek kell lenniuk
- RMI: masik JVMen futo obj metodusok invokolasa. a remote obj meghivasa az RMI altal mgelt threadben tortenik. egyszerre tobb thread is hivhatja az objkat. threadsafenek kell lenniuk
- Swing/AWT: a GUI appok termeszetszeruleg asyncok; kulon thread a user eventek kezelesere es a view updatelesere. Swing componentek, pl. JTable nem threadsafek; a threadsafetyt ugy erik el hogy minden GUI comp accessalas az event threadben kell tortenjen. ha a user UI actiont hajt vegre akkor erre az event threadben egy event handler krealodik. ha a handlernek mas threadek altal is accessalt app statet kell modositania (pl. document edit) akkor azt threadsafe modon kell tennie

