Chapter 12. Testing Concurrent Programs

conc prgk designja hasonlo a single threadedhez. kul a nondeterminizmus, no a lehetseges interactionok es failurek szama
hasonloan conc prgk tesztelese a seq prgkere epul; csak nagyobb az elromolhato dolgok space-e. conc prgkban lehetseges hibak "rare probabalistic occurrences rather than deterministic ones", az ilyeneket kimutatasahoz extenziv es hosszan futo tesztek kellenek

conc classok tesztelese safety v livenessre iranyul ("nothing bad ever happens" vs "sg good eventually happens")

safety testek azt verifyoljak h class behav conform-e spechez, alt invariantokat tesztelnek. pl. LL impl ami minden modifnal cacheli a list sizeot, egy safety test oszehas a cached szamot a tenyleges listaelemek szamaval. single threaded appban ez egyszeru mert a lista nem valt a teszt alatt. de conc prgban race lehet, hacsak nem tudjuk egy atomic operben observelni a cache fieldet es megszamolni az elemeket. pl excl accessre lockoljuk a listat az impl altal nyujtott vmi "atomic snapshot" feature segitsegevel v az impl altal nyujtott "test point"okkal amelyekkel a testek invariantokat assertalhatnak v atomic test execelessel

szerencsetlen esetben a hibas eseteket szimulalo test kod olyan timing v sync artifactokat is behozhat amelyek elmaszkoljak a tenyleges bugokat (un Heisenbugs)

liveness testek tobbek kozt progresst/nonprogresst tesztelik; de hogy verifyoljuk h egy metodus blokkol v csak lassan fut? hogy teszteljuk h egy algo NEM DL-el? mennyi ideig kell varnunk mielott kijelenthetjuk h failelt?

livenesshez kapcs a perf testek. perf meres modjai
throughput: rate amellyel conc taskok egy setje completel
resp: egy action requestje es completionja (latency)
scal: throughput++ ha tobb rsct (alt CPU) adunk hozza

[[12.1. TESTING FOR CORRECTNESS]]
cocnc classra irt unit test irasa uugy kezd mint seqnel - invariantok es postcondok azonositasa. ha szerencsenk van, spec leirja oket, egyebkent iterativan kell felfedeznunk

bounded bufferre fogunk testcaseket irni
public class BoundedBuffer<E> {
  private final Semaphore availableItems, availableSpaces; private final E[] items; private putPosition = 0, takePosition = 0;
  public BoundedBuffer(int capacity) { availableItems = new Semaphore(0); availableSpaces = new Semaphore(capacity); items = (E[]) new Object[capacity]; }
  public boolean isEmpty() { return availableItems.availablePermits() == 0; }
  public boolean isFull() { return availableSpaces.availablePermits() == 0; }
  public void put(E x) throws InterruptedException { availableSpaces.acquire(); doInsert(x); availableItems.release(); }
  public E take() throws InterruptedException { availableItems.acquire(); E item = doExtract(); availableSpaces.release(); return item; }
  private synchronized void doInsert(E x) { int i = putPosition; items[i] = x; putPosition = (++i == items.length) ? 0 : i; }
  private synchronized E doExtract() { int i = takePosition; E x = items[i]; items[i] = null; takePosition = (++i == items.length) ? 0 : i; return x; }

fixed-length array based queue, blocking put()/take() metodusok amiket ket semaphore controllal. availableItems az elemek szama amelyek removolhatoak a bufferbol, init 0 (buffer az elejen ures). availableSpaces az elemek szama amennyi insertelheto a bufferbe, init buffer size
take()-hez eloszor kell egy permit availableItems-bol. ha buffer nonempty akkor ez sikerul, egyebkent blokkol amig nonempty lesz. ha megvan a permit akkor removoljuk a kov bufferelemet es releaseljuk a permitet az availableSpacesnek (counting semaphoroknal a permitek nincsenek expl repr v owning threadhez kapcsolva; release() permitet kreal, acquire() permitet consumal). put() forditvam tehat take()-bol/put()-bol exitelesnel a ket semaphore countjainak osszege pont = bound (gyakorlatban ha bounded buffer kell, akkor haszn ABQ-t v LBQ-t ne sajatot, itt csak az insert/removalok demoja miatt)

[[[12.1.1. Basic Unit Tests]]]
alap unit testek uolyanok mint seqnel - bounded buffer krealas, metodushivasok, postcondok es invariantok assertalasa. invariantok pl. ujonnan kreal buffer empty, es egyuttal nem full. pl. N capacityju bufferbe N elem insertalas (blocking nelkul mennie kellene) es csekkelni h a buffer full, es not empty
ezek az egyszeru test metodusok seqek; felderitheto veluk h egy problema NEM conc related

[[[12.1.2. Testing Blocking Operations]]]
conc propertyk tesztelesehez tobb thread kell. legtobb test fw nem conc friendly; nem nagyon tamogatjak a thread krealast ees monitorozast. ha egy test case altal krealt helper thread failuret detektal, a fw alt nem tudja h melyik testhez tart a thread, emiatt a success/failure infot vhogy vissza kell juttatni a main test runner threadbe h reportalni lehessen

java.util.concurrent tesztelesehez fontos volt h a failurek osszekapcsolhatoak legyenek egy adott testtel. ezert krealtak egy base test classt (JSR166TestCase.java) amely metodusokat nyujtott a failurek reportolasahoz a tearDown soran; azt a konvenciot kovetve h minden testnek varnia kell amig az altala krealt threadek terminalnak. de nem kell ennyire messzire menni; a key req h tudjuk mikor passed a test, a failure info pedig vhol reportolva legyen

ha egy metodus bizonyos feltetelek mellett blokkol akkor erre a behavre a test csakkor succesful ha a thread nem halad tovabb. metodus blokkolas tesztelese hasonlo annak tesztelesehez amikor a metodus exct dob; ha a metodus normal returnol az fail

metodus blokkolas tesztelesenel plusz komplexitas: ha a metodus sikeresen blokkol, akkor vhogy meg kell gyozni h unblockoljon. pl interruption: blocking activity kulon threadben startolva, varunk amig a thread blokkol, interruptoljuk es aztan assertalunk h a blockin oper completed. ehhez persze a blocking metodusoknak koran kell returnolnie v InterruptedExceptiont dobni

a "varunk amig a thread blokkol" nem egyszeru: gyakorlatban arbitrary dontes arrol h az execelendo instructionok mennyi ideig tartanak es annal kicsit tobbet varni. fel kell keszulni arra h ezt az erteket novelni kell ha nem megfelelo (kulonben spurious test failurek lesznek)

void testTakeBlocksWhenEmpty() {
  final BundedBuffer<Integer> bb = new BoundedBuffer<>(10); 
  Thread taker = new Thread() { 
    public void run() { try { int unused = bb.take(); fail(); //ha eljutunk idaig az hiba } catch(InterruptedException success) {}}};
	try { taker.start(); Thread.sleep(LOCKUP_DETECT_TIMEOUT); taker.interrupt(); taker.join(LOCKUP_DETECT_TIMEOUT); assertFalse(taker.isAlive()); } catch(Exception unexpected) { fail(); }
blocking oper tesztelese. taker thread megprobal elemet takelni empty bufferbol. ha siker akkor failuret regisztral. a test runner thread startolja a taker threadet, var egy ideig, aztan interruptolja. ha a taker thread az elvarasnak megfeleloen blokkolt a take()-ben akkor InterruptedException-t dob es a catch blokk ezt succeskent kezeli es hagyja a threadet exiitelni. a main test runner thread ezutan megprobal joinolni a taker threaddel es a Thread.isAlive() hivassal verifyolja h a join sikeresen returnolt; ha a taer thread valaszolt az interruptra akkor a joinnak gyorsan completelnie kell

ez a timed join biztositja h a test completel meg ha a take() be is ragad vmilyen unexpected modon. a take() tobb propertyjet is teszteli; nem csak azt h blokkol hanem azt is h interrupt eseten InterruptedExceptiont dob. ez azon esetek egyike ahol Thread subclassolas jobb mint Runnable haszn: a joinnal valo megfelelo termination tesztelesere. uezzel az approacchal tesztelheto h a taker thread unblockol miutan a main thread egy elemet tett a queuera

Thread.getState() csabito lehet annak verifyolasara h a thread condition wait miatt blokkolodik, de ez nem reliable. semmi nem requireli h a blocking thread valaha is belepjen a WAITING v TIMED_WAITING statekbe, mivel a JVM implhatja blockingot spin waitinggel is. hasonloan mivel Object.wait()-bol v Condition.await()-bol lehet spurious wakeup (ld 14) ezert egy WAITING-ben v TIMED_WAITING-ben levo thread temp atmehet RUNNABLE-be meg akkor is ha a condition amire waitel meg nem true. es meg ezeket az impl lehetosegeket ignoralva is eltelhet ido amig a target thread blocking statebe kerul. tehat Thread.getState() nem hasznalhato conc controlra, es testingnel se tul hasznos; debugging info forraskent hasznalhato

[[[12.1.3. Testing Safety]]]
eddigi tesztek data racekkel nem fogl. annak tesztelesere h egy conc class unpred conc access eseten jol mukodik, tobb threadet kell setupolnunk amelyek put()/take() opereket hajtanak vegre

conc classok safety errorjait felderito tesztek chicken-egg problema: maguk a test prgk is conc prgk, es jo conc testeket fejleszteni komplikaltabb lehet mint magukat a tesztelt classokat

conc classokhoz hatekony safety testek irasanal a fo challenge azon propertyk azonositasa amelyek jo esellyel failelnek ha vmi felremegy, uakkor ne hagyjuk h a failuret vizsgalo kod mestersegesen modositsa a conct. legjobb ha a test property csekkelese nem igenyel semmilyen syncet

egy approach ami P/C designokban (pl. BoundedBuffer) jol muk, annak csekkelese h minden amit berakunk a queueba/bufferbe az ki is jon, es semmi mas. ennek naiv implja egy "shadow" listbe inserteli/removolja az elemet amikor bekerul/removolodik a queueba, es assertalja h a shadow list ures a teszt vegen. de ez distortolja a test threadek schedulalasat mert a shadow list modifolasa valszeg syncet es blockingot jelent

jobb az enqueuolt/dequeueolt elemek checksumjat kiszamolni order-sensitiv checksum fvel es osszehasonlitani; ha match akkor test pass. ez single P, single C esetben a legjobb mert ekkor nem csak azt ell h a jo elemek jonnek ki, de azt is h jo sorrendben

ezt kiterj tobb P, tobb C-re; olyan checksum fv kell ami insensitive az elemek orderjere, igy tobb checksum kombinalhato a teszt utan. egyebkent egy shared checksum fieldhez valo sync access conc bottleneck lehet v distortolhatja a test timingjet (ezt bmely kommutativ oper, pl. + v XOR teljesiti)

h biztositsuk h tenyleg azt teszteljuk amit akarunk, fontos h a compiler ne tudja a checksumot kitalalni. nem jo otlet egymast oveto integereket haszn test datakent mert akkor mindig uaz az eredmeny es egy okos compiler precomputalna

ezt elkerulendo test datat random kell generalni, de rossz random gen valasztas is prob lehet. random number generalas (RNG) couplingot krealhat a classok es a timing artifactok kozt mert a legtobb RNG class threadsage es emiatt plusz syncet okoz (sok benchmark szandektalanul valojaban azt teszteli h a RNG mekkora conc bottleneck). ha minden threadnek sajat RNG-je van az nem threadsafe RNG

general purpose RNG helyett jobb egyszeru pseudornd fveket haszn. eleg annyi randomness ami bizt h futasonkent mas-mas szamok lesznek. pl. xorShift(). hashCode() es nanoTime() altal nyujtott valuekkal szamolva gyak biztos h minden futasnal mas lesz

PutTakeTest (pelda tesz kod): N prod thread ami elemeket general es enqueueol, N consumer thread ami dequeueol. mindegyik thread updateli a bejovo/kimeno elemek checksumjat, per-thread checksumok a test vegen kombinalva, igy nem adnak hozza tobb syncet es contentiont mint ami a buffer tesztelesehez szukseges

platformtol fuggoen thread krealas/startolas moderately heavyweight oper lehet. ha a threadunk rovid ideig fut es tobb threadet startolunk loopban, worst caseben a threadek seq futnak nem conc. egy kevesbe rossz esetben is az elso thread egy darabig egyedul fut, aztan az elso ket thread conc, es csak egy ido utan fut az osszes thread conc (vegen uez, a korabban indulo threadek hamarabb is allnak le)

5.5.1-ben starting/finish gatekent hasznalt CDL-ekkel csokkentettuk ezt a problemat. masik mod CyclicBarrierrel, worker threadek szama + 1-re initelve, es a worker threadek es a test driver a barriernel varnak a futasuk elejen es vegen. ez biztositja h minden thread fut mielott elkezdene dolgozni. PutTakeTest igy koordinalja a worker threadek inditasat/leallitasat, ezaltal tobb conct biztositva. ez meg mindig nem garantalja h a scheduler nem futtatja az osszes threadet seq, de ha a futasokat eleg hosszuva tesszuk azzal csokk ennek az eselyet

PutTakeTest ezen kivul egy determ termination kriteriumot haszn, h ne kelljen plusz interthread koord annak megallapitasara h mikor van vege a tesztnek. test() uannyi P-vel es C-vel indul, es mindegyik uannyi elemet put)(-ol es take()-el, igy az osszesen addolt es removolt elemek szama uannyi

az ilyen tesztek jok a safety viok megtalalasara. pl. semaphore altal kontrollalt bufferek impljanal gyakori hiba h az insertet/extractot vegzo kod mutexet kivan meg (synchronized v ReentrantLock). PutTakeTest futtatasa egy olyan BoundedBufferrel ahol doInsert()/doExtract() nem synchronized, gyorsan failel. ha megfuttatjuk PutTakeTestet nehany tucat threaddel, par millioszor, klf capacityju buffereken, akkor mar jo mintank van ra h put()/take() nem csinal data corruptiont

testeknek multiproc syseken kell futnia h a noveljuk a thread interleavinget. de ha nehanynal tobb CPUnk van az nem szuksegkeppen teszi hatekonyabba a teszteket. ha novelni akarjuk a timing-sensitive data racek detektalasanak eselyet, akkor tobb aktiv thread kell mint CPU, h minden idopillban legyenek futo es kiswitchelt threadek is, igy csokkentve a threadek kozti interactionok predictabilityjet

olyan teszteknel, amik fix szamu oper completeleseig tartanak, lehet h a testcase sosem fej be ha a tesztelt kod bug miatt excre fut. leggyakoribb kezelese ha a test fw abortalja a testeket amik biz idon belul nem terminalnak; varakozasi idot empirikusan kell megall, utana pedig analizalni a failuret h biztosan nem az volt a problema h nem vartunk eleget (ez uigy van seq teszteknel is)

[[[12.1.4. Testing Resource Management]]]
eddigi testek azt neztek h a class teljesitette-e a spect. masik test aspect: NEM csinalja amit NEM kell neki, pl. rsc leakeles. bmely obj ami mas objkat tart v managel, ne maintaineljen refeket azokra az objkra hosszabban mint szukseges. az ilyen storage leakek preventaljak h a GC reclaimelje a memet (v threadeket, file handleket, socket handleket, DB connokat v egyeb limted rscket) es rsc exhaustionhoz es app failurehez vezethetnek

rsc mgmt issuek nagyon fontos olyan classoknal mint BoundedBuffer, hiszen a buffer boundolas oka epp az h preventaljuk a rsc exhustionbol eredo app failuret ha P-k nagyon megelozik a C-ket. bounding fogja blokkolni a tul produktiv P-ket h ne krealjanak tovabbi workot ami fogyasztja a memet es egyeb rscket

nem kivant mem retention tesztelheto heap insp toolokkal, amik merik az app mem usaget
testLeak() metodus (pelda teszt kod): heap snapshotok, amik GC-t forcolnak (tenylegesen nem "forcolas", System.gc() csak javasol) es feljegyzik a heap size es mem usage infot. tobb nagy objt rak be a bounded bufferbe, majd removolja oket; a ket heap snapshot pontban a mem usage kb egyforma kell legyen. ha doExtract()-ban nem lenne kinullozva a ref a returnolt elemre (items[i] = null) akkor nem lennenek egyformak (ez egyike azon eseteknek ahol az explicit nullozas szukseges, egyebkent nem az sot karos)

[[[12.1.5. Using Callbacks]]]
client-provided kodba valo callbackek hasznosak lehetnek test case krealashoz; callbackek gyakran az obj lifecycle ismert pontjain tortennek, ami jo lehetoseg invariantok assertelesere. pl. TPE behiv a task Runnablekbe es ThreadFactoryba

thread pool tesztelese magaba foglalja az exec policy teszteleset: lesznek-e plusz threadek krealva amikor kell ill nem lesznek amikor nem kell; idle threadek reapelodnek amikor kell stb. onalloan ezek alt egyszeruen tesztelhetoek, de teljes test suite elkeszitese nagy effort

thread krealas instrumentalhato custom thread factoryval
class TestingThreadFactory implements ThreadFactory {
  public final AtomicInteger numCreated = new AtomicInteger(); private final ThreadFactory factory = Executors.defaultThreadFactory();
  public Thread new Thread(Runnable r) { numCreated.incrementAndGet(); return factory.newThread(r); }
krealt threadeket szamolja; test casek verifyolhatjak a test run soran kreal threadek szamat. extendalhato h olyan custom Threadet returnoljon ami feljegyzi amikor a thread terminal h a test casek verifyolni tudjak h a threadek az exec policynak megfeleloen reapelodnek-e

ha core pool size < max size, a poolnak nonie kell ahogy az exec demand no. ha hosszan futo taskokat submittolunk a poolnak akkor az execelo taskok szama eleg hosszu ideig const marad ahhoz h assertelni lehessen pl. h a pool az elvartnak megfeleloen expandolodik-e (pelda teszt kod)

[[[12.1.6. Generating More Interleavings]]]
conc kodban levo lehetseges failurek kozul sok kis vgu event, de vannak technikak amikkel novelhetjuk. pl. lattuk h ha olyan multiproc sysen futtatunk ahol kevesebb proc mint aktiv thread, akkor tobb thread interleaving lesz mint akar single threaded sysben akar sokprocosban

trukk az interleavingek szamanak novelesere es ezaltal a prg state space jobb kihasznalasara, Thread.yield()-el osztonozni a ctx switchet olyan operek kozben amelyek shared statet accessalnak (platformfuggo mert a JVM kezelheti yieldet noopkent; egy rovid de nonzero sleep lassabb de megbizhatobb mo)
public synchronized void transferCredits(Account from, Account to, int amount) { from.setBalance(from.getBalance() - amount); if(random.nextInt() > THRESHOLD) Thread.yield(); to.setBalance(to.getBalance() + amount);
a ket update oper kozt az olyan invariantok mint "az accountok osszegyenlege 0" nem allnak fenn. ha oper kozepen yieldelunk akkor aktivalni tudunk timing-sensitive bugokat olyan kodokban ami nem haszn megfelelo syncet a state accessalasara. elkerulendo h ez prod kodban ne legyen, csak tesztben, hasznalhatunk AOPt

[[12.2. TESTING FOR PERFORMANCE]]
perf testek gyakran a func testek extended verzioi. erdemes is vmennyi basic func testinget berakni a perf testekbe h biztos ne broken code perfjet teszteljuk
perf es func testek celja mas. perf testek a use casek end-to-end perf metricjeit merik. use scenariok megfelelo setjenek kivalasztasa nem mindig egyszeru; idealis esetben a testeknek tukroznie kellene h a tesztelt objk h vannak az appban hasznalva
neha nyilvanvalo h mi a megfelelo test scenario. bounded puffert szinte mindig P/C designban haszn, tehat erdemes a C-knek datat feedelo P-k throughputjat tesztelni. PutTakeTest erre a scenariora jol extendelheto perf testte

perf test gyakori masodlagos celja a klf sizingek empirikus megallapitasa, threadek szama, buffer capacok stb. ezek lehetnek platformfuggoek is (pl. proc type, procok szama, mem size) ami dinam configot igenyel, de vannak olyanok ahol egy ertek szamos sysben jol muk

[[[12.2.1. Extending PutTakeTest to Add Timing]]]



  