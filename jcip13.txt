Java Concurrency in Practice

[Chapter 13. Explicit Locks]
Java 5 elott a shared data access coord mchjai csak a synchronized es a volatile voltak, ekkor jott be a ReentrantLock. nem helyettesiti az intrinsic lockingot, hanem egy alternativa, advanced featureokkel

[[13.1. LOCK AND REENTRANTLOCK]]
abstract Lock iface; unconditional, polled, timed es interrutible lock acqot is lehetove tesz, es minden lock/unlock oper explicit. Lock impljai uazokat a mem-visibility semanticsot nyujtjak mint az intrinsic locking, de masok lehetnek a locking semantics, scheduling algo, ordering garanciak es perf jellemzok (ld. 14 Lock.newCondition())

ReentrantLock impl Lock, uazokat a mutual excl es mem-visibility garanciakat nyujtja mint a synchronized. RL acqnak uazok a mem semanticsjai mint synchronized blockba valo belepesnek, releaselesenek pedig mint synchronized blockbol valo kilepesnek (mem vis ld. 3.1, 16). synchronizedhez hasonloan RL is reentrant locking semanticsot nyujt (ld. 2.3.2). RL a Lock altal def osszes lock acq modeot supportalja, lock unavailability kezeleseben flex++ a synchronizedhez kepest

instrinsic locking a legtobb esetben jol muk, de vannak func limitjei - nem lehetseges lock acqra waitelo threadot interruptolni, v lock acqot megkiserelni anelkul h hajlandoak lennenk orokre waitelni ra. intrinsic lockot uabban a code blockban kell releaselni ahol acqoltuk; ez egyszerusiti a codingot es jol interactol az exc handlinggel, de lehetetlenne teszi a non-blockstructured locking hasznalatat. ezek miatt meg nem kellene eldobnunk a synchronized-et, de biz esetekben egy more flexible locking mech liveness++ es perf++ jelent

Lock lock = new ReentrantLock(); lock.lock(); try { /* update obj state; catch exc, restore invariants if necessary */ } finally { lock.unlock(); }
kicsit komplexebb mint az intrinsic lock; a lockot a finally blockban KELL releaselni. egyebkent sosem releaselodne ha a guardolt code exct dobna. arra is gondolni kell mi van ha try blockbol exc dobodik; ha az obj incons statebe kerulhet, akkor tovabbi try-catch v try-finally blockok kellhetnek
ha nem hasznalunk finallyt a Lock releaseleshez akkor problema eseten nagyon nehez trackelni h mi tortent. ez egy ok ami miatt a RL nem egyenerteku helyettesitoje a synchronized-nek; "veszelyesebb" mert nem cleanupolja autom a lockot amikor a control kilep a guarded blockbol (pl. FindBugs-ban van is "unreleased lock" detector)

[[[13.1.1. Polled and Timed Lock Acquisition]]]
tryLock() altal nyujtott timed es polled acq modeok szofisztikaltabb error recoveryt nyujtanak mint unconditional acq. intrinsic locknal egy DL vegzetes; recover egyetlen modja az app restart, es az egyetlen vedelem ha ugy designolunk h incons lock ordering ne legyen lehetseges. 

a timed es polled locking viszont "probabilistic DL avoidance"-t nyujt; vissza tudjuk venni a controlt ha nem tudunk minden lockot acqolni, releaselni amelyeket acqoltunk es ujraprobalni (v legalabb logolni a failuret). 

10.1.2-ben latott dyn ordering DL eset kezelese maskent
while(true) {
  if(fromAcct.lock.tryLock()) {
    try { 
	  if(toAcct.lock.tryLock()) {
	    try { if(fromAcct.getBalance() < amount) throw new InsufficientFundException(); else { fromAcct.devit(amount}; toAcct.credit(amount); return true; } } finally { toAcct.lock.unlock(); }
    } finally { fromAcct.lock.unlock(); }
  }
  if(System.nanoTime() > stopTime) return false;
  NANOSECONDS.sleep(fixedDelay + rnd.nextLong());
tryLock()-al probaljuk acqolni a ket lockot, de backoffolunk es retryolunk ha nem tudjuk mindkettot acqolni. a sleep idotartamnak van egy fixed es egy random osszetevoje, h livelock vg-- legyen. ha a lockokat nem sikerult a megadott idon belul acqolni, akkor a transferMoney failure statussal ter vissza h graceful oper  failure legyen

timed lockok akkor is hasznosak timed budgetet managelo activityknel (ld.6.3.7). ha egy ilyen activity blocking methodot hiv, akkor megadhat egy timeoutot a remaining time budgetnek megfeleloen. igy az activityk korabban terminalhatnak ha a kivant idon belul nem tudnak resultot deliverelni. intrinsic locknal nincs mod lock acqot cancellalni ha mar elkezdodott, ezert nem egyszeru vele time budgeted activityket impl

6.3.8-ban latott travel portal pelda separate taskot krealt minden car-rental companyhoz amelytol bidet fetchelt. ez a muvelet valszeg excl accesst kivant meg vmi scarce rschez, pl. comm link a company fele. 9.5-ben lattuk h egy rschez valo serialized access egyik modja a single threaded executor. masik mod ha excl lockkal guardoljuk. 

if(!lock.tryLock(nanoSeconds, NANOSECONDS)) { return false; try { return sendOnSharedLine(message); } finally { lock.unlock(); 
msgt probal kuldeni egy shared comm linkre amit egy Lock guardol, es gracefully failel ha time budgeten belul nem tudja megcsinalni

[[[13.1.2. Interruptible Lock Acquisition]]]
ahogy a timed lock acq excl lockingot tesz lehetove time limited activitykhez, ugy teszi lehetove az interruptible locking cancellable activityknel. 7.1.6.-ban lattunk non-interruptible mechkat, pl. intrinsic locking. Lock.lockInterruptibly() metodus lehetove teszi h lockot acqoljunk mikozben resp maradunk interruptra

interruptible lock acq kicsit komplikaltabb mint a normal, mert ket try block kell (ha az interruptible lock acq tud InterruptedExceptiont dobni akkor standard try-finally eleg)
lock.lockInterruptibly(); try { return cancellableSendOnSharedLine(message); } finally { lock.unlock(); } //cancellableSendOnSharedLine() throws InterruptedException

timed tryLock() is resp az interruptionra, tehat hasznalhato amikor timed es interruptible lock acq kell

[[[13.1.3. Non-block-structured Locking]]]
intrinsic locknal az acq-release parok block-structuredek; egy lock mindig uabban a blockban releaselodik ahol acqolva volt, fgtl attol h a control hogyan hagyta el a blockot. ez az autom lock release egyszerubb kodot + analizisre van szukseg, de neha ennel flexebb lockingra van szukseg

ld.11: lock granularity-- scal++. lock striping lehetove teszi h egy hash-based coll kul hash chainjei kul lockokat hasznaljanak. hasonlo elvet hasznalhatunk ha egy LL locking granularityjet akarjuk csokk; hasznaljunk kul lockot minden link nodera, ezaltal kul threadek egymastol fgtl operalhatnak a lista kul reszein. egy adott node lockja guardolja a link pointereket es a nodeban tarolt datat, tehat amikor traversalunk v modifoljuk a listat akkor tartanunk kell egy node lockjat amig nem acqoltuk a kov node lockjat; csak akkor releaselhetjuk az elozot (un. hand-over-hand locking v lock coupling)

[[13.2. PERFORMANCE CONSIDERATIONS]]
amikor a RL-t hozzaadtak Java 5-ben, akkor joval jobb contended perft nyujtott mint az intrinsic locking. sync primitiveknel a contended perf a scal kulcsa: ha tobb rsct forditunk a lock mgmtre es schedulingra akkor kevesebb jut az appra. egy jobb lock implnal kevesebb a sys call, ctx switch es a mem-sync traffic a shared mem buson
Java 6-ban improvoltak az intrinsic lock mgmt algot, hasonloan arra ami az RL-nel van, ezzel a scal gap jelentosen csokkent. Java 5-ben a RL throughputja lenyegesen jobb volt, Java 6-ban mar szinte egyforma (ebbol is latszik h az "X is faster than Y" stmtek rovid eletuek. perf es scal platform sensitivek: CPU, ccahe size, JVM characteristics befolyasoljak)

[[13.3. FAIRNESS]]
RL konstr ket lehetoseg: nonfair (default) v fair lock. fair lockot a threadek abban az orderben acqoljak ahogy requesteltek, a nonfair locknal viszont lehet barging (betolakodas): lockot requestelo thread a queuban waitelo threadek ele ugorhat amennyiben a lock a requestkor eppen available (Semaphorenal szinten lehet fair v nonfair acq ordering). nonfair RL-ek nem promotaljak a bargingot, csak nem preventaljak ha egy thread igy viselkedik. fair locknal egy ujonnan requestelo thread queuolodik ha a lockot egy masik thread tartja vagy ha vannak a lockra waitelo queueolt threadek; nonfair locknal a thread csakkor queueolodik ha a lock eppen tartva van. a polled tryLock() mindig bargol, meg fair lockokra is

miert nem akarjuk h minden lock fair legyen? fairnessnek jelentos perf ktge van, a thread suspend/resume miatt. gyak egy statistical fairness garancia (igeret arra h egy blocked thread eventually acqolni fogja a lockot) alt eleg es sokkal kevesbe ktges. bizonyos algok fair queuingen relyolnak, de ez ritka; alt a nonfair locking perf benefitje jobban megeri

perf test: HashMap bewrappelve fair ill nonfair RL-be: fairness throughput penaltyja majdnem ket nagysagrend

egy ok ami miatt egy barging lock annyival jobban teljesit heavy contention mellett h jelentos delay lehet a suspended thread resomolasa es tenyleges runja kozott. pl. thread A tartja a lockot es B thread keri uazt. mivel a lock busy, B thread suspended. amikor A releaseli a lockot, B resumeolodik es ujra megprobalhatja. de a kozbeeso idoben C thread requestelheti, acqolhatja sot releaselheti is a lockot mielott B thread egyaltalan befejezne a wakeupot. ez win-win: B thread nem kapja kesobb a lockot mint egyebkent kapna, C pedig joval korabban kapja meg, throughput++

fair lockok akkor muk a legjobban ha rel hosszabb ideig vannak tartva v h a lock requestek kozti mean time rel hosszu. ilyen korulmenyek kozott a barging altal nyujtott throughput elony (amikor a lock nincs tartva de egy eppen wakeupolo thread meg tudja szerezni) kevesbe valoszinu

intrinsic locking a default RL-hez hasonloan nem nyujt deterministic fairness garanciakat, de a statistical garanciak a legtobb esetre megfeleloek. Java spec nem kivanja meg h a JVM fair modon implja az intrinsic lockokat, es a production JVMek nem is teszik

[[13.4. CHOOSING BETWEEN SYNCHRONIZED AND REENTRANTLOCK]]
RL uazt a locking es mem semanticsot nyujtja mint az intrinsic locking, plisz timed lock wait, interruptible lock wait, fairness, non-block-structured locking. perfje is vmivel jobb. akkor a synchronized miert nem deprecated?

intrinsic locknak is megvannak az elonyei. ismeros es compact syntax, szamos letezo prg mar intrinsic lockingot hasznal, explicittel keverni confusing lenne. ha RL-nel elfelejtunk finallyban releaselni az veszelyes

RL olyan esetekben jo ahol az intrinsic lock nem praktikus; pl. ha az advanced featurejeit akarjuk kihaszn

Java 6-nal latott perf javulasok is synchronized mellett szolhatnak. mivel a synchronized a JVM resze, vegrehajthat optimizaciokat pl. lock elision thread-confined lock objkra, vagy lock coarsening a sync eliminalasara (ld.11.3.2); ezeket explicit lockokkal nem igazan lehet

[[13.5. READ-WRITE LOCKS]]
RL egy standard mutual excl lockot impl: egy idoben max egy thread tarthat egy RL-t. de a mutual excl gyakran erosebb req annal mint ami a data integrityhez szukseges, es emiatt a szuksegesnel jobban limitalja a concot. a mutual excl egy konzervativ locking strat ami preventalja a writer/writer es writer/reader overlapokat, de a reader/reader overlapokat is. a data structok alt "read-mostly"-k - mutablek es neha modifolodnak, de a legtobb access csak reading. ezekben az esetekben jo lenne enyhiteni a locking accesst es engedni h egy idoben tobb reader is accessalhasson. amig minden reader thread egy up-to-date allapotot lat a databol, es mas threadek ezalatt nem modifoljak a datat, akkor nincs gond. ezt teszi lehetove a read-write lock: egy rsct egyidejuleg tobb reader vagy egy darab writer accessalhat, de nem mindketto

RWL ket Lock objt exposol: az egyiket readre, a masikat writera. RWL altal guardolt data readelesehez eloszor a read lockot kell acqolni, modifolasahoz a write lockot. bar ket kulon locknak tunnek, valojaban egy integrated read-write lock obj ket viewjarol van szo

a read-write lockok altal impl locking strat tobb parh readert de csak egy writert engedelyez. mint a Lock, a RWL is tobbfele implt tesz lehetove, kul perf, scheduling garanciak, acq pref, fairness, locking semantics

read-write lockok multiproc sysben, read-mostly data structoknal jelentenek perf++; mas feltetelek mellett a komplexitasuk miatt rosszabban telj mint az excl lockok. mivel a RWL is Lock-ot hasznal, ezert konnyen kiswappolhato egy excl lockra ha a profiling azt mutatja h rosszabban teljesit

read es write lockok kozti interaction tobbfele implt tesz lehetove. impl options:
- release preference: amikor a writer releaseli a write lockot, es a readerek es a writerek is be vannak queuezva, akkor ki legyen a kedvezmenyezett?
- reader barging: ha readerek tartjak a lockot, de vannak waitelo writerek akkor az ujonnan erkezo readerek kapjanak accesst vagy a writerek mogott waiteljenek? ha megengedjuk h a readerek a writerek ele bargoljanak, az conc enhance, de writer starving kockazat
- reentrancy: a read es write lockok reentransak?
- downgrading: ha egy thread tartja a write lockot, akkor tudja acqolni a read lockot anelkul h releaselne a write lockot? ezaltal a writer "downgradelne" egy read lockra, mikozben nem engedne h mas writerek modifoljak a guarded rsct
- upgrading: read lock updgradelheto write lockra, mas waitelo readerekkel v writerekkel szemben preferalva? a legtobb read-write lock impl nem suportolja az upgradinget mert explicit upgrade oper nelkul DL-prone (ha ket reader egyszerre probal write lockra upgradelni, akkor egyikus sem fogja releaselni a read lockot)

ReentrantReadWriteLock reentrant locking semanticsot nyujt mindket lockra. ReentrantLockhoz hasonloan a RRWL is lehet nonfair (default) v fair. fair locknal a legregebb ota waitelo thread a preferalt; ha a lockot readerek tartjak es egy thread requesteli a write lockot, akkor tobb reader nem acqolhatja a read lockot amig a writer ki nem lett szolgalva, es nem releaseli a write lockot. nonfair locknal a threadek access sorrendje unspecified. writerrol readerre downgradeles megengedett; forditva nem (DL miatt)

ReentrantLockhoz hasonloan a RRWLnek is unique ownerje van, es csak az a thread releaselheti amelyik acqolta. Java 5-ben a read lock meg inkabb a Semaphore-hoz volt hasonlo, csak a readerek szamat tartotta nyilvan, az id-juket nem. Java 6-ban mar az is nyilvan van tartva h mely threadek kaptak meg a read lockot

read-write lockok tip javithatjak a conct, ha a lockok jell mersekelten hosszu ideig vannak tartva es az operek tobbsege nem modifolja a guarded rscket
public class ReadWriteMap<K,V> {
  private final Map<K,V> map; private final ReadWriteLock lock = new ReentrantReadWriteLock(); private final Lock r = lock.readLock(); private final Lock w = lock.writeLock();
  public V put(K key, V value) { w.lock(); try { return map.put(key, value); } finally { w.unlock(); //remove(), putAll(), clear() hasonloan
  public V get(Object key) { r.lock(); try { return map.get(key); } finally { r.unlock(); //tobbi read-only metodus hasonloan
RRWL-el wrappel be egy Map-et h safely shared lehessen tobb reader kozott, es preventalja a reader-writer es writer-writer conflictokat (valosagban a CHM perfje eleg jo ahhoz h azt hasznaljuk es ne ezt az approachot amennyiben egy concurrent hash-based mapre van szuksegunk; ez akkor lehet hasznos ha more conc accesstt akarunk nyujtani vmi alternativ Map implhez mint pl. LHM)

ReentrantLock-al bewrappelt AL vs RWL throughputja (abra alapjan az utobbi jobbnak tunik)