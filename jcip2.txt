Java Concurrency in Practice

[Chapter 2. Thread Safety]

threadsafe code: managing access to (shared, mutable) _state_
obj stateje: data amit a state varjaiban (pl. fieldek) tarol. dependent objk fieldjei is szamitanak, pl. HashMap stateje reszben magaban a HM-ben, reszben a Map.Entry objkban tarolodik
shared: tobb thread accessalhatja a vart. mutable: value az elettartam soran valtozhat
thread safety celja: data megvedese uncontrolled conc accesstol

ha egy state vart tobb mint egy thread accessalhat, es min 1 thread irhat is, akkor az accessalasahoz synchronization kell
"synchronization" magaba foglalja: synchronized, volatile, expl locks, atomic vars
1) ne shareljunk state vart threadek kozott 2) state var legyen immut 3) state var accessalasa legyen sync
OO technikak, pl. encaps, data hiding, immut, pontosan spec invariantok hasznosak threadsafetyhez is. conc codenal kulonosen vigyazni kell ha perf++ kedveert ezeket mellozzuk

threadsafe prg nem feltetlenul csak threadsafe classokbol all, es kizarolag threadsafe classokbol allo prg is lehet nem threadsafe
class csakkor lehet threadsafe ha encaps a sajat statejet

[[2.1. WHAT IS THREAD SAFETY?]]

correctness: class megfelel a specjenek
jo spec: meghat az obj statejere von invariantokat es az operationok (publ metodusok hivasa, publ fieldek irasa/olvasasa) hatasat leiro postconditionokat
class threadsafe, ha tobb threadbol accessalva is correcten viselkedik, fuggetlenul ezen threadek schedulalasatol; tovabba nem igenyel additional syncet a hivo fel reszerol. egy threadsafe class instance semmilyen operek vegrehajtasa eseten nem lehet invalid stateben

[[[2.1.1. Example: A Stateless Servlet]]]

a threadsafetyre gyakran nem azert kell figyelni mert mi magunk hasznalunk threadeket hanem a fw amivel dolgozunk, pl. servlet
class StatelessFactorizer implements Servlet { void service() {...
stateless: nincsenek fieldjei es nem hiv mas classok fieldjeire. a szamitasok eredmenyei kizarolag local varokban, amelyek csak az execelo thread stackjen vannak; a state nem sharelodik tobb thread kozott, olyan mintha kulonbozo instanceokat accessalnanak 
stateless objk threadsafek
servletek alt statelessek, threadsafety csak akkor issue ha egyik requestrol a masikra meg akarnak jegyezni dolgokat

[[2.2. ATOMICITY]]
elozo stateless servlethez hit counter hozzaadasa
class UnsafeCountingFactorizer implements Servlet { long count = 0; void service() { count++;...
nem threadsafe, bar 1 threades envben jol mukodik. ld. 1.fejezet pelda, ++ nem atomic, hanem read-modify-write, threadek szerencsetlen timingje eseten inkrementalasok elveszhetnek. race cond
(+ un. stale data problema is van vele, ld. 3.fej)

[[[2.2.1. Race Conditions]]]
race cond leggyakoribb esete check-then-act, amikor egy potentially stale observationon alapul a dontes h mit csinalunk kovetkezokent
race condot gyakran keverik az un data race-szel, ami akkor van ha egy shared nonfinal field accesse nincs syncelve (ld. 16.fej). UnsafeCountingFactorizerben mindketto van
IRL race cond: en es az ismerosom ket kavezo kozott setalgatunk egymast keresve, mert nem tudjuk pontosan melyikben beszeltuk meg a talalkozot. a problema: "not at the same time"; a ket hely kozti setaval eltelik vmennyi ido, ami alatt a rendszer stateje megvaltozhat (a masik ember pont ezalatt atjohet a masik helyrol oda ahol mi eddig voltunk), es ezaltal invalidalja az observationt
ez a check-then-act: observation (file nem letezik), action based on observation (file krealasa), de a ketto kozottt az observation invalidda valhat (vki is mas megkrealta a filet) es ez problema lehet (exception, overwrite, corruption)

[[[2.2.2. Example: Race Conditions in Lazy Initialization]]]
pl. az lenne a cel h csak egy instanceunk legyen es az obj initelese csakkor tortenjen meg amikor tenyleg szukseg van ra
class LazyInitRace { ExpensiveObj inst = null; ExpensiveObj getInst() { if(inst == null) { inst = new ExpensiveObj(); } return inst; (~singleton alap) 
race cond: A thread azt latja h inst null es ujat kreal, de egyidejuleg B thread is nullnak latja es o is ujat kreal
az UnsafeCountingFactorizerben levo race cond masfele: read-modify-write; transzformalja az obj statejet az elozo state fveben. pl. inkrementalashoz tudnunk kell az elozo valuet es gondoskodni kell rola h senki mas ne modositsa vagy hasznalja azt az erteket mikozben mi eppen updateljuk
race cond nem feltetlenul okoz failuret de a lehetoseg fennall

[[[2.2.3. Compound Actions]]]
a LazyInitRace es az UnsafeCountingFactorizer is olyan oper seqt tartalmazott aminek atomicnak kell lennie
A es B operek egymasra nezve atomicok az A-t execelo thread szemszogebol amennyiben egy masik thread execeli B-t, akkor vagy az egesz B lefutott vagy egyaltalan semmi nem futott le belole
thread safety erdekeben check-then-act (pl. lazy init) es read-modify-write (pl. increment) opereknek atomicnak kell lenniuk. ofoglalo neven ezek compound actionok: oper seqk amelyeket atomic kell execelni h threadsafek legyenek
class CountingFactorizer implements Servlet { AtomicLong count = new AtomicLong(0); void service() { count.incrementAndGet();...
AtomicLong biztositja h a counter statejet accessalo minden action atomic; es mivel a counter stateje most egyben a servlet stateje is, ezaltal a servlet threadsafe lesz

[[2.3. LOCKING]]
egy threadsafe state vart hozzaadva a servlethez meg tudtuk tartani a threadsafetyjet. mi van ha ket state vart szeretnenk?
tfh szeretnenk az utolso szamitas eredmenyet elcachelni (jobb cachelest ld. 5.6): meg kell jegyezni az utolso faktoralt szamot es a faktorait. AtomicReference? (obj 
ref threadsafe tarolasa)

class UnsafeCachingFactorizer implements Servlet { 
  AtomicReference<BigInteger> lastNumber; AtomicReference<BigInteger[]> lastFactors; 
  void service() {
    if(reqNr.equals(lastNumber.get())) resp = lastFactors.get();
	else lastNumber.set(reqNr); lastFactors.set(reqFactors); resp = reqFactors;

nem jo, bar az AtomicReferencek onmagaban threadsafek, a prgban megis van race cond. invariant: lastFactorsban levo szamok szorzata = lastNumber. mivel tobb var vesz reszt az invariantban, ezert ha az egyiket updateljuk akkor a tobbit is uabban az atomic operben kellene updatelni. ez itt nem teljesul, elofordulhat h egy masik thread pont a set-ek vegrehajtasa kozt vagy a get-ek vegrehajtasa kozt modosit bele

[[[2.3.1. Intrinsic Locks]]]
atomicity enforcolasa: synchronized (built-in locking mechanizmus)
sync block ket resze: lockkent szolgalo obj ref + a lock altal guardolt code block
sync method: shorthand az egesz metoduson ativelo sync blockra. a lock az az obj lesz amin a metodust invokoljuk (static sync metodus eseteben a class obj)
minden java obj lehet implicite lock: un. intrinsic lock vagy monitor lock. az executolo thread automatikusan acquireli a lockot mielott belep a sync blockba es automatikusan releaseli amikor kilep (akar normal modon akar exceptionnel). intrinsic lock megszerzesenek egyetlen modja az altala guardolt sync blockba belepes
intrinsic lockok mutexek tehat max 1 thread tarthatja oket; ha masik thread is probalja egyidejuleg megszerezni, akkor o blokkolodik amig az elso thread el nem engedi a lockot
tehat a sync blockok az adott lockra vonatkozoan atomic modon execelodnek
UnsafeCachingFactorizer javitasa: class SynchronizedFactorizer implements Servlet { sync service(); 
ezaltal a lastNumber es a lastFactors fieldeket a "this" guardolja. ez mar threadsafe, de perf-- mert igy nem tudja tobb kliens egyidejuleg hasznalni a servletet (ld. 2.5)

[[[2.3.2. Reentrancy]]]
intrinsic lockok reentrantok, tehat ha egy thread egy olyan lockot probal acqolni amit mar o maga tart, az sikeres. tehat a lockok per-thread es nem per-invocation alapon mukodnek (vs pl. POSIX pthreads). minden lockhoz tartozik egy owning thread es egy acq count; ha a count=0 akkor a lock unheld. ha egy thread acqolja a lockot, akkor o lesz az owner es count++. ha ugyano ujra acqolja, akkor megint count++, ha releaseli akkor count--, lock akkor szabadul fel ha megint count=0

reentrancy encapsulalja a locking behaviourt; enelkul pl.
class Widget { sync doSomething();
class LoggingWidget extends Widget() { sync doSomething() { super.doSomething(); }
mindket sync doSomething() metodus a Widget inst lockjat probalja acqolni
ha az intrinsic lockok nem lennenek reentrantok akkor a super.doSomething() hivas DL lenne mert ugy tekintene hogy a lockot mar tartja valaki

[[2.4. GUARDING STATE WITH LOCKS]]
lockok serialized accesst biztositanak az altaluk guardolt kodhoz, segitsegukkel exclusive access biztosithato a shared statehez (serialized itt a concurrent ellentete, nem a serialization!)
shared staten vegzett compound actionoknak atomicnak kell lennie; de bewrappelni csak az actiont egy sync blockba nem eleg; mindenutt kell ahol az erintett var accessalva (nem csak irva! ld. 3.1) van
ha egy mutable vart tobb thread accessalhat, akkor minden accesst hozza uaz a lock kell guardoljon (mint a servlet peldanal lastNumbert es lastFactort a servlet this-je)
egy obj fieldjeit nem szuksegszeruen kell h maga az obj intrinsic lockja guardoljon (csak convenience h ne kelljen explicit lock objkat krealni; bar confusing is lehet). obj lockjanak acqolasa nem gatolja h mas threadek is accessaljak magat az objt; azt gatolja h mas thread is acqolja a lockot
common locking gyakorlat h egy obj minden mutable statejet encapsulaljuk es ehhez minden accesst az obj intrinsic lockjara syncelunk (pl. Vector, sync coll classok)

pl. single threaded prg ami sok datat accessal. periodikusan snapshotolni akarjuk h ha megall akkor ne kelljen elolrol indulnia: TimerTask 10 percenkent fileba menti a prg allapotat. a TimerTask egy masik threadbol hivodik (amit a Timer managel), de a main thread is accessalja a snapshot datat; minden ilyen code pathnak syncelve kell lennie!

ha egy vart egy lock guardol azzal biztositjuk h a vart egyidejuleg csak egy thread accessalhatja. ha egy classnak tobb state vart erinto invariantjai vannak, akkor minden erintett vart uannak a locknak kell guardolnia; ld. syncelt factorizer servlet
ha minden metodust egyszeruen syncelunk az nem feltetlenul teszi a compound actionokat atomicka (ellenben liveness, perf problemakat okozhat, ld. syncelt factorizer servlet megint)
if(!vector.contains(element)) vector.add(element)
ez igy race cond, bar onmagaban a contains() es az add() is sync/atomic. tovabbi locking szukseges, ld. 4.4

[[2.5. LIVENESS AND PERFORMANCE]]
SynchronizedFactorizer threadsafe volt, de perf--. sync service() metodust egyszerre csak egy thread execelheti; servlet fw celja pont a reqk szimultan kiszolgalasa lenne, itt viszont a klienseknek varniuk kell ha egy req faktorizalas pont lassu. poor concurrency: nem rsc problema okozza hanem maga az app strukturaja

mo.: sync scope csokkentese, ne legyenek a belsejeben olyan hosszan futo operek amik a shared statet nem affectaljak 
class CachedFactorizer implements Servlet { ...
egy sync block vedi a check-then-act reszt ami ellenorzi h visszaadhatjuk-e a cached eredmenyt; egy masik pedig a cached number/factors updateleset
visszakerult tovabba az UnsafeCountingFactorizer-ben levo long counter; ennek a gettelesei szinten syncek. AtomicLong itt most felesleges, mert a sync gondoskodik az atomicitasrol
ez igy threadsafe, es reasonable balance a simplicity (teljes metodus syncje az egyszerubb) es a perf kozott
