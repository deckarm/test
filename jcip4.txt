Java Concurrency in Practice

[Chapter 4. Composing Objects]
eddig a threadsafety low level alapjai

[[4.1. DESIGNING A THREAD-SAFE CLASS]]
lehet threadsafe prgt irni ami a statejet public static fieldekben tartja, de encaps jobb
threadsafe class designja: obj statet alkoto varok azonositasa; state varokat megkoto invariantok azonositasa; obj statehez valo conc access policy letrehozasa
ha egy obj fieldjei mind primitivek akkor ezek alkotjak a statet. ha a fieldek kozt van ref mas objra akkor a referalt obj fieldjei is szamitanak (pl. LinkedList statejaban benne vannak a linked node objk statejei is)
synchronization policy: hogyan koord obj az accesst a statejehez anelkul h az invariantok es postconditionok serulnenek (doc)

[[[4.1.1. Gathering Synchronization Requirements]]]
class threadsafe ha invarjai conc access mellett is megtartanak: minel kisebb a stateje, annal egyszerubb. final fieldekkel szukithetjuk. immut objknak egyetlen stateje van

sok classnak vannak invarjai amelye validkent v invalidkent azonositanak allapotokat. long state spaceje MIN_VALUE es MAX_VALUE kozott van, de az alabbi class tovabbi constraintje h nem lehetnek neg ertekek
class Counter { long value = 0; sync long incr() { if(value = Long.MAX_VALUE) throw new IllegalStateException(); return ++value; }

opereknek lehetnek postcondjai, amelyek invalidahatnak egyes state transitionoket. pl. ha Counter stateje jelenleg 17, akkor a kov state csak 18 lehet. ha a kov state a jelenlegibol derived akkor az oper szuksegszeruen compound. de nem minden oper jelent state transition constraintet, pl. egy homersekletet tarolo var kov erteke nem fugg az aktualistol
invarok es postcondok altal a statekre vagy state transitionokre von constraintek synct/encapst igenyelhetnek. ha egy state invalid, akkor az alkoto state varokat encaps kell, kulonben client code elviheti az invalid statebe. ha egy opernek invalid state transitionjei vannak akkor atomicka kell tenni
classnak lehetnek invarjai amelyek tobb state vart constrainelnek. pl. number range classban (ld.4.3.3) state varok lower es upper boundra, constraint h lower < upper. az erintett varokat atomic kell fetchelni/updatelni, mert ha a ketto kozt releaseljuk a lockot akkor az obj invalid statebe mehet

[[[4.1.2. State-dependent Operations]]]
class invarok es metodus postcondok constrainelik az obj valid statejeit es state transitionjait. egyes objknak lehetnek metodusai state-based precondokkal is, pl. empty queuebol nem lehet removolni (state-dependent operek)
single threaded prgban ha precond nem teljesul akkor az oper fail; de conc prgban a precond kesobb igazza valhat
olyan oper krealasa, ami arra var hogy precond trueva valjon, lehet wait/notify-al is, de jobb lib classokkal pl. blocking queue, semaphore (ld 5, ld 14)

[[[4.1.3. State Ownership]]]
obj statejeben olyan data amit az obj ownol. pl. HashMap statejeben benne van a Map.Entry es egyeb internal objok stateje is
GC csokk a ref sharingbol szarmazo tip hibak lehetoseget (pl. mikor objt metodusnak adunk at azt C++-ban nagyon ovatosan kell)
ownership es encaps gyakran egybeesik; obj encapsolja az ownolt statet es ownolja az encapsulalt statet. ha egy mutable objra reft publisholunk akkor legjobb esetben is "shared ownership". class leggyakrabban nem ownolja a konstr/metodusai altal kapott objket, kiveve ha direkt ugy van tervezve (pl. sync coll wrapper factory metodusok)

coll classoknal gyakran "split ownership": coll ownolja a coll infrastr statejet, de a client kod ownolja a tarolt objkat. pl. ServletContext-ben van egy map-szeru obj container service, ahol servletek app objket set/gettelhetnek. a servlet container altal impl ServletContext obj threadsafe kell legyen mert tobb thread accessalja. servleteknek nem kell syncelniuk set/get hivasnal, de kellhet syncelniuk a ServletContextben tarolt objk hasznalatanal. ezeket az objkat az app ownolja, a servlet container tarolja az app szamara

[[4.2. INSTANCE CONFINEMENT]]
data encapsolasa objba a data osszess accesset confinalja az obj metodusaiba; ezt egy megfelelo lockinggal kombinalva nem threadsafe objk hasznalhatok threadsafe modon

obj confinalhato class instanceba (private class member), lexical scopeba (local var) vagy threadbe (obj atadhato metodusbol metodusba de csak uazon a threaden belul)

class PersonSet { private final Set<Person> mySet = new HashSet<>(); public sync void addPerson(Person p); public sync boolean containsPerson(Person p);
PersonSet stateje a HashSet, ami nem threadsafe, de private ezert confinalva van a PersonSetbe, es az ot accessalo ket code path mindegyike a PersonSet lockjat acqolja. Person threadsafetyjet nem tudjuk de ha mutable akkor tovabbi sync kell ha accessalni akarunk egy PersonSetbol retrievelt Persont. legjobb ha a Person threadsafe; kevesbe megbizhato ha a Person objkat lockkal guardoljuk es figyelunk h a clientek azt megfeleloen acqoljak. a locking nem csak az intrinsic lock lehet mint itt, mas-mas state varokat kulonbozo lock is guardolhat (ld. ServerStatus...)

JDK-ban jopar class van csak azert h nem threadsafe classokat threadsafe-e tegyen; pl. nem threadsafe basic coll classokhoz (ArrayList, HashMap) wrapper factory metodusok (pl. Collections.synchronizedList). decorator pattern: a wrapper obj synckent implja az osszes metodust es o fwdolja a reqket az underlying coll objnak

conf obj kipublisholasa a tervezett scopebol bug (iteratorok, inner classok reven indirekten is kipublisholodhat)

[[[4.2.1. The Java Monitor Pattern]]]
obj az osszes mutable statejet encapsulalja es a sajat intrinsic lockjaval guardolja (pl. Counter 4.1)

JDK classok is haszn, pl. Vector, Hashtable. egyszeru, de neha finer-grained locking kellhet (ld. 11)

intrinsic lock helyett masfajta lockkal, pl. private field obj is lehet guardolni. elony h a lock encapsolva van; vs public locknal a client kodnak is reszt kell vennie a megfelelo syncben

[[[4.2.2. Example: Tracking Fleet Vehicles]]]
minden vehiclet egy String id azonosit es van egy x,y MutablePoint locationje 
class MonitorVehicleTracker { 
  private final Map<String, MutablePoint> locations; 
  public MonitorVehicleTracker(Map<String, MutablePoint> locations) { this.locations = deepCopy(locations);
  public sync Map<String, MutablePoint> getLocations { return deepCopy(locations); } 
  public sync MutablePoint getLocation(String id) { if(locations.get(id) !=null) return new MutablePoint(loc);}
  public sync void setLocation(...);
  private static Map<String, MutablePoint> deepCopy(Map<String,MutablePoint> m) { Map<String, MutablePoint> result = new HashMap<>(); for(String id: m.keySet())
    result.put(id, new MutablePoint(m.get(id))) ; return Collections.unModifiableMap(result);

pl. MVC GUI-nal egy view thread es tobb updater thread kozott sharelodhet a data. bar a MutablePoint nem threadsafe, a tracker class igen; sem a map, sem a benne levo pointok nem publisholodnak, mindig copyt ad vissza. deepCopy() nem csak bewrappeli a Mapet, mert az csak magat a collt vedene, a benne levo objkat a caller ettol meg modosithatna (HashMap copy constral valo feltoltese sem lenne jo, mert csak a pointok refjei masolodnanak nem maguk a point objk)

a copyzas altalaban nem perf-- csak ha a set nagyon nagy; illetve mivel a deepCopy() sync metodusbol hivodik, egy hosszu masolas feltarthatja a futast. valamint getLocations() eseteben a returnolt coll contentje nem valtozik meg, meg ha az underlying locationok valtoznak is; requirementtol fugg h ez igy OK-e

[[4.3. DELEGATING THREAD SAFETY]]
ha egy composite obj componentjei threadsafek, az neha onmagaban eleg ahhoz h a composite is az legyen, neha nem. pl. CountingFactorizer (2.2.3) egy db fieldje threadsafe AtomicLong counter volt, es mivel annak statejere nem voltak tovabbi constraintek, igy maga a class is az volt: a class delegalta a thread safety responsibilityjeit az AtomicLongnak (ha a counter nem lett volna final, es a ref egy masik AtomicLong objra valthatott volna akkor gondoskodni kellett volna rola h az osszes thread lassa ezt a valtozast, es ne legyen race cond)

[[[4.3.1. Example: Vehicle Tracker Using Delegation]]]
MutablePoint helyett immutable Point (x,y fieldek finalok); szabadon sharelheto/publishelheto, nem kell a locationokat copyzni returnoleskor
sima Map helyett threadsafe ConcurrentHashMap alkotja a class statejet; keyek es valuek is immut; nem kell tovabbi sync
class DelegatingVehicleTracker {
  private final ConcurrentMap<String, Point> locations;
  private final Map<String, Point> unmodifiableMap;
  public DelegateVehicleTracker(Map<String, Point> points) { locations = new ConcurrentHashMap<>(points); unmodifiableMap = Collections.unmodifiableMap(locations)
  public Map<String, Point> getLocations() { return unmodifiableMap;
  public Point getLocation(String id) { return locations.get(id);
  public void setLocation(...);
a MonitorVehicleTracker a locations snapshotjat returnolte, ez viszont egy unmodifiable de "live" viewt; ha thread A getLocations()-t hiv majd thread B modosit egy locationt akkor a valtozas latszik az A-nak returnolt mapben. ha valtozatlan viewt szeretnenk akkor a locations shallow copyjat kell returnolni; mivel a map elemei itt immutablek, ezert csak a map strukturajat es nem tartalmat kell copyzni
public Map<String, Point> getLocations() { return Collections.unmodifiableMap(new HashMap<String, Point>(locations));

[[[4.3.2. Independent State Variables]]]
eddigi peldakban csak egy darab threadsafe state varnak delegaltunk; tobbnek is lehet amennyiben fgtlek, azaz a classnak nincsenek rajuk von invarjai
class VisualComponent { private final List<KeyListener> keyListeners = new CopyOnWriteArrayList<>(); private final List<MouseListener> mouseListeners = new CopyOnWriteArrayList<>(); add()/remove()
ket threadsafe list, fgtlek ezert a class delegalhatja nekik a threadsafetyt

[[[4.3.3. When Delegation Fails]]]
legtobb composite classban vannak invariantok
class NumberRange {
  private final AtomicInteger lower = new AtomicInteger(0); private final AtomicInteger upper = new AtomicInteger(0);
  public void setLower(int i) { if(i > upper.get()) throw exc; lower.set(i);
  public void setUpper(int i) { if(i < lower.get()) throw exc; upper.set(i);
nem threadsafe; nem preserveli a lower <= upper invart. megprobalja, de rosszul, a set-ekben levo check-then-actokban nincs megfelelo locking. ha egy thread setLower(5)-t egy masik thread pedig egyidejuleg setUpper(4)-et hiv akkor szerencsetlen timing eseten mindket check teljesul, es (5,4) all elo
threadsafetyhez maintainelni kell az invarokat; pl. common lockkal guardolni lowert es uppert. publisholasukat el kell kerulni h a clientek se sertsek meg az invarokat
ha classnak compound actionjai vannak, delegation nem eleg; lockinggal kell biztositani h ezek az actionok atomicok legyenek; hacsak az egesz compound action nem delegalhato le a state varoknak
ha a state varok fgtlek es nincsenek olyan operek amik invalid state transitiont okozhatnak akkor a threadsafety ledelegalhato a state varoknak
(~3.1.4-ben latott rulehoz: state var csak akkor lehet vol, ha nem vesz reszt invarban mas state varokkal)

[[[4.3.4. Publishing underlying state variables]]]
ha threadsafetyt az obj state varjainak delegaljuk akkor a publisholasuk lehetosege is az invarjaiktol fugg. pl. Counter class value fieldje csak poz erteku lehet; ha public akkor clientek elronthatjak. de pl. homerseklet var publisholasanal nincs ilyen gond (mutable varok publisholasa ettol fgtl nem jo otlet, bar nem feltetlenul okoz threadsafety problemat)
ha state var threadsafe, nem vesz reszt invarokban amik megkotik az erteket, es nincsenek prohibited state transitionjei, akkor safely publisholhato. pl. 4.3.2-beli keyListeners/mouseListeners

[[[4.3.5. Example: Vehicle Tracker that Publishes Its State]]]
most mutable de threadsafe pointokat haszn
class Safepoint
  private int x,y;
  private SafePoint(int[] a) {this(a[0], a[1]);
  public SafePoint(SafePoint p) { this(p.get());
  public SafePoint(int x, int y) { this.x = x; this.y = y;
  public sync int[] get() { return new int[] {x,y};
  public sync void set(int x, int y) {...
getter egyszerre returnoli x,y-t. private constr azert van h elkeruljuk a this(p.x,p.y) copy constrbol szarmazo race condot 

veh tracker ami threadsafety problema nelkul publisholja a mutable statejet
class PublishingVehicleTracker {
  private final Map<String, SafePoint> locations;
  private final Map<String, SafePoint> unmodifiableMap;
  public PublishingVehicleTracker(Map<String,SafePoint> locations) { this.locations = new ConcurrentHashMap<>(locations); this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
  public Map<String,SafePoint> getLocations() { return unmodifiableMap;
  public SafePoint getLocation(String id) { return locations.get(id);
  public void setLocation(String id, int x, int y) { ... locations.get(id).set(x,y);
class delegalja a threadsafetyt a ConcurrentHashMapnek, de most a pointok nem immutok hanem threadsafe mutableok. getLocations() unmodif copyt ad vissza. callerek megvaltoztathatjak egy veh locationjet a mapbol returnolt SafePoint modositasaval. ez megint "live" view a maprol. a class igy threadsafe, de ha pl. lennenek plusz constraintek a valid location ertekekre akkor gond lehetne

[[4.4. ADDING FUNCTIONALITY TO EXISTING THREAD-SAFE CLASSES]]
sok olyan lib class van ami szinte mindenre jo ami nekunk kell; uj oper hozzaadasnal figyelni kell threadsafetyre
pl. threadsafe List-et szeretnenk amiben van put-if-absent is; sync list implkben van add() es contains(), ezeket kell atomic osszerakni (nem atomic esetben lehet h ket thread is absentnek latna uazt az elemet egyidejuleg, es mindketten hozzaadnak)
legjobb lenne magaba az original classba berakni az uj opert de ezt nem mindig lehet
class extension is lehetseges
class BetterVector<E> extends Vector<E> { public sync putIfAbsent(E e) {...
more fragile mert a sync igy tobb sourceon ivel at. ha pl. az underlying classban masik lockot kezdenek el hasznalni akkor a subclass eltorhet

[[[4.4.1. Client-side Locking]]]
Collections.synchronizedList()-el bewrappelt ArrayList-nel se az orig class kiegeszitesevel, se extensionnal nem lehet mert nem is tudjuk h milyen List returnolodik a wrapper factorybol. helper classba rakott extension
class ListHelper<E> { public List<E> list = Collections.synchronizedList(new ArrayList<E>()); public sync boolean putIfAbsent(E e) {...
ez igy nem jo, mert a putIfAbsent() a ListHelper lockjara syncel mig maga a list field nem erre

mo client-side/external locking _uarra_ a lockra. pl. Vector es a sync wrapper collok tamogatjak, a Vector illetve a wrapper (nem a wrapped!) coll instrinsic lockjaval
class ListHelper<E> { public List<E> list = Collections.synchronizedList(new ArrayList<E>()); public boolean putIfAbsent(E e) {sync(list)...
ez meg inkabb fragile mert a sync itt unrelated classokon ivel at
(~ class extension: derived class behaviourjet couplolja a base class implhoz. class extension serti az impl encapst, client-side locking serti a sync policy encapst)

[[[4.4.2. Composition]]]
class ImprovedList<T> implements List<T> {
  private final List<T> list;
  public ImprovedList(List<T> list) { this.list = list;
  public sync boolean putIfAbsent(T x) {...
  public sync void clear() { list.clear(); //tobbi List metodus uigy
delegalja a List opereket egy underlying List instancenak (coll wrapperekhez hasonloan feltetelezi azt h miutan a konstr atvett egy listat, a client a tovabbiakban azt csak az ImprovedList-en keresztul accessalja)
sajat intrinsic lockjat hasznalja, nem erdekes h az underlying List threadsafe-e. ez lehet kis perf-- de kevesbe fragile

[[4.5. DOCUMENTING SYNCHRONIZATION POLICIES]]
class thread safety garanciait a clientjei, sync policyjat a maintainerei szamara kell(ene) docolni
pl. SimpleDateFormat nem threadsafe, de JDK 1.4-ig ez nem volt javadocban leirva

[[[4.5.1. Interpreting Vague Documentation]]]
egyes fontos ifacek threadsafety garanciairol nem sok van ledocolva, pl. ServletContext, HttpSession, DataSource. container v DB vendor adja az implt, mi nem feltetlenul latjuk; vmint nem akarunk egy bizonyos implre hagyatkozni, hanem a standard szintjen szeretnenk tudni h mi van

gyakran tippelnunk kell, megprobalva az implementalo helyebe kepzelni magunkat. pl. okkal feltetelezhetjuk h a servlet container altal kozzetett ServletContext, HttpSession objkat tobb thread akarja conc accessalni, single threadedben nem sok ertelme lenne; ezert az objk threadsafek kell legyenek. ez ugyan nincs leirva, de reasonable assumption; vmint az official spec/tut peldakban semmi nem utal client-side lockingra
a ServletContextbe/HttpSessionbe setAttribute()-al berakott objkat a webapp ownolja nem a servlet container. a servlet spec nem ir a shared attrokra von semmilyen koord mechanizmusrol; tehat a container altal a webapp szamara storeolt attrok threadsafe v eff immut kell legyenek. ha csak storeolasrol lenne szo akkor szoba johetne lockolas is amikor az app code accessalja oket, de mivel a container serializalhatja is az objkat a HttpSessionba replication/passivation cellal es a container nyilvan nem ismerheti a mi lock protocolunkat, ezert threadsafenek kell lenniuk

JDBC DataSource (reusable data connk poolja) hasonlo eset; single thread app eseten nem sok ertelme lenne. tehat bar a spec nem irja h DataSource threadsafe lenne, okkal felt h DataSource.getConnection() nem igenyel client-side lockingot. de magukra a Connection objkra ez nem von; ha egy Connectiont obtainelo activity tobb threaden is ativel, akkor neki kell garantalnia h a Connectionhoz valo access megfeleloen syncelve (alt a legtobb app egy threadbe confinalja Connectiont)