Java Concurrency in Practice

[Chapter 6. Task Execution]
task: abstract, discrete work unit

[[6.1. EXECUTING TASKS IN THREADS]]
elso lepes a task boundaryk azonositasa. idealis esetben a taskok fgtlek, ami segiti a parh feldolgozhatosagot
server appok jo throughputot/responsivenesst kell nyujtsanak. overload esetben ne essenek ossze, hanem graceful degr. ebben segitenek a jol megval task boundaryk + jo task exec policy (6.2.2)
legtobb server appnal task boundaryk a client requestek. pl. mail servernel az egyes messagek processalasa nem befolyasolja egymast

[[[6.1.1. Executing Tasks Sequentially]]]
80-as porton erkezo http reqk a taskok, seq feldolg
class SingleThreadWebServer { main() { ServerSocket s = new ServerSocket(80); while(true) { Socket conn = s.accept(); handleReq(conn);
gyenge perf, mert egyszerre csak egy reqt tud feldolg. a main thread alternal a conn acceptek es a req processingek kozt. amig egy reqt processal addig az uj connoknak varniuk kell, mig ujra nem hiv accept()-et
web req feldolg soran pl. IO (file, DB) lehet ami blokkolhat; single threaded servernel ezek komoly delayt okozhatnak, ill a CPU is idle amig az egyetlen thread IO-ra var
servereknel a single thread ritkan jo; csak ha keves/hosszu task van, vagy csak egy client ami egyidejuleg csak egy reqt kuld, de ez ritka. neha megis ez az egyszerubb/safety++ jelenthet, pl. GUI fw (ld 9)

[[[6.1.2. Explicitly Creating Threads for Tasks]]]
minden reqhez uj thread
class ThreadPerTaskWebServer { main() { ServerSocket s = new ServerSocket(); while(true) { final Socket conn = s.accept(); Runnable task = new Runnable() { run() { handleReq(conn);}}; new Thread(task).start();
main thread itt is alternal a conn acceptek es a req processingek kozt, de minden connhoz uj threadet kreal, nem a main threadben processalja
1) a main varhatja a kov connt; kov conn acceptalodhat mielott az elozo req processalasa befejezodik, resp++ 2) taskok parh processalodhatnak, throughput++ lehet ha tobb CPU van 3) a task kezelo kod threadsafe kell legyen mert tobb taskra is conc invokolodhat
mersekelt loadnal ez jobb mint a seq. amig a req erkezesi arany nem nagyobb mint a server feldolg kapac addig resp/throughput++

[[[6.1.3. Disadvantages of Unbounded Thread Creation]]]
prod envben a thread-per-task hatranyai, ha sok thread van
- thread krealasnak ktge van, sok threadnel rsc igenyes, latency++ is lehet
- threadek rsc (foleg mem) igenyesek, thread#>CPU# akkor idle threadek foglaljak a memet, GC-t okozhatnak, egyeb perf--
- krealhato threadek szamara (platformfuggo) limit, ha ezt elerjuk akkor OutOfMemoryError
egy bizonyos pontig thread++ => throughput++, de azon felul csak lassitjak a systemet, ill heavy live traffic loadtol akar crashelhet is. jobb ha app szintjen limitaljuk h mennyi threadet krealhat

[[6.2. THE EXECUTOR FRAMEWORK]]
task: luw. thread: taskok async futtatasat teszik lehetove. seq futtatas es task-per-thread futtatas limitjeit lattuk
Executor iface: task exec abstraction
public interface Executor { void execute(Runnable command);
executor fw: decouplolja task (Runnable) submissionjat az exectol, lifecycle support, app mgmt/monitoring, stats. p/c-n alapul ahol a task submittolo activityk a p-k es az execelo threadek a c-k

[[[6.2.1. Example: Web Server Using Executor]]]
class TaskExecutionWebServer { private static final Executor exec = Executors.newFixedThreadPool(100); main() { ... exec.execute(task); 
egyebkent minden mas pontosan uaz mint a ThreadPerTaskWebServer volt
hardcoded thread krealas helyett executorral. a req handling task submissionja decouplolva van az execelesetol (az exec configolas tortenhet deployment idoben). executor implja kicserelheto, pl. csinalhatunk olyat ahol az execute() torzse new Thread(r).start(), ami egyenerteku ThreadPerTaskWebServer-el, vagy r.run() egyenerteku SingleThreadWebServer-el

[[[6.2.2. Execution Policies]]]
submission/exec decoupling reven konnyen tudjuk spec, majd kesobb megvalt taskok egy csoportjanak execution policyjat
mely threadben lesz a task execelve, milyen sorrendben (FIFO, LIFO, prio), mennyi task futhat conc, mennyi lehet exec queueban pending, rejectelt taskot mi alapjan valasztjuk, exec elott/utan milyen actionok stb
celja a rsc/requirement mgmt

[[[6.2.3. Thread Pools]]]
worker threadek homogen poolja + work queue az execelendo taskokkal. worker thread felvesz es execel egy taskot a queuebol majd visszamegy es var a kov taskra
thread-per-taskhoz kepest elonyok: thread reuse, uj thread krealasabol szarmazo latency++ kikusz ezaltal resp++, pool size megfelelo hangolasaval egyszerre lehet jo CPU kihaszn es outofmem elkerules

Executors static factory metodusok
- newFixedThreadPool: submittolt taskoknak megfeleloen krealja a threadeket amig el nem eri a pool sizet, amit onnantol tartani probal (akkor ad hozza uj threadet ha egy masik thread meghal)
- newCachedThreadPool: (...kicsit zavaros leiras...?) nem limitalja a pool sizet
(ezek a factoryk ThreadPoolExecutor instanceot adnak vissza, amikkel specialisabb executorokat lehet krealni, ld 8)
- newSingleThreadExecutor: egy worker threadet kreal, ha ez meghalna akkor kreal ujat; a taskok a queue altal meghat order szerint processalodnak (FIFO, LIFO, prio). objk confinalva a task threadbe, mem writeok lathatoak a kesobbi taskok szamara, akkor is ha a worker thread menet kozben kicserelodik
- newScheduledThreadPool: fix size, delayed/periodikus task exec, ~Timer (ld 6.2.5)

[[[6.2.4. Executor Lifecycle]]]
JVM akkor exitel ha minden nondaemon thread megallt, tehat ha pl. nem shutdownolunk egy executort akkor a JVM sem tud exitelni
mivel az Executor async processalja a taskokat, a stateje bmely idopillanatban nem egyertelmu; lehetnek benne completed, running, queued taskok. shutdown terjedhet gracefultol (befejezzuk amivel fogl de ujat mar nem veszunk fel) az abruptig (folyamatban levoket is megprobalja cancelezni)

ExecutorService iface: Executor-t extendalja, lifecyce metodusok (shutdown(), shutdownNow(), awaitTermination() stb)
lifecycle statek: running, shutting down, terminated. ExecutorService running stateben krealodik, shutdown() graceful, shutdownNow() abrupt. shutdownolodott ExecutorServicenek kuldott taskokat a rejected exec handler kezeli (ld 8.3.3) ami vagy silent discardolja a taskot vagy RejectedExecutionExceptiont dob. ha minden task completed, akkor az ExecutorService terminated statebe kerul. shutdown() utan kiadott awaitTermination()-al sync shutdown hatasa keltheto (ld 7)

class LifecycleWebServer  {
  private final ExecutorService exec = ...
  public void start() { 
    ServerSocket s = new ServerSocket(80);
	while(!exec.isShutdown()) {
	  try { final Socket conn = s.accept(); exec.execute(new Runnable() { run() { handleReq(conn); 
	  catch(RejectedExecutionException e) { if(!exec.isShutdown()) { log()...
  public void stop() { exec.shutdown();
  void handleReq(Socket conn) { if(isShutdownReq(connReq)) { stop(); } else dispatchReq(connReq);
shutdownolhato prgbol (stop()) vagy spec client shutdown req-el
	  
[[[6.2.5. Delayed and Periodic Tasks]]]
Timer: deferred (100 ms mulva) es periodic (minden 10 ms-ban) taskok execelese
Timer csak abszolut idot tam ami gond lehet system clock valtasnal, ScheduledThreadPoolExecutor relativet. Timer csak egy threadet kreal, ha egy TimerTask tul sokaig fut, az befolyasolhatja mas TimerTaskok timingjet (pl. ha egy recurring tasknak 10 ms-kent kellene futnia, egy masik task viszont fut 40 ms-ig, akkor miutan a masodik veget ert, akkor az elso (fuggoen attol h fixed rate v fixed delay) vagy 4x lefut gyors egymasutanban vagy teljesen kimarad 4 lefutasa). scheduled thread pooloknal a tobb thread miatt nincs ilyen gond

Timer nem kezeli ha TimerTask unchecked exct dob hanem terminalodik; a mar beschedulalt de meg nem execelt TimerTaskok sosem fognak lefutni (ld. 7.3, thread leakage)
class OutOfTime { main() { timer.schedule(new Throwtask(),1); SECONDS.sleep(1); timer.schedule(new ThrowTask(),1); SECONDS.sleep(5);
class Throwtask extends TimerTask { run() { throw new RuntimeException();
azt varnank h 6 secig fut majd exitel, de valojaban 1 sec utan terminal IllegalStateException("timer already cancelled")-el

sajat scheduling serviceben hasznalhato DelayQueue: BQ impl ami ScheduledThreadPoolExecutor funkciot nyujt; Delayed objk (delay timejuk van) colljat manageli; a queuebol csakkor takelheto egy elem ha a delaye mar lejart; a returnolt objk delay time szerint orderelve

[[6.3. FINDING EXPLOITABLE PARALLELISM]]
Executor taskjai Runnablek. legtobb server appban a task boundaryk az egyes client reqk, desktop appokban ez nem annyira egyertelmu. single client reqben is adodhat parhuzamositasi lehetoseg
browser app page rendering (HTML to buffer) reszet fogjuk alakitani. tfh csak text markup+imgk vannak benne

[[[6.3.1. Example: Sequential Page Renderer]]]
legegyszerubb: barmilyen elem jon (text v img) azt rakjuk be a bufferbe. sokaig tarthat amig minden text kirenderelodik
szinten seq de kicsit jobb: eloszor a text elemeket rendereljuk, imgk helyen placeholderek, aztan meg egyszer vegigmegyunk a docon az imgk fedolgozasahoz
img letoltes tobbnyire IO-ra varast jelent ami alatt a CPU nincs kihaszn

[[[6.3.2. Result-bearing Tasks: Callable and Future]]]
a legtobb task deferred. DB query, rsc fetcheles networkrol, szamitasok. ezekre Callable jobb mint Runnable; tud erteket returnolni (ha nincs ra szukseg akkor Callable<Void>), checked exct dobni. Runnablet is bele tudjuk wrappelni
taskok alt finitek. Executorral execelt taskok lifecycleja: created, submitted, started, completed. submitted de meg nem started taskok cancellalhatok, started taskok akkor cancellalhatoak ha interruptra tudnak reagalni (ld. 7). Future repr a task lifecyclejat
Future.get() viselkedese task statetol fugg; azonnal returnol vagy exct dob ha task mar completed; blokkolodik ha a task meg nem completed
ExecutorService submit metodusai Futuret returnolnek; ily modon Runnablet/Callablet tudunk submittolni egy executornak es visszakapunk egy Futuret amibol ki tudjuk gettelni az eredmenyt vagy cancellalni a taskot. FutureTask (Futuret impl) direktben is krealhato egy Runnablehoz/Callablehoz (AbstractExecutorService.newTaskFor(Callable))
Runnable/Callable safely published a submitting threadbol az executing threadbe. Future eredmenye is safely published a szamitast vegzo threadbol a gettelo threadbe

[[[6.3.3. Example: Page Renderer with Future]]]
ket taskra osztjuk, az egyik rendereli a textet, a masik letolti az imgket (az egyik CPU a masik IO bound, ez meg egy CPU-nal is improvement lehet)

class FutureRenderer {
  void renderPage(CharSequence source) {
    List<ImageInfo> imageInfos = scanForImageInfo(source);
	Callable<List<ImageData>> task = new Callable<>() { public List<ImageData> call() { for(imageInfos) result.add(imageInfo.downloadImage()); return result; }};
    Future<List<ImageData>> future = executor.submit(task); 
	renderText(source);
    try { List<ImageData> imageData = future.get(); renderImages(imageData); } catch(InterruptedException e) { Thread.currentThread().interrupt(); future.cancel(true);

Callable tolti le az imgket es submitolja egy ExecutorService-nek; ez egy Futuret ad vissza, a main prg ebbol getteli az eredmenyt amikor a megfelelo pontra er (ha szerencsenk van addigra kesz is lesz a letoltes; ha nincs akkor legalabb lesz egy kis head startunk azaltal h mar elkezdtuk)
a get() state-dependent, ezert a hivonak nem kell a task statejet ismerni; a submission es retrieval kozti safe publish pedig threadsafe-e teszi
text rendereles es img letoltes itt mar conc megy; de jobb lenne ha nem kellene az osszes img letolteset megvarni, hanem minden letoltott img rogton kirajzolodna

[[[6.3.4. Limitations of Parallelizing Heterogeneous Tasks]]]
ket ember hatekonyan tud mosogatni, az egyik mos a masik szarit, de scalability nem jo: tovabbi embereket nem lehet ugy odaallitani h magat a munkafolyamatot ne kelljen atalakitani. eltero task sizeok is gondot jelentenek: pl. ket taskot elosztunk ket worker kozott, de az aranyuk 90-10, akkor ez csak 9% javulast jelent. workerek kozti koord overheadjevel is szamolni kell
FutureRendererben ket task van, de ha a text render sokkal gyorsabb mint az img letoltes akkor a perf nem sokkal jobb mint a seq valtozatnal, viszont komplikaltabb a kod
heterogen taskok parhuzamositasa nem mindig terul meg; inkabb nagyszamu fgtl, homogen task eseteben jo

[[[6.3.5. CompletionService: Executor Meets BlockingQueue]]]
ha van egy csomo taskunk amiket submittolunk egy executornak, akkor folyamatosan pollozhatjuk a Future-okat 0 timeouttal; de ennel jobb a completion service
CompletionService : Executor + BQ. Callable taskokat submittolhatunk neki, es take/poll metodusokkal retrievelhetjuk a Future resultokat
ExecutorCompletionService konsr BQ-t kreal a completed taskoknak. task completionkor FutureTask.done() hivodik; a task a submittolasakor itt QueueingFuture-al lesz bewrappelve, ami a FutureTask subclassa es a done()-ja a BQ-ba rakja az eredmenyt. take()/poll() a BQ-nak delegalnak, blokkolnak ha az eredmeny nem elerheto

[[[6.3.6. Example: page renderer with CompletionService]]]
minden img letoltesehez kulon task, amiket threadpoolban execelunk. igy seq helyett parh letoltes, time--. eredmenyek CompletionService-bol retrievelese resp++
class Renderer {
  void renderPage(CharSequence source) {
	List<ImageInfo> imageInfos = scanForImageInfo(source);
	CompletionService<ImageData> completionService = new ExecutorCompletionService<>(executor);
    for(imageInfo) { completionService.submit(new Callable<>() { public ImageData call() { return imageInfo.downloadImage();
    renderText(source);
    try { for(imageInfo) { Future<ImageData> f = completionService.take(); ImageData imageData = f.get(); renderImage(source); }} catch(InterruptedException e) { Thread.currentThread().interrupt();
	
tobb ExecutorCompletionService osztozhat egy kozos Executoron. CompletionService ilyen modon taskok egy batchjehez tartozik (uugy mint ahogy a Future egy taskhoz); nyilvantartva h mennyi taskot submitteltunk neki es mennyi completed eredmenyt kaptunk, tudjuk h mikor ertunk a batch vegere

[[[6.3.7. Placing Time Limits on Tasks]]]
neha ha egy activity bizonyos idon belul nem completed akkor abandonolhato. pl. ha kulso serverrol nem sikerul lefetchelni a hirdetest 2 sec alatt, akkor vmi defaulttal helyettesitjuk, hogy resp legyen
Future<Ad> = exec.submit(new FetchAdTask()); renderPageBody(); try { ad = f.get(timeLeft, NANOSECONDS); } catch(TimeoutException e) { ad = DEFAULT_AD; f.cancel(true);
Future.get() timed verzioja returnol ha megvan az eredmeny, TimeoutExceptiont dob ha adott idon belul nincs meg
ha timed task kifut az idobol akkor le kell allitani h ne foglaljon rscket. ha Future.get() TimeoutExceptionnel er veget akkor tudjuk cancelezni (true azt jelenti h a futo task threadje interruptolhato)

[[[6.3.8. Example: A Travel Reservations Portal]]]
elozo fej altalanositasa tetszoleges szamu taskra. travel portal, ami kulonbozo forrasokbol fetcheli az adatait; nem a leglassabban valaszolohoz igazitjuk a mukodest, hanem csak azt az infot displayeljuk ami time limiten belul megerkezik
kulonbozo forrasoktol fetcheles jo task boundary. lehetne n taskot krealni, submittalni oket threadpoolnak, retainelni a Futureokat es timed get()-ekkel kifetchelni az eredmenyeket; konnyebb az invokeAll(), ami taskok colljat veszi at es Futureok colljat returnol; a ket coll iter orderje megegyezik. timed verzioja akkor returnol ha minden task completed, a hivo thread interruptolt vagy a timeout lejart. a timeout lejartakor nem completed taskok cancellalodnak. az invokeAll() vegen minden task vagy completed vagy cancelled, hivo fel get()/isCancelled()-el allapithatja meg h melyik
