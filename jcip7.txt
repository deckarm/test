de nem minden blocking metodus reagal igy az it-re; ha egy thread sync IO-ra vagy intrinsic lockra varva blokkol akkor az it hatasa csak annyi h beallitja a thread it statusat. a nem-intteruptolhato tevekenyseg kozben blokkolt threadek neha "meggyozhetoek" arrol h megis alljanak meg, de ez fugg a blokkolodas okatol
sync socket IO (java.io): InputStream.read() es OutputStream.write() nem reagalnak it-re, de ha bezarjuk magat a socketet akkor a blokkolodott thread SocketExceptiont dob
sync IO (java.nio): InterruptibleChannel-re varo thread it-re valaszkent ClosedByInterruptException-t dob es bezarja a channelt (ezaltal a channelre varo osszes tobbi thread is ClosedByInterruptException-t dob). maganak az InterruptibleChannelnek a closolasara az eppen channel operationban blokkolt threadek AsynchronousCloseException-t dobnak
async IO Selectorral: ha egy thread Selector.select()-ben van blokkolva, akkor close() vagy wakeup() hivasra returnolodik
lock acq: ha egy thread intrinsic lockra varva blokkolodik akkor nem tehetunk semmit azon kivul h megprobaljuk elerni h hozzaferjen a lockhoz es eljusson egy olyan allapotba ahol meg tudjuk szolitani. de az explicit Lock classban van lockInterruptibly() metodus ami lehetove teszi az egyszerre lockra varast es it-re figyelest

nonstandard cancel encapsulalasa
class ReaderThread extends Thread {
private final Socket socket; private final InputStream in;
public void interrupt() { try { socket.close(); } catch(IOException ignored) {} finally {super.interrupt();}
public void run() { try { in.read(), store to buffer } catch(IOException e) { //allow thread to exit
sync olvas a socketrol es bufferbe menti az erkezo datat. ugy overridolja a Thread.interrupt()-ot h egyreszt bezarja a socketet masreszt standard it-t is kuld; igy ha it-t kap akkor mindenkeppen felbeszakitja amit csinal, akar a read()-ben, akar egy interuptolhato blocking metodusban van blokkolodva

[[[7.1.7. Encapsulating nonstandard cancellation with newtaskFor]]]
ReaderThreadben latott mo finomithato ThreadPoolExecutor.newTaskFor() segitsegevel; factory metodus ami a taskot repr Futuret krealja, RunnableFuture-t returnol amit FutureTask impl

Future.cancel() overridolhato; cancellalhatunk benne it-re nem reagalo activityket is
hosszu pelda: overridolt Future.cancel()-ben bezarjuk a socketet es super.cancel()-t is kiadunk. ha a task a Future-jan keresztul cancellalodik, akkor a socket is bezarodik ES az execelo thread is interruptolodik. ezaltal a task nem csak interruptolhato blocking metodusokat hivhat hanem blocking socket IO metodusokat is ugy hogy cancelra resp marad

[[7.2. STOPPING A THREAD-BASED SERVICE]]
az appok alt serviceket krealnak amik threadeket ownolnak; es a servicek elettartama alt hosszabb mint az oket krealo metoduse. ha az appot gracefully akarjuk shutdownolni akkor a servicek altal ownolt threadeket terminalni kell. threadet preemptiven stoppolni nem lehet, hanem meg kell oket gyozni h alljanak le
thread API-ban nincs formalis ownership def; a threadet krealo classra tekinthetunk ownerkent. tehat pl. egy thread pool ownolja a worker threadjeit es neki kell gondoskodni az it-jukrol
ownership nem tranzitiv; app ownolja a servicet, service ownolja a worker threadeket, de az app nem ownolja a worker threadeket es nem szabad direktben stoppolnia oket. a servicenek kell lifecycle metodusokat providolnia amelyekkel lecsukhato o es az ownolt threadjei. (~ ExecutorService.shutdown()/shutdownNow())

[[[7.2.1. Example: A Logging Service]]]
a legtobb appban van logging, ami gyakran csak sima println()-eket jelent. PrintWriter es egyeb stream classok threadsafek, ezert ehhez nem kell explicit sync (bar ha egy log msg tobb sorbol all akkor client-side locking kellhet pluszban mert ha ket thread uarra a streamre loggol akkor az outputok osszekeveredhetnek. vmint ld. 11.6, inline logging high volume appokban perf--). masik lehetoseg h a log() hivas queueba teszi a log msgt es egy masik thread processalja

class LogWriter {
  private final BlockingQueue<String> queue; private final LoggerThread logger;
  public void start() { logger.start(); }
  public void log(String msg) throws InterruptedException { queue.put(msg); }
  private class LoggerThread extends Thread {
    private final PrintWriter writer;
    public void run() { try { while(true) witer.println(queue.take()); } catch(InterruptedException ignored) {} finally {writer.close();}
logging kulon threadben; a msgt producolo thread nem direktben streamre irja hanem BQ-ba es a logger thread irja ki. multiple producer, single consumer: log()-ot hivo activityk a producerek es a background logger thread a consumer. ha a logger thread lemarad akkor a BQ blokkolja a producereket amig behozza a lemaradast
problema: logger threadet nem tudjuk terminalni, ami akadalyozza a normal JVM shutdownt. take() resp az it-re ezert ha lekezeljuk InterruptedException-t exit-tel akkor leall a service
ezzel az a gond h egy ilyen abrupt shutdownnal  discardolodnak a meg logba irasra varo msgk, masreszt a log()-ban (tele queue miatt) blokkolodott threadek sosem fognak unblokkolodni. p/c cancellalasa mind a p-k mind a c-k cancellalasat igenyli; itt csak a c logger threaddel foglalkozik

masik lehetoseg egy shutdown requested flag beallitasaval preventalni tovabbi msgk submittolasat. igy a c shutdown notif eseten drainelhetne a queuet, kiirhatna a pending msgket es unblokkolhatna a log()-ban blokkolodott p-kat
public void log(String msg) throws InterruptedException { if(!shutdownRequested) queue.put(msg); else throw new IllegalStateException("logger is shut down");
ebben igy race cond van, mert check-then-act: p-k ugy lathatjak h a service meg nem shutdownolt es valojaban mar a shutdown utan rakjak be a queueba a msgket, es fennall a veszely h a p orokre blokkolodik a log()-ban. vannak trukkok amivel ennek lehet a vget csokk, pl. c varjon par secig mielott uresnek nyilvanitana a queuet, de az alapproblemat ezek nem oldjak meg 
a log msg submittolasat atomicka kell tenni. de a put() alatt nem akarjuk tartani a lockot mert az blokkolodhat; ehelyett atomic csekkelhetjuk a shutdownt es inkrementalhatunk egy szlot aminek segitsegevel "reservalhatjuk" a msg submittolas jogat (hosszu peldakod)

[[[7.2.2. ExecutorService Shutdown]]]
ExecutorService graceful shutdown() v abrupt shutdownNow(); utobbi azon taskok listajat returnoli amik meg nem indultak el. abrubt gyorsabb de kockazatosabb mert taskok az exec kozepen allhatnak meg; normal lassabb de biztonsagosabb mert az ES nem all le amig minden queuban levo task nem processalodik

egyszerubb prgk leallithatjak az ES-t main()-bol is; osszetettebben encapsoljak az ES-t vmi hidden level servicebe ami sajat lifecycle metodusokat nyujt
public class LogService {
  public void start() {}
  public void stop() throws InterruptedException { try { exec.shutdown(); exec.awaitTermination(timeout, unit); } finally { writer.close(); }
  public void log(String msg) { try { exec.execute(new WriteTask(msg)); } catch(RejectedExecutionException ignored) {}
nem sajat threadekkel dolgozik hanem ES-nek delegal

[[[7.2.3. Poison Pills]]]
queura rakott obj ami azt jelenti h "ha ezt getteled akkor allj le". FIFO queueknal posion pill biztositja h a c-k minden msgt leolvastak a queuerol, hiszen a p-k a pill utan mar nem submittolnak mast

hosszu peldakod az 5.3.1-beli crawler poison pilles megoldasara (1p, 1c)

poison pillek csakkor mukodnek ha a p-k es c-k szama ismert. az elozo prg bovitheto tobb p-re ugy h minden p ratesz egy pillt a queuera, a c pedig akkor all meg ha minden pillt leolvasott. bovitheto tobb c-re is, ekkor minden p a c-k szamanak megfelelo pillt tesz a queuera, persze nagyszamu p/c eseten mar lehetnek gondok. poison pillek csak unbounded queuekkal mukodnek megbizhatoan

[[[7.2.4. Example: A One-shot Execution Service]]]
ha egy metodusnak taskok egy batchjet kell processalnia es nem returnolhet amig minden task be nem fejezodott, akkor hasznalhat egy privat Executort (invokeAll()/invokeAny())

boolean checkMail(Set<String> hosts) throws InterruptedException {
  ExecutorService exec = Executors.newCachedThreadPool();
  final AtomicBoolean hasNewMail = new AtomicBoolean(false);
  try { for(hosts) { exec.execute(new Runnable() { public void run() {if(checkMail(host) hasNewMail.set(true);}})} finally { exec.shutdown(); exec.awaitTermination(timeout, unit); } return hasNewMail.get();
tobb hoston csekkeli parh h van-e uj mail; private executort kreal es minden hosthoz submittal egy taskot; aztan lezarja az executort es varja a terminationt ami akkor kov be ha minden mail checking task completed
(azert haszn AtomicBooleant volatile boolean helyett mert ha a belso Runnablebol akarnak accessalni akkor finalnak kellene lennie, akkor pedig nem lehetne modositani)

[[[7.2.5. Limitations of Shutdownnow]]]
ha egy ES-t abrupt shutdownNow()-olunk akkor megprobalja cancellalni az in progressben levo taskokat es returnoli a submittalt de nem startolt taskok listajat loggolas v kesobbi processalas celjabol (a returnolt Runnable objk nem biztos h uazok mint a submittolt objk, lehet h be vannak wrappelve)
de nem lehet tudni h shutdownkor mely taskok vannak in progressben hacsak maga a task nem checkpointolja ezt vmilyen modon

pelda: AbstractExecutorServicet extendalo sajat TrackingExecutor class. execute() metodusa egy encapsulalt ES-nek delegal, h megjegyezze mely taskok voltak a shutdown utan cancellalva. meg tudja allapitani  h mely taskok azok amelyek startoltak de nem completeltek normally. az exec megallasa utan visszaadja a cancelled taskok listajat. ehhez a taskoknak meg kell orizniuk a thread it statusat amikor returnolnek (jol megirt taskok ezt meg szoktak tenni)

pelda: elozo TrackingExecutor hasznalata web crawlerben. crawler shutdownjakor menteni akarjuk a statejet h kesobb restartolni tudjuk. ilyenkor a vegigscanneli meg el nem indult es a cancellalt taskokat is, es feljegyzi az URL-eket; restartnal pedig ezekhez az URL-ekhez crawling taskokat submittol a queueba

TrackingExecutorban race cond, ami false positiveokat okozhat: cancelledkent azonositott de valojaban completed taskok. oka h a thread pool shutdownolhat azutan h a task utolso utasitasa mar execelodott de a pool meg nem jegyezte fel a taskot completedkent. ez nem gond idempontent taskok eseten (ketszeri vegrehajtasa hatasa uaz mint egyszerie), crawlerben alt igy van; egyebkent a cancelled taskokat retrievelo appnak kell gondoskodnia a false positiveok kezeleserol

[[7.3. HANDLING ABNORMAL THREAD TERMINATION]]
