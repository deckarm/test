Java Concurrency in Practice

[Chapter 7. Cancellation and Shutdown]
javaban nincs safe forced thread leallitas (Thread.stop()/suspend() deprecated); helyette kooperativ interrupt. kooper azert kell mert leggyakrabban nem akarjuk h thread azonnal megalljon es inkonz allapotban hagyjon vmi shared datat; eloszor cleanupoljon es aztan terminaljon

[[7.1. TASK CANCELLATION]]
cancellable: external code completed allapotba tudja moveolni
cancel oka lehet: user requested (UI, JMX), time limited (timer expiry), app events (pl. tobb task dolgozik a probleman, ha az egyik megoldotta akkor a tobbit cancellaljuk), error, shutdown (graceful (futo taskok meg completelhetnek) v immediate)
a cancellalando task es a cancelt requestelo kod vmilyen protocol szerint kooper

class PrimeGenerator implements Runnable { 
  private volatile boolean cancelled; 
  public void run() { while(!cancelled) { p.nextProbablePrime(); } } 
  public void cancel { cancelled = true; } 
  public sync List<BigInteger> get() {...} 
client() { new Thread(primeGenerator).start(); try { SECONDS.sleep(1); } finally { generator.cancel(); } return generator.get();
a task periodikusan csekkel egy cancellation requested flaget (volatile!) es ha beallitva talalja akkor leall
client 1 secig hagyja futni a generatort mielott cancellalja. nem biztos h pontosan 1 sec lesz mert a cancel request es a run() altali kovetkezo csekkeles kozott lehet delay. cancel() azert finallybol van meghivva h a generator akkor is cancellalodjon ha a sleep interruptolodna

cancellation policy: how/when/what; client kod hogyan kerheti a task canceljet, mikor csekkeli a task h volt-e cancel request, hogyan reagal a task a cancel requestre

[[[7.1.1. Interruption]]]
PrimeGeneratorban a cancellation elobb-utobb bekovetkezik, de ha a cancellalando taskban blocking metodushivas van, akkor lehet h a task sosem jut el oda hogy csekkelje a cancellation flaget
class BrokenPrimeProducer extends Thread {
  public void run() { while(!cancelled) { bq.put(p.nextProbablePrime()); } } 
ez a producer. ha a consumer akkor probalja ot cancellalni amikor a queue eppen tele van, tehat a put() eppen blokkol, akkor nem lesz csekkelve a cancelled flag (a consumer meg kozben nem vesz el elemeket a queuebol amitol a put() tovabbmenjen)

interruption: minden threadnek van egy bool interrupted statusa; ha a threadet interruptoljak akkor ez truera allitodik. interrupt() interruptolja a target threadet. isInterrupted() returnoli a target thread interrupted statusat. static interrupted() metodus returnoli a current thread interrupted statusat, majd pedig kicleareli azt (metodusnev nem szerencses)
blocking lib metodusok mint pl. Thread.sleep(), Object.wait() valasza az interruptra az h clearelik az interrupted statust es InterruptedExceptiont dobnak, jelezve h a blocking oper az interrupt miatt hamarabb ert veget
ha egy thread akkor interruptolodik amikor NEM blocked akkor beallitja az interrupted statust; az pedig a cancellalando activity feladata h csekkelje ezt a statust. ez az un "sticky" interrupt, mert az interrupted status rogzul amig vki ki nem cleareli
az interrupt csak megkeri a threadet h interruptoljon a kovetkezo megfelelo lehetosegnel (un cancellation pointok). egyes metodusok, mint a wait(), sleep(), join() azonnal teljesitik az interrupt kerest v ha belepeskor besettelt interrupted statust talalnak, es InterruptExceptiont dobnak. jol megirt metodusok ignoralhatjak az interrupt kerest, de arra figyelniuk kell h maga a keres ne vesszen el es a hivo kod foglalkozzon vele. interrupt kerest lenyelni nem tanacsos
interrupted() metodussal ovatosan mert cleareli a current thread interrupted statusat. ha meghivjuk es truet returnol akkor azt vhogy kezelnunk kell; vagy dobjunk tovabb InterruptedExceptiont, vagy allitsuk vissza az interrupted statust (ld. 5.4)

custom cancel megoldas helyett interrupttal
class PrimeProducer extends Thread {
  public void run() { try { while(!Thread.currentThread().isInterrupted()) { bq.put(p.nextProbablePrime()); }  catch(InterruptedException e) { //allow thread to exit}
  public void cancel() { interrupt(); }
az interrupt igy detektalodhat a blocking put() metodusban, illetve az interrupted status pollozva van a loop headerben is; utobbi nem is lenne szukseges de resp++, mert meg azelott csekkel h az esetleg hosszas primkereses elindulna

[[[7.1.2. Interruption Policies]]]
hogyan kezeli a thread az it kerest: mit tesz (ha tesz barmit is), az it szempontjabol mi az atomic unit of work, milyen gyorsan reagal a keresre
legpraktikusabb a thread/service level szintu policy: mielobbi exit, cleanup ha szukseges, owning entityk notifyolasa ha szukseges. mas lehetoseg pl pause/resume, de nonstandard it policyju threadeket/poolokat csak olyan taskokhoz szabad hasznalni amelyeket ennek figyelembevetelevel irtak meg

it szempontjabol kulonbseget kell tenni a task es thread kozott. egy adott it keresnek tobb lehetseges cimzettje is lehet, egy thread poolbeli worker thread interruptolasa jelentheti azt is h "cancel the current task" es azt is h "shut down the worker thread"
taskok nem ownoljak a threadeket amikben execelnek; csak kolcsonveszik oket pl. egy thread pooltol. nem ownolo kod is reagalhat az it-re, de meg kell oriznie az interrupted statust az owning kod szamara (ha vkinek vigyazok a hazara, akkor en is elolvashatom a postajaval erkezett ujsagokat, de megorzom oket a tulaj szamara). ezert van h a legtobb blocking lib metodus egyszeruen InterruptedException dobasaval reagal az it keresre; ok nem az altaluk ownolt threadben futnak, ezert ez a legpraktikusabb; egyszeruen felreallnak az utbol, kommunikaljak az it tenyet a hivonak, es hagyjak h a call stack magasabb szintjei foglalkozzanak vele. de egy tasknak nem szuksegszeruen kell azonnal leallnia it kereskor, hanem befejezhetik amit csinalnak, es aztan dobhatjak az InterruptedException-t v jelezhetik az it tenyet vmilyen mas modon
task alapertelmezesben nem feltetelezhet semmit az executolo threadjenek it policyjarol, csak ha ot magat is annak figyelembevetelevel irtak. ha a task nem egyszeruen InterruptedException propagalasaval reagal, akkor gondoskodnia kell az executolo thread interrupted statusanak megorzeserol Thread.currentThread().interrupt()-al
a cancellalo kod sem feltetelezhet semmit arbitrary threadek it policyjarol. egy threadet csak az ownere interruptolhat, o az aki fel tudja a thread it policyjet egy megfelelo cancellation mechanizmusban hasznalni (pl. shutdown metodus)

[[[7.1.3. Responding to Interruption]]]
interruptolhato blocking metodus hivasanal (pl. Thread.sleep(), BQ.put()) ket lehetoseg az InterruptedException kezelesere

1) exception propagalasa (alt vmilyen cleanup utan); ezaltal a mi metodusunk is interruptolhato blocking metodussa valik. legegyszerubb modja a throws clausehoz valo hozaadas
public Task getNextTask() throws InterruptedException { return bq.take(); }

2) ha nem akarjuk v nem tudjuk propagalni az exct (pl mert a taskunk egy Runnable-ben van) akkor vhogy meg kell orizni az it kerest. leggyakrabban restoroljuk az interrupted statust az interrupt() meghivasaval. InterruptedExceptiont ne nyeljunk le ures catch-el csak ha a mi kodunk maga implementalja thread it policyjat. pl. PrimeProducer tudja h a thread terminalni fog es a call stackben magasabban nincs kod aminek tudnia kellene az it-rol; de a legtobb kod nem tudja ezt es meg kell orizniuk az interrupted statust

ha egy task nem tam a cancellationt (vagyis o maga nem interruptolhato, nincs a throwsjaban propagalva az exc!?) de interruptolhato blocking metodust hiv, akkor azt loopban kell csinalnia, it eseten pedig retryolni. lokalisan el kell mentenie az it statust, es a returnoles elott restorolnia, nem a catcheleskor. nem szabad tul koran beallitani az it statust, mert az vegtelen ciklust okozhat, mert a legtobb interruptolhato blocking metodus belepeskor csekkeli az it statust es rogton InterruptedExceptiont dob ha be van allitva
public Task getNextTask() {
  boolean interrupted = false;
  try { while(true) { try { return bq.take(); } catch(InterruptedException e) { interrupted = true; }
  finally { if(interrupted) Thread.currentThread().interrupt();

ha egy task nem hiv interruptolhato blocking metodusokat, azt ugy tehetjuk az it-re responsivva h pollozzuk a current thread it statusat; poll freq megvalasztasa az eff/resp kovetelmenyektol fugg. ha gyors resp kell, akkor nem hivhatunk olyan hosszan futo metodusokat amelyek nem reagalnak az it-re

pl. ha egy ThreadPoolExecutor altal ownolt worker thread it-t detektal akkor csekkeli h a pool eppen shutdownol-e; ha igen akkor vmi cleanupot hajt vegre mielott terminalna, egyebkent pl. kreal egy uj threadet h a pool merete megmaradjon

[[[7.1.4. Example: Timed Run]]]
7.1-ben inditottunk egy PrimeGeneratort majd 1 sec utan interruptoltuk. ha meg a timeout lejarta elott dobott volna egy unchecked exct akkor az valszeg eszrevetlen maradt volna mert a generator egy kulon threadben futott ami nem kezeli explicit az exckat

public void timedRun(Runnable r) {
  final Thread taskThread = Thread.currentThread();
  cancelExec.schedule(new Runnable() { public void run() { taskThread.interrupt(); }, timeout, unit); r.run();
magaban a hivo threadban futtatja a taskot es beschedulal egy cancellation taskot ami megadott ido utan interruptolja. ez megoldja a taskbol dobott unchecked exck problemajat mert ezeket a timedRun() hivoja elkaphatja
nem jo, mert tudni kellene a thread it policyjat ha interruptolni akarjuk, a timedRun()-t pedig bmilyen thread meghivhatja. ha a task meg a timeout elott befejezodik, akkor az interruptot kezdemenyezo task azutan sul el hogy a timedRun() mar returnolt ami nyilvan nem szerencses (erre mo ha schedule()-bol returnolt ScheduledFuture segitsegevel lelohetjuk az interruptot kezdemenyezo taskot). emellett az is problema ha a task olyan h nem reagal az it keresekre, mert ekkor a timedRun() nem returnol amig a task nem fejezodik be, ami joval a vart timeout utan is lehet v soha

public void timedRun(Runnable r) throws InterruptedException {
  class RethrowableTask implements Runnable {
    private volatile Throwable t;
	public void run() { try r.run(); } catch(Throwable t) { this.t = t; }
	void rethrow() { if(t != null) { throw(t); }
  RethrowableTask task = new RethrowableTask();
  final Thread taskThread = new Thread(task);
  taskThread.start();
  cancelExec.schedule(new Runnable() { public void run() { taskThread.interrupt(); }, timeout, unit);
  taskThread.join(timeout);
  task.rethrow();
igy a taskot execelo threadnek meglehet a sajat exec policyja, es meg ha a task nem is reagal az it keresre, a timedRun() ennek ellenere tud returnolni. a task thread inditasa utan a timedRun() futtat ra egy join()-t; miutan a join() returnolt, csekkeli h volt-e a taskban exc, es ha igen akkor rethrowolja azt a timedRun()-t futtato threadben. az elmentett Throwable ket thread kozt van sharelve ezert volatile, h safely legyen publisholva a task threadbol a timedRun() threadjaba
(ez javitja a fenti hibat, de timed join()-rol nem lehet tudni h azert returnolt mert a thread normalisan exitelt v mert a join timeoutolt. ez Thread API flaw)	

[[[7.1.5. Cancellation Via Future]]]
lib class jobb mint custom cancel
ExecutorService.submit() Futuret returnol. Future.cancel(mayInterruptIfRunning) returnoli h a cancel sikeres volt-e (deliverelodott-e az interrupt; nem azt h a task hogy reagalt ra). ha az arg true es a task eppen fut egy threadben akkor az a thread interruptolodik. ha az arg false az azt jelenti, h "ne futtasd ezt a taskot ha meg nem indult el"
olyan threadet nem akarunk interruptolni, aminek nem ismerjuk az it policyjet: standard Executor implk altal krealt threadeket ismerjuk, ezert az ilyeneken futo taskok Futurejara mehet cancel(true). pool threadet ne interruptoljunk direktben, mert nem tudjuk h eppen milyen task fut amikor az it keres deliverelodik; csak a task Futurejan keresztul. ez is egy ok amellett h a taskokat ugy irjuk meg h az it-t cancel kereskent kezeljek, mert ekkor cancellezhetok lesznek a Future-jukon keresztul

public void timedRun(Runnable r) throws InterruptedException {
  Future<?> task = taskExec.submit(r); 
  try { task.get(timeout,unit); } catch(TimeoutException e) {} catch(ExecutionException e) {rethrow();} finally { task.cancel(true); }
ExecutorServicenek submittolja a taskot, es timed Future.get()-el retrieveli az eredmenyt. timeoutexc eseten a taskot a Futurejan keresztul cancellaljuk (egyszerusites h a finally reven minden esetben lesz cancel, kihasznalva h completed task cancellalasanak nincs hatasa). ha meg a cancel elott exception tortenik, azt rethrowoljuk es a hivo foglalkozhat vele. jo practice olyan taskokat elcancellalni amiknek az eredmenyere mar nincs szukseg (ld.6.3.3, 6.3.7); ha Future.get() 
InterruptedException/TimeoutException-t dob es tudjuk h az eredmeny mar nem kell, akkor cancellalhatjuk a taskot

[[[7.1.6. Dealing with Non-interruptible Blocking]]]
sok lib metodus azonnali InterruptedException dobassal reagal az it-re, igy konnyebb a cancelra reagalo taskokat irni. de nem minden blocking metodus reagal igy az it-re; ha egy thread sync IO-ra vagy intrinsic lockra varva blokkol akkor az it hatasa csak annyi h beallitja a thread it statusat. a nem-intteruptolhato tevekenyseg kozben blokkolt threadek neha "meggyozhetoek" arrol h megis alljanak meg, de ez fugg a blokkolodas okatol
sync socket IO (java.io): InputStream.read() es OutputStream.write() nem reagalnak it-re, de ha bezarjuk magat a socketet akkor a blokkolodott thread SocketExceptiont dob
sync IO (java.nio): InterruptibleChannel-re varo thread it-re valaszkent ClosedByInterruptException-t dob es bezarja a channelt (ezaltal a channelre varo osszes tobbi thread is ClosedByInterruptException-t dob). maganak az InterruptibleChannelnek a closolasara az eppen channel operationban blokkolt threadek AsynchronousCloseException-t dobnak
async IO Selectorral: ha egy thread Selector.select()-ben van blokkolva, akkor close() vagy wakeup() hivasra returnolodik
lock acq: ha egy thread intrinsic lockra varva blokkolodik akkor nem tehetunk semmit azon kivul h megprobaljuk elerni h hozzaferjen a lockhoz es eljusson egy olyan allapotba ahol meg tudjuk szolitani. de az explicit Lock classban van lockInterruptibly() metodus ami lehetove teszi az egyszerre lockra varast es it-re figyelest

nonstandard cancel encapsulalasa
class ReaderThread extends Thread {
private final Socket socket; private final InputStream in;
public void interrupt() { try { socket.close(); } catch(IOException ignored) {} finally {super.interrupt();}
public void run() { try { in.read(), store to buffer } catch(IOException e) { //allow thread to exit
sync olvas a socketrol es bufferbe menti az erkezo datat. ugy overridolja a Thread.interrupt()-ot h egyreszt bezarja a socketet masreszt standard it-t is kuld; igy ha it-t kap akkor mindenkeppen felbeszakitja amit csinal, akar a read()-ben, akar egy interuptolhato blocking metodusban van blokkolodva

[[[7.1.7. Encapsulating nonstandard cancellation with newtaskFor]]]
ReaderThreadben latott mo finomithato ThreadPoolExecutor.newTaskFor() segitsegevel; factory metodus ami a taskot repr Futuret krealja, RunnableFuture-t returnol amit FutureTask impl

Future.cancel() overridolhato; cancellalhatunk benne it-re nem reagalo activityket is
hosszu pelda: overridolt Future.cancel()-ben bezarjuk a socketet es super.cancel()-t is kiadunk. ha a task a Future-jan keresztul cancellalodik, akkor a socket is bezarodik ES az execelo thread is interruptolodik. ezaltal a task nem csak interruptolhato blocking metodusokat hivhat hanem blocking socket IO metodusokat is ugy hogy cancelra resp marad

[[7.2. STOPPING A THREAD-BASED SERVICE]]
az appok alt serviceket krealnak amik threadeket ownolnak; es a servicek elettartama alt hosszabb mint az oket krealo metoduse. ha az appot gracefully akarjuk shutdownolni akkor a servicek altal ownolt threadeket terminalni kell. threadet preemptiven stoppolni nem lehet, hanem meg kell oket gyozni h alljanak le
thread API-ban nincs formalis ownership def; a threadet krealo classra tekinthetunk ownerkent. tehat pl. egy thread pool ownolja a worker threadjeit es neki kell gondoskodni az it-jukrol
ownership nem tranzitiv; app ownolja a servicet, service ownolja a worker threadeket, de az app nem ownolja a worker threadeket es nem szabad direktben stoppolnia oket. a servicenek kell lifecycle metodusokat providolnia amelyekkel lecsukhato o es az ownolt threadjei. (~ ExecutorService.shutdown()/shutdownNow())

[[[7.2.1. Example: A Logging Service]]]
a legtobb appban van logging, ami gyakran csak sima println()-eket jelent. PrintWriter es egyeb stream classok threadsafek, ezert ehhez nem kell explicit sync (bar ha egy log msg tobb sorbol all akkor client-side locking kellhet pluszban mert ha ket thread uarra a streamre loggol akkor az outputok osszekeveredhetnek. vmint ld. 11.6, inline logging high volume appokban perf--). masik lehetoseg h a log() hivas queueba teszi a log msgt es egy masik thread processalja

class LogWriter {
  private final BlockingQueue<String> queue; private final LoggerThread logger;
  public void start() { logger.start(); }
  public void log(String msg) throws InterruptedException { queue.put(msg); }
  private class LoggerThread extends Thread {
    private final PrintWriter writer;
    public void run() { try { while(true) witer.println(queue.take()); } catch(InterruptedException ignored) {} finally {writer.close();}
logging kulon threadben; a msgt producolo thread nem direktben streamre irja hanem BQ-ba es a logger thread irja ki. multiple producer, single consumer: log()-ot hivo activityk a producerek es a background logger thread a consumer. ha a logger thread lemarad akkor a BQ blokkolja a producereket amig behozza a lemaradast
problema: logger threadet nem tudjuk terminalni, ami akadalyozza a normal JVM shutdownt. take() resp az it-re ezert ha lekezeljuk InterruptedException-t exit-tel akkor leall a service
ezzel az a gond h egy ilyen abrupt shutdownnal  discardolodnak a meg logba irasra varo msgk, masreszt a log()-ban (tele queue miatt) blokkolodott threadek sosem fognak unblokkolodni. p/c cancellalasa mind a p-k mind a c-k cancellalasat igenyli; itt csak a c logger threaddel foglalkozik

masik lehetoseg egy shutdown requested flag beallitasaval preventalni tovabbi msgk submittolasat. igy a c shutdown notif eseten drainelhetne a queuet, kiirhatna a pending msgket es unblokkolhatna a log()-ban blokkolodott p-kat
public void log(String msg) throws InterruptedException { if(!shutdownRequested) queue.put(msg); else throw new IllegalStateException("logger is shut down");
ebben igy race cond van, mert check-then-act: p-k ugy lathatjak h a service meg nem shutdownolt es valojaban mar a shutdown utan rakjak be a queueba a msgket, es fennall a veszely h a p orokre blokkolodik a log()-ban. vannak trukkok amivel ennek lehet a vget csokk, pl. c varjon par secig mielott uresnek nyilvanitana a queuet, de az alapproblemat ezek nem oldjak meg 
a log msg submittolasat atomicka kell tenni. de a put() alatt nem akarjuk tartani a lockot mert az blokkolodhat; ehelyett atomic csekkelhetjuk a shutdownt es inkrementalhatunk egy szlot aminek segitsegevel "reservalhatjuk" a msg submittolas jogat (hosszu peldakod)

[[[7.2.2. ExecutorService Shutdown]]]
ExecutorService graceful shutdown() v abrupt shutdownNow(); utobbi azon taskok listajat returnoli amik meg nem indultak el. abrubt gyorsabb de kockazatosabb mert taskok az exec kozepen allhatnak meg; normal lassabb de biztonsagosabb mert az ES nem all le amig minden queuban levo task nem processalodik

egyszerubb prgk leallithatjak az ES-t main()-bol is; osszetettebben encapsoljak az ES-t vmi hidden level servicebe ami sajat lifecycle metodusokat nyujt
public class LogService {
  public void start() {}
  public void stop() throws InterruptedException { try { exec.shutdown(); exec.awaitTermination(timeout, unit); } finally { writer.close(); }
  public void log(String msg) { try { exec.execute(new WriteTask(msg)); } catch(RejectedExecutionException ignored) {}
nem sajat threadekkel dolgozik hanem ES-nek delegal

[[[7.2.3. Poison Pills]]]
queura rakott obj ami azt jelenti h "ha ezt getteled akkor allj le". FIFO queueknal posion pill biztositja h a c-k minden msgt leolvastak a queuerol, hiszen a p-k a pill utan mar nem submittolnak mast

hosszu peldakod az 5.3.1-beli crawler poison pilles megoldasara (1p, 1c)

poison pillek csakkor mukodnek ha a p-k es c-k szama ismert. az elozo prg bovitheto tobb p-re ugy h minden p ratesz egy pillt a queuera, a c pedig akkor all meg ha minden pillt leolvasott. bovitheto tobb c-re is, ekkor minden p a c-k szamanak megfelelo pillt tesz a queuera, persze nagyszamu p/c eseten mar lehetnek gondok. poison pillek csak unbounded queuekkal mukodnek megbizhatoan

[[[7.2.4. Example: A One-shot Execution Service]]]
ha egy metodusnak taskok egy batchjet kell processalnia es nem returnolhet amig minden task be nem fejezodott, akkor hasznalhat egy privat Executort (invokeAll()/invokeAny())

boolean checkMail(Set<String> hosts) throws InterruptedException {
  ExecutorService exec = Executors.newCachedThreadPool();
  final AtomicBoolean hasNewMail = new AtomicBoolean(false);
  try { for(hosts) { exec.execute(new Runnable() { public void run() {if(checkMail(host) hasNewMail.set(true);}})} finally { exec.shutdown(); exec.awaitTermination(timeout, unit); } return hasNewMail.get();
tobb hoston csekkeli parh h van-e uj mail; private executort kreal es minden hosthoz submittal egy taskot; aztan lezarja az executort es varja a terminationt ami akkor kov be ha minden mail checking task completed
(azert haszn AtomicBooleant volatile boolean helyett mert ha a belso Runnablebol akarnak accessalni akkor finalnak kellene lennie, akkor pedig nem lehetne modositani)

[[[7.2.5. Limitations of Shutdownnow]]]
ha egy ES-t abrupt shutdownNow()-olunk akkor megprobalja cancellalni az in progressben levo taskokat es returnoli a submittalt de nem startolt taskok listajat loggolas v kesobbi processalas celjabol (a returnolt Runnable objk nem biztos h uazok mint a submittolt objk, lehet h be vannak wrappelve)
de nem lehet tudni h shutdownkor mely taskok vannak in progressben hacsak maga a task nem checkpointolja ezt vmilyen modon

pelda: AbstractExecutorServicet extendalo sajat TrackingExecutor class. execute() metodusa egy encapsulalt ES-nek delegal, h megjegyezze mely taskok voltak a shutdown utan cancellalva. meg tudja allapitani  h mely taskok azok amelyek startoltak de nem completeltek normally. az exec megallasa utan visszaadja a cancelled taskok listajat. ehhez a taskoknak meg kell orizniuk a thread it statusat amikor returnolnek (jol megirt taskok ezt meg szoktak tenni)

pelda: elozo TrackingExecutor hasznalata web crawlerben. crawler shutdownjakor menteni akarjuk a statejet h kesobb restartolni tudjuk. ilyenkor a vegigscanneli meg el nem indult es a cancellalt taskokat is, es feljegyzi az URL-eket; restartnal pedig ezekhez az URL-ekhez crawling taskokat submittol a queueba

TrackingExecutorban race cond, ami false positiveokat okozhat: cancelledkent azonositott de valojaban completed taskok. oka h a thread pool shutdownolhat azutan h a task utolso utasitasa mar execelodott de a pool meg nem jegyezte fel a taskot completedkent. ez nem gond idempontent taskok eseten (ketszeri vegrehajtasa hatasa uaz mint egyszerie), crawlerben alt igy van; egyebkent a cancelled taskokat retrievelo appnak kell gondoskodnia a false positiveok kezeleserol

[[7.3. HANDLING ABNORMAL THREAD TERMINATION]]
