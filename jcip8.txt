[Chapter 8. Applying Thread Pools]

[[8.1. IMPLICIT COUPLINGS BETWEEN TASKS AND EXECUTION POLICIES]]
korabban azt mondtuk h Executor decouplolja a task submissiont az executiontol. valojaban nem minden task kompatibilis minden exec policyvel. taskok amelyek spec exec policyt igenyelnek
- dependent tasks: a legjobb taskok az independentek; amik nem fuggnek mas taskok timigjetol/resultjatol/side effectjeitol. ha indep taskokat execelunk thread poolban, akkor szabadon valthatjuk a pool sizet es configot, ez a perfen kivul masra nem lesz hatassal. de ha dep taskokat submittalunk thread poolba, az implicit constrainteket kreal az exec policyre, amikre figyelnunk kell ha nem akarunk liveness problemakat (ld. 8.1.1)
- tasks that exploit thread confinement: single thread executorok tobb garanciat vallalnak mint thread poolok. garantaljak h taskok nem lesznek conc execelve, ami miatt a task thread safetyje lazithato. az objk confinalhatoak a task threadbe, igy az abban a threadben valo futasra designolt taskok sync nelkul accessalhatjak oket, meg akkor is ha az objk nem threadsafek. ez implicit couplingot okoz a task es az exec policy kozott: a task executorja single threaded kell legyen; ha ahelyett thread poolt hasznalunk akkor a threadsafety elveszhet (a kovetelmeny valojaban nem ennyire szigoru; eleg biztositani h a taskok ne legyenek conc execelve, es legyen eleg sync h az egyik task altal okozott mem valtozasok visiblek legyenek a kov task szamara: newSingleThreadExecutor garantalja ezt)
- response-time-sensitive tasks: GUI appok resp time sensitivek, a user nem szereti ha a gombnyomas es a visual feedback kozott delay van. ha hosszan futo taskot submittolunk single thread executornak, vagy sok hosszan futo taskot submittolunk egy keves threades thread poolnak, az befolyasolhatja az executor altal managelt service respjat
- tasks that use ThreadLocal: ThreadLocal reven minden threadnek sajat private "verzioja" van a varbol. de az executorok szabadon reusolhatjak a threadeket: standard Executor implk lekaszalhatjak (reap) az idle threadeket ha low a demand, illetve uj threadeket addolhatnak ha high a demand; es replacelhetnek egy worker threadet ha egy task unchecked exct dob. ThreadLocalnak pool threadekben csakkor van ertelme, ha a task lifetimeja boundolja a var lifetimejat; ne hasznaljunk ThreadLocalt pool threadekben arra h taskok kozt valuekat kommunikaljunk

thread poolok akkor muk a legjobban ha a taskok homogenek es indepek. hosszu es rovid futasi ideju taskokat mixelve a pool "eltomodhet" ha nem eleg nagy; mas taskokon dependalo taskokat submittalva DL lephet fel hacsak a pool nem unbounded. szerencsere a tip nw-based server appok (webserver, mailserver, fileserver) requestjei alt teljesitik ezt

egyes taskok megkovetelnek v kizarnak spec exec policyt. mas taskokon dependalo taskok megkov h a thread pool eleg nagy legyen h a taskok sose legyenek queuzva/rejectalva; thread confinementet exploitolo taskok seq execet igenyelnek. ezeket dokumentalni kell h maintainerek kesobb nehogy inkompat exec policyra csereljek le

[[[8.1.1. Thread Starvation Deadlock]]]
ha mas taskokon dependalo taskokat thread poolban execelunk abbol DL lehet. single threaded executorban egy task ami egy masik taskot submitol uannak az executornak es var a resultja, az mindig DL lesz (a masodik task addig all a work queueban amig az elso completel, de az elso nem completel mert a masodik resultjara var). uez lehet nagyobb thread poolokban is ha minden thread olyan taskokat execel amelyek azert blokkolnak mert a work queuen levo egyeb taskokra varnak. ez az un thread starvation DL: akkor van ha egy pool task unbounded blocking waitet kezd egy olyan rscre/conditionra amit csak egy masik pool task actionja teljesithet (pl. a masik task return valueja v side effectje), kiveve ha a pool eleg nagy

class ThreadDeadlock {
  ExecutorService exec = Executors.newSingleThreadExecutor();
  class RenderPageTask implements Callable<String> {
    public String call() throws Exception {
	  Future<String> header, footer; header = exec.submit(new LoadFileTask("header.html")); footer = exec.submit(new LoadFileTask("footer.html")); String page = renderBody(); return header.get() + page + footer.get(); 
task (RenderPageTask) a (altala submittolt) subtask resultjara var, single threaded executorral ez mindig DL
egymas kozott barrierrel koordinalo taskoknal is fellephet ha a pool nem eleg nagy

ha nem indep taskokat submittolunk egy executornak akkor figyeljunk a thread starv DL lehetosegere, es dokumentaljuk a pool sizingre/configra von constrainteket
a thread pool size-jan kivul lehetnek megy egyeb implicit constraintek is, pl. ha 10 connra kepes JDBC conn poolt haszn es minden tasknak kell DB conn, az olyan mintha a thread poolban csak 10 thread lenne

[[[8.1.2. Long-running Tasks]]]
thread pooloknak akkor is resp problemai lehetnek ha a taskok hosszu ideig blokkolnak, meg ha DL nincs is. a pool "eltomodhet" az ilyen taskokkal, es meg a rovid futasi ideju taskok service timeja is megnohet. ha a pool size relative kicsi a hosszu futasi ideju taskok szamahoz kepest, akkor vegul minden pool thread ilyen taskokat fog futtatni, es resp-- lesz
segithet ha a taskok unbounded wait helyett timed rsc waitet haszn. legtobb blocking metodusnak a platform libekben van timed verzioja, pl. Thread.join(), BQ.put(), CountDownLatch.await(), Selector.select(). ha a wait timeoutol akkor a taskot failre markolhatjuk es abortalhatjuk v requeuolhatjuk kesobbi execre. igy minden task elobb-utobb completel (success v failure) a threadek pedig felszabadulnak. ha egy thread pool gyakran van tele blocked taskokkal azt jelezheti h a pool tul kicsi

[[8.2. SIZING THREAD POOLS]]
az idealis size a submittalando taskok tipusatol es a deployment sys jellemzoitol fugg. size ritkan hardcoded; configolhato v dinam van kiszamolva CPU szam alapjan
sizing nem egzakt tudomany, csak a "tul nagy" es "tul kicsi" kerulendo el. ha a pool tul nagy akkor a threadek keves CPU/mem rscert versenyeznek, magasabb mem usage, es valoszinubb rsc exhaustion. ha tul kicsi, az throughput-- mert a procok kihasznalatlanul allnak pedig lenne work
hany proc van a depl sysben? mennyi mem? taskok foleg szamolnak/IO/ketto kombinacioja? hasznalnak limitalt rsct pl JDBC connt? ha klf behavju taskjaink vannak, akkor tobb thread poolt is hasznalhatunk

szamitasintenziv taskokra egy Ncpu (Runtime.availableProcessors()) procos sys opt kihasznalasa alt Ncpu+1 threades thread poollal (meg az ilyen taskoknal is lehet page fault v egyeb okbol pause, egy extra threaddel ilyenkor nem vesztunk CPU ciklusokat). IO-t v egyeb blocking opereket tartalmazo taskokhoz nagyobb pool kell mert nem minden thread schedulalhato mindig. task waiting time/compute time-ot kell estimalni (nem kell pontosan, lehet pro-filinggel(?) v instrumentationnel). masik lehetoseg: tobb klf pool size mellett futtatni az appot benchmark loaddal, es megfigyelni a CPU kihasznaltsagot. az opt pool size: Ncpu * Ucpu * (1 + W/C), ahol Ucpu a kihasznaltsag (0 es 1 kozotti ertek)

CPU ciklusokon kivul mas rscok is szamitanak: mem, file handleok, socket handleok, DB connok. ezekre egyszerubb pool size constraintet szamolni: adjuk ossze h az egyes taskok mennyi rsct igenyelnek es osszuk el a total qtyvel, ez lesz a pool size felso hatara

ha taskok pooled rsct igenyelnek pl. DB conn, akkor a thread pool size es az rsc pool size bef egymast. ha minden tasknak kell conn, akkor a conn pool size limitalja a thread pool eff sizejat. hasonloan ha a connok consumerei kizarolag a pool taskok, akkor a thread pool size limitalja a conn pool sizeot

[[8.3. CONFIGURING THREADPOOLEXECUTOR]]
ThreadPoolExecutor a base impl az Executors-beli newCachedThreadPool(), newFixedThreadPool() es newScheduledThreadExecutor() factoryk altal visszaadott executorokhoz. flex, robust pool impl, jol customizalhato. ha a default exec policy nem megfelelo nekunk akkor peldanyosithatunk egy ThreadPoolExecutort a konstruktoraval es customizalhatjuk (exec policyk dokumentalva az Executors kodjaban)

[[[8.3.1. Thread Creation and Teardown]]]
TPE konstr paramok
core pool size a target size, probalja ezt megtartani meg ha eppen nincsenek is execelendo taskok (TPE krealaskor a core threadek nem startolnak el rogton, hanem amikor a taskok submittolodnak; hacsak nem hivunk prestartAllCoreThreads()-t) es nem kreal ennel tobb threadet hacsak a work queue nincs tele. max pool size...


