Applying concurrency and multi-threading to common Java patterns (Jose Paumard)

thread: OS szint. set of instructions. app: several threads. diff threads exec same time. JVM threads: GC, JIT etc
same time: text typing + spellcheck + print + email receive. 1 core: time slicing, gyors ezert tunik ugy mintha parh lenne. tobb core: valodi parh
CPU time sharing: scheduler. thread pausalasa 3 okbol 1) egyenlo elosztas 2) thread wait for data (IO) 3) thread wait for other thread
race condition: 2 thread tries to R+W (!) same data same time => mas 1 ill tobb core eseten
pl. singleton getInstance()-t ket thread probalja exec. T1 bejut ifbe, amikor a scheduler atadja T2-nek, T2 is bejut ifbe, megkrealja az instanceot, aztan megint T1 jon ami mar benn van az ifben, ezert o is megkreal egy masik instanceot es felulvagja T2 munkajat
mo: sync. egy code blockot csak 1 thread execelhet. az objnak van egy lockja, ahhoz egy key (monitor), ezt kapja meg az execelo thread, es amig nala van addig masik thread nem kaphatja meg
key: static getInstance() eseten maga a Singleton.class. non-static esetben az instance. ezek implicitek. explicit: metoduson belul sync(key), ahol key = new Object() fieldje a classnak
Person class, sync getName(), sync getAge() metodusok. Mary instance eseten maga a Mary a key. T1 exec Mary.getName() => T2 nem executolhatja Mary.getAge()-t
Mary + John ket kulon instance: T1 execeli Mary.getName()-t => T2 execelheti John.getAge()-jet vagy John.getName()-t is
ha azt akarjuk h a Person class minden instanceban csak egy thread execelhesse a getName()-t, akkor a locknak a Person classhoz kell boundolnia (static field a classban) nem az egyes instanceokhoz. ekkor ha T1 execeli Mary.getName()-t, akkor T2 nem execelheti se John.getName()-t, se John.getAge()-t
