Applying concurrency and multi-threading to common Java patterns (Jose Paumard)

[understanding concurrency threading and synchronization]

thread: OS szint. set of instructions. app: several threads. diff threads exec same time. JVM threads: GC, JIT etc

same time: text typing + spellcheck + print + email receive. 1 core: time slicing, gyors ezert tunik ugy mintha parh lenne. tobb core: valodi parh

CPU time sharing: scheduler. thread pausalasa 3 okbol 1) egyenlo elosztas 2) thread wait for data (IO) 3) thread wait for other thread

race condition: 2 thread tries to R+W (!) same data same time => mas 1 ill tobb core eseten

pl. singleton getInstance()-t ket thread probalja exec. T1 bejut ifbe, amikor a scheduler atadja T2-nek, T2 is bejut ifbe, megkrealja az instanceot, aztan megint T1 jon ami mar benn van az ifben, ezert o is megkreal egy masik instanceot es felulvagja T2 munkajat

mo: sync. egy code blockot csak 1 thread execelhet. az objnak van egy lockja, ahhoz egy key (monitor), ezt kapja meg az execelo thread, es amig nala van addig masik thread nem kaphatja meg

key: static getInstance() eseten maga a Singleton.class. non-static esetben az instance. ezek implicitek. explicit: metoduson belul sync(key), ahol key = new Object() fieldje a classnak

Person class, sync getName(), sync getAge() metodusok. Mary instance eseten maga a Mary a key. T1 exec Mary.getName() => T2 nem executolhatja Mary.getAge()-t

Mary + John ket kulon instance: T1 execeli Mary.getName()-t => T2 execelheti John.getAge()-jet vagy John.getName()-t is

ha azt akarjuk h a Person class minden instanceban csak egy thread execelhesse a getName()-t, akkor a locknak a Person classhoz kell boundolnia (static field a classban) nem az egyes instanceokhoz. ekkor ha T1 execeli Mary.getName()-t, akkor T2 nem execelheti se John.getName()-t, se John.getAge()-t

reentrant lock: Mary.m1() hivja John.m2()-t, aminek uaz a lockja. uaz a thread at tud lepni egyikbol a masikba, ez a reentrant

deadlock: Mary.m1() hivja John.m2()-t de nem ugyanaz a lockjuk; John.m2() hivja Mary.m3()-at aminek ugyanaz a lockja mint Mary.m1()-nek
T1 execeli Mary.m1()-et, tehat egyuttal fogja Mary.m3()-at is, valamint T2 execeli John.m2()-t. Ez igy DL, mert T1 nem tud atlepni John.m2()-be, T2 pedig nem tud atlepni Mary.m3()-ba
JVM tud DL-t detectalni, de restarton kivul mast nem nagyon lehet vele csinalni

runnable pattern: new R() (lambda!) => pass to T constructor => T.start()
R.run() {sout("I am running in" + Thread.currentThread().getName())}; T(R); T.setName("mythread"); T.start() => "mythread". de ha t.start() helyett t.run()-t irunk, akkor "main", mert nem uj threadben futtatja!

pl. LongWrapper class, get(), increment() {i = i +1}
main: R.run() {for(1000) LW.incr();}; T(R); T.start(); T.join(); sout(LW.get()); => 1000 OK, mert 1 threadunk van
(join azert kell, h a join utan irt kod, azaz a sout a T lefutasa utan fusson le!)
ha 1000 threadunk van, mindegyikre Ti(R), Ti.start(), Ti.join() => nem 1000000 lesz, es minden futtatasra mas
az i = i+1 (R followed by W) tipikus race cond, ha diff threadek execelik same time
mo: incr() metodus syncelese, a LW classba felvett new Object() keyjel

pl. 3 metodus, 2 key
a() K1 => b(); b() K2 => c(); c() K1 nem hiv senkit
R1.run() {O.a()}; R2.run() {O.b()}; T1(R1); T2(R2); T1.start(); T2.start(); T1.join(); T2.join();
T1 blocked, mert nem tud b()-be atlepni. T2 blocked mert nem tud c()-be atlepni
debug modban latszodik (suspend thread): "waiting for object", "waited by", "owned by"

thread (T instance) executes task (R instance) in spec context

[implementing the producer/consumer pattern using wait/notify]

thread executes a task(R)
stop thread: interrupt(). nem allitja meg a threadet, hanem signalt kuld a thread altal futtatot tasknak h alljon le
R.run() { while(!Thread.currentThread().isInterrupted())...}. T1(R); T1.start(); T1.interrupt() => ekkor fog a R-ben levo isInterrupted() true-t visszaadni es kiszallni a while-bol
ha a thread blocked/waiting, akkor a corresponding metodus InterruptedExc-t fog dobni (pl. wait, notify, join)

producer/consumer: bufferbe/bol, ami lehet ures/full is
Pi/Ci mind sajat threadjeikben futnak => race cond lehet
P: while(isFull) {NOP}; B[c++] = 1;
C: while(isEmpty){NOP}; B[--c] = 0;
ez igy race cond. minden P,C a sajat threadjeben fut es probalja W/R-ni a buffert => conc access miatt corrupt the array
fix? sync magukat a p/c metodusokat? NOK, mert igy a P es a C instanceok lesznek a _kulon_ keyek
kozos key kell: Object lock; es sync(lock) a p/c metodusokon belul
de ha B empty: a c-t futtato thread blokkolodik a whileban es fogja a keyt => p-t futtato thread var a sync(lock)-ra, de azt a c threadje fogja; ezert p nem tud adatot adni a B-hez => DL
mo: parkoltatni kell a c threadjet ha producolasra var; es el kell engedni az altala tartott keyt h a p threadje hozzaferjen => wait/notify

wait(): releaseli a thread altal tartott keyt. a thread WAIT statebe kerul, amibol notify() hatasara johet ki
notify(): releaseli a threadet WAIT-bol, es RUNNABLE-be teszi. a sima notify() random valaszt a WAIT-elo threadek kozul, notifyAll() minden WAIT-ben levo threadet ebreszt (akik arra a keyre varnak!?)

P: sync(lock) if(isFull(B)) lock.wait(); B[c++] = 1; lock.notifyAll(); => while helyett if! producer threadet WAIT-be teszi, ezaltal a thread altal fogott key releaselodik es a consumer felveheti; evegbol notifyolja az esetleg eppen WAIT-ben levo c-ket
C: sync(lock) if(isEmpty(B)) lock.wait(); B[--c] = 0; lock.notifyAll(); => while helyett if! consumer threadet WAIT-be teszi, ezaltal a thread altal fogott key releaselodik es a producer felveheti; evegbol notifyolja az esetleg eppen WAIT-ben levo p-ket
a lock kozos! tehat a p es c sync blokkjat ket thread nem execelheti egyszerre

lock obj-hoz (keyhez) wait list tartozik, ebbe kerulnek a ra varo threadek

P/C demo
1) sync nelkul => race cond miatt a vegen nem lesz 0 a B (egyenlo szamu ++ es -- utan)
2) while-os verzio + sync => DL. debug/suspendben latszik h az egyik thread (c) fogja a lockot es a whileban porog; a masik thread (p) pedig var a lockra
3) while helyett if + wait/notify => vegen B = 0 (vagy pl. 50++, 45-- utan 5)

thread state: running or not? ha not, akkor indithatja a scheduler? nem mindig, pl. ha a thread egy lock wait listjeben van, akkor a scheduler csak ugy nem utemezheti
Thread.getState()
NEW
RUNNABLE: NEW-bol start() hatasara. itt a scheduler mar adhat neki idoszeletet
TERMINATED: ha RUNNABLE-bol atkerul ide, akkor a scheduler mar nem utemezheti
ezekbol visszakerulhet RUNNABLE-be:
BLOCKED: RUNNABLE-bol kerul at ide, ha sync blokk bejaratanal all aminek a keye nem hozzaferheto
WAITING: RUNNABLE-bol wait() hatasara kerul at ide; wait listbe kerul; notify() ebresztheti
TIMED_WAITING: RUNNABLE-bol wait(ms) vagy sleep(ms) hatasara kerul at ide. az ido lejartaval a system automatikusan notifyolja

[ordering R/W operations on multicore]

sync protect block of code => exec by only 1 thread at the same time => prevent race cond (pl. P/C)

P/C count++, count--
cache nelkul ez OK lenne, de ma mar van cache :)
- main mem: ~100 ns, 1 GB
- CPU: tobb core, mindegyiknek sajat L1 (0.5 ns, 32 kb), L2 (7 ns, 256 kb); common L3

pl. main memben count = 0;
C1-ben levo prod ++-olja, az o L1-jeben count = 1 lesz
C2-ben levo thread accessalna, neki mar count = 1-et kellene latnia es nem 0-t

visibility lenyegeben: inform other caches that the var has been modified and should not be fetched from main mem
var visible, ha a rajta vegrehajtott W-k visiblek. a sync W-ok azok visiblek!

HB: abstract notion
java mem model: multicore-on R/W same time tortenhetnek, a varok pedig tobb helyen tarolodhatnak. vis: R should return value set by last W

1) T1 x:=1
2) T2 r:=x
r = ? ha nincs 1) es 2) kozott HB, akkor unknown (1 vagy 0). ha van HB akkor r = 1
HB: minden sync vagy volatile W es a rakovetkezo sync vagy vol R kozott van

W: incr() {i++}
R: print() {sout(i)}
W-t es R-t ket kulonnbozo thread futtatja
- nincs sync, nincs vol: print unknown
- ha a ket metodus sync (ugyanarra az objra/instancera!): a jo ertek printelodik
- volatile i; (es nincs sync): a jo ertek printelodik

m1() { x = 1; sync(lock) {y = 1}}
m2() { sync(lock) { r1 = y }; r2 = x;}
T1 futtatja m1-et, T2 m2-et; r2 = ? (x,y,r1,r2 nem vol!)
x = 1 HB y = 1 es r1 = y HB r2 = x mert uazon a metoduson belul vannak
- ha T1 lep be eloszor: y = 1 HB r1 = y a sync miatt, es a fenti ket HB-vel egyutt latszik h r2 = 1 lesz
- ha T2 lep be eloszor: r1 = y HB y = 1 a sync miatt, de r2 = x es x = 1 kozott nincs HB, nem tudjuk melyik lesz elobb, tehat nem tudjuk h r2 = 0 v 1 lesz

sync: exclusive exec a block of code
vis: var consistency guarantee (read the correctly updated value). gyengebb mint sync
=> shared vart a threadeknek sync vagy vol modon kell accessalniuk

false sharing: side effect, perf-- lehet
cache data lineokbol all (8 long = 64 byte). ha volatile vart modositunk L1 cacheben, akkor a tobbi cacheben uazt a linet dirtyre markolja. dirty line olvasasa line refresht triggerel

vol a,b 
m1() {a++}
m2() {b++}
T1 core1-n futtatja m1-et, csak a erdekli, de core1.L1-ben uabba a lineba b is bekerul (mert egymas mellett vannak def?)
T2 core2-n futtaja m2-t, csak b erdekli, de core2.L1-ben uabba a lineba a is bekerul
eloszor T1 a++ => a line core2.L1-ben is dirtyre lesz markolva
aztan T2 jonne, de a dirty miatt cache miss, es a main membol kell kiszednie b-t; pedig T1 nem nyult b-hez, a cache arch miatt tortent minden. ez a false sharing. invisible, hard to predict

demo: 4 thread, 50m iter
VolLongUnPadded { vol long = 0L; } => ha a class tobb instanceat krealjuk akkor valszeg uabba a cache lineba kerulnek, false sharing
VolLongPadded {6db long; vol long = 0L; 6db long; } => ez igy isolated lesz egy cache lineban; tobb instance eseten nem uabba a cache lineba kerulnek
n db T(createUnpaddedRunnable) => R-ben az unpadded long modifyolasa tortenik => same line, false sharing
n db T(createPaddedRunnable) => R-ben a padded long modifyolasa tortenik => diff line, no false sharing
1 db thread eseten az unpadded es a padded eset perf kb =, 2 db thread eseten mar latszi h az unpadded eset lassabb

[implementing threadsafe singleton on multicore CPU]

private static Singl inst; private final Singl(); public static getInst() { if(inst == null) {inst == new Singl();} return inst;}
inst == null R; inst = new... W. nincs koztuk HB. ha kul thread futtatja oket akkor race cond. ez nem threadsafe mo

sync getInst()? ket thread nem tudja execelni tehat ez igy funkcionalisan OK
1 core: T1 lep be eloszor syncbe, inst == null telj; ekkor sched atvalt T2-re aki viszont nem tud belepni syncbe mert T1 tartja a lockot; T2 kiutemezodik, T1 folyt, megkrealja az instanceot es kilep a syncbol. T2 most mar be tud lepni a syncbe es kiolvasni az instanceot
2 core: T1 lep be eloszor syncbe, inst == null telj. mivel 2 core van, ezert T2 same time execelheti getInst()-t de hiaba van masik coreon nem tud belepni syncbe mert T1 tartja a lockot (T2 itt varhat egy kicsit mert tudja h egy masik coreon futo thread tartja a lockot es hatha elengedi), ugyhogy meg kell varnia amig T1 megkrealja az instanceot es kilep a syncbol. T2 most mar be tud lepni a syncbe es kiolvasni az instanceot
pl. 4 core: T1 vegzi a krealast; de a tobbi 3 thread kozul mindig egyszerre csak egy tud olvasni a sync miatt, nem tudnak parh olvasni, ami perf--
tehat multicoreon a sima sync nem eleg perf mo

double checked locking: getInst() ne legyen sync
getInst() { if(inst!=null) return inst; sync(key) {if(inst!=null) {inst = new();} return inst;}}
elso inst!=null nem sync blockban van, tehat a R-k lehetnek parh
a masodik inst!=null ell h ha egy masik thread mar megkrealta akkor azt vissza lehet adni

- az elso inst!=null R, de nem sync es nem vol
- az inst = new W, nem vol de sync
ezek kozott nincs HB mert az csak sync/vol W/R-k kozt lenne
ez 1 coreon nem gond mert ott nem issue a visibility
de tobb coreon gond lehet
az inst field egy pointer 1) mem area alloc 2) inst point to mem area 3) obj construction a mem areaban
nem tudjuk h a 2) v 3) lesz elobb. ha 3) akkor OK. de ha 2) es masik threadbol probaljuk R, akkor nem fully built objt latunk

ha inst vol lenne, akkor sync W majd vol R; HB megvan, de ezzel visszajutunk a perf-- problemahoz
jo mo: enum Singleton {INSTANCE}

korabbi LongWrapper pelda; ott az incr() metodusban synceltunk. mi lenne ha inkabb vol long lenne? nem jo, mert a vol R es vol W ugyan OK lesz, de az l = l + 1 nem atomic; kell a sync hogy egyben fusson le
a korabbi synces mo egyebkent nem teljes, mert a get() nem volt sync (sem vol) => nem garantalt h az incr()-ben utoljara W-elt erteket olvassa majd ki

Java puzzlers pelda: az app egy sync metoduson belul meghiv egy join()-t, de a metodus megsem fut le egyben => a join() JDK impl belsejeben van egy wait() ami ugye releaseli a lockot. mo: sajat lockkal is kell syncelnunk meg pluszban a join() korul

conc programok irasa
- race cond fielden lehet (varon, met paramon nem)
- HB: R/W vol? sync?
- sync vagy vol legyen? sync = atomicity, vol = visibility
