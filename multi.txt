Applying concurrency and multi-threading to common Java patterns (Jose Paumard)

[understanding concurrency threading and synchronization]

thread: OS szint. set of instructions. app: several threads. diff threads exec same time. JVM threads: GC, JIT etc

same time: text typing + spellcheck + print + email receive. 1 core: time slicing, gyors ezert tunik ugy mintha parh lenne. tobb core: valodi parh

CPU time sharing: scheduler. thread pausalasa 3 okbol 1) egyenlo elosztas 2) thread wait for data (IO) 3) thread wait for other thread

race condition: 2 thread tries to R+W (!) same data same time => mas 1 ill tobb core eseten

pl. singleton getInstance()-t ket thread probalja exec. T1 bejut ifbe, amikor a scheduler atadja T2-nek, T2 is bejut ifbe, megkrealja az instanceot, aztan megint T1 jon ami mar benn van az ifben, ezert o is megkreal egy masik instanceot es felulvagja T2 munkajat

mo: sync. egy code blockot csak 1 thread execelhet. az objnak van egy lockja, ahhoz egy key (monitor), ezt kapja meg az execelo thread, es amig nala van addig masik thread nem kaphatja meg

key: static getInstance() eseten maga a Singleton.class. non-static esetben az instance. ezek implicitek. explicit: metoduson belul sync(key), ahol key = new Object() fieldje a classnak

Person class, sync getName(), sync getAge() metodusok. Mary instance eseten maga a Mary a key. T1 exec Mary.getName() => T2 nem executolhatja Mary.getAge()-t

Mary + John ket kulon instance: T1 execeli Mary.getName()-t => T2 execelheti John.getAge()-jet vagy John.getName()-t is

ha azt akarjuk h a Person class minden instanceban csak egy thread execelhesse a getName()-t, akkor a locknak a Person classhoz kell boundolnia (static field a classban) nem az egyes instanceokhoz. ekkor ha T1 execeli Mary.getName()-t, akkor T2 nem execelheti se John.getName()-t, se John.getAge()-t

reentrant lock: Mary.m1() hivja John.m2()-t, aminek uaz a lockja. uaz a thread at tud lepni egyikbol a masikba, ez a reentrant

deadlock: Mary.m1() hivja John.m2()-t de nem ugyanaz a lockjuk; John.m2() hivja Mary.m3()-at aminek ugyanaz a lockja mint Mary.m1()-nek
T1 execeli Mary.m1()-et, tehat egyuttal fogja Mary.m3()-at is, valamint T2 execeli John.m2()-t. Ez igy DL, mert T1 nem tud atlepni John.m2()-be, T2 pedig nem tud atlepni Mary.m3()-ba
JVM tud DL-t detectalni, de restarton kivul mast nem nagyon lehet vele csinalni

runnable pattern: new R() (lambda!) => pass to T constructor => T.start()
R.run() {sout("I am running in" + Thread.currentThread().getName())}; T(R); T.setName("mythread"); T.start() => "mythread". de ha t.start() helyett t.run()-t irunk, akkor "main", mert nem uj threadben futtatja!

pl. LongWrapper class, get(), increment() {i = i +1}
main: R.run() {for(1000) LW.incr();}; T(R); T.start(); T.join(); sout(LW.get()); => 1000 OK, mert 1 threadunk van
(join azert kell, h a join utan irt kod, azaz a sout a T lefutasa utan fusson le!)
ha 1000 threadunk van, mindegyikre Ti(R), Ti.start(), Ti.join() => nem 1000000 lesz, es minden futtatasra mas
az i = i+1 (R followed by W) tipikus race cond, ha diff threadek execelik same time
mo: incr() metodus syncelese, a LW classba felvett new Object() keyjel

pl. 3 metodus, 2 key
a() K1 => b(); b() K2 => c(); c() K1 nem hiv senkit
R1.run() {O.a()}; R2.run() {O.b()}; T1(R1); T2(R2); T1.start(); T2.start(); T1.join(); T2.join();
T1 blocked, mert nem tud b()-be atlepni. T2 blocked mert nem tud c()-be atlepni
debug modban latszodik (suspend thread): "waiting for object", "waited by", "owned by"

thread (T instance) executes task (R instance) in spec context

[implementing the producer/consumer pattern using wait/notify]

thread executes a task(R)
stop thread: interrupt(). nem allitja meg a threadet, hanem signalt kuld a thread altal futtatot tasknak h alljon le
R.run() { while(!Thread.currentThread().isInterrupted())...}. T1(R); T1.start(); T1.interrupt() => ekkor fog a R-ben levo isInterrupted() true-t visszaadni es kiszallni a while-bol
ha a thread blocked/waiting, akkor a corresponding metodus InterruptedExc-t fog dobni (pl. wait, notify, join)

producer/consumer: bufferbe/bol, ami lehet ures/full is
Pi/Ci mind sajat threadjeikben futnak => race cond lehet
P: while(isFull) {NOP}; B[c++] = 1;
C: while(isEmpty){NOP}; B[--c] = 0;
ez igy race cond. minden P,C a sajat threadjeben fut es probalja W/R-ni a buffert => conc access miatt corrupt the array
fix? sync magukat a p/c metodusokat? NOK, mert igy a P es a C instanceok lesznek a _kulon_ keyek
kozos key kell: Object lock; es sync(lock) a p/c metodusokon belul
ha B empty: a c-t futtato thread blokkolodik a whileban es fogja a keyt => p-t futtato thread var a sync(lock)-ra, de azt a c threadje fogja; ezert p nem tud adatot adni a B-hez => DL
mo: parkoltatni kell a c threadjet ha producolasra var; es el kell engedni az altala tartott keyt h a p threadje hozzaferjen => wait/notify

wait(): releaseli a thread altal tartott keyt. a thread WAIT statebe kerul, amibol notify() hatasara johet ki
notify(): releaseli a threadet WAIT-bol, es RUNNABLE-be teszi. a sima notify() random valaszt a WAIT-elo threadek kozul, notifyAll() minden WAIT-ben levo threadet ebreszt (akik arra a keyre varnak!?)

P: sync(lock) if(isFull(B)) lock.wait(); B[c++] = 1; lock.notifyAll(); => while helyett if! producer threadet WAIT-be teszi, ezaltal a thread altal fogott key releaselodik es a consumer felveheti; evegbol notifyolja az esetleg eppen WAIT-ben levo c-ket
C: sync(lock) if(isEmpty(B)) lock.wait(); B[--c] = 0; lock.notifyAll(); => while helyett if! consumer threadet WAIT-be teszi, ezaltal a thread altal fogott key releaselodik es a producer felveheti; evegbol notifyolja az esetleg eppen WAIT-ben levo p-ket
a lock kozos! tehat a p es c sync blokkjat ket thread nem execelheti egyszerre

lock obj-hoz (keyhez) wait list tartozik, ebbe kerulnek a ra varo threadek

P/C demo
1) sync nelkul => race cond miatt a vegen nem lesz 0 a B (egyenlo szamu ++ es -- utan)
2) while-os verzio + sync => DL. debug/suspendben latszik h az egyik thread (c) fogja a lockot es a whileban porog; a masik thread (p) pedig var a lockra
3) while helyett if + wait/notify => vegen B = 0 (vagy pl. 50++, 45-- utan 5)

thread state: running or not? ha not, akkor indithatja a scheduler? nem mindig, pl. ha a thread egy lock wait listjeben van, akkor a scheduler csak ugy nem utemezheti
Thread.getState()
NEW
RUNNABLE: NEW-bol start() hatasara. itt a scheduler mar adhat neki idoszeletet
TERMINATED: ha RUNNABLE-bol atkerul ide, akkor a scheduler mar nem utemezheti
ezekbol visszakerulhet RUNNABLE-be:
BLOCKED: RUNNABLE-bol kerul at ide, ha sync blokk bejaratanal all aminek a keye nem hozzaferheto
WAITING: RUNNABLE-bol wait() hatasara kerul at ide; wait listbe kerul; notify() ebresztheti
TIMED_WAITING: RUNNABLE-bol wait(ms) vagy sleep(ms) hatasara kerul at ide. az ido lejartaval a system automatikusan notifyolja
