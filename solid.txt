SOLID Principles of Object Oriented Design (Steve Smith)

[The Single Responsibility Principle]

SRP: every obj should have a single resp and that resp should be entirely encapsed by the class
Uncle Bob: there should never be more than one reason for a class to change
pl. zsebkes ami mindent tud, csak nem megy bele a zsebembe. "just because you can, doesn't mean you should"

cohesion: module/class respjei mennyire relatedek es focusedek
coupling: az a degree amivel egy module/class relyol a masik modulon/classon
cel a high cohesion es a loose coupling

tobb resp => valoszinubb valtozas
ha tobb resp van egy classban az osszecouplolja oket
egy change minel tobb classt erint, annal valoszinubb a hiba

demo
Rectangle class
- area()
- render(): GUI liben dependal
a classt ket app hasznalja
- geometry service: no GUI, csak az area()-t hivja
- graphical app: fokent render()-t hivja, esetleg az area()-t is. szinten dependal a GUI liben
mivel a Rectangle dependal a GUI liben, a geometry service pedig hasznalja a Rectanglet, ezert a GUI lib valtozasakor a geometry servicet is recompilolni kell, bar az tenylegesen nem hasznalja a GUI libet
Rectanglet kette kellene vagni, az egyik reszben lenne az area() masikban meg a render()

Order class
tulkepp shopping cart, amit egy website es egy point of sale app hasznal
metodusai: checkout(), chargeCard(), notifyCustomer(), reserveInventory()
checkout() hivja a cC()-ot, aztan a rI()-t aztan a nC()-t ha szukseges
nC() dependal SMTP-n, rI() egy InventorySystemen, cC() egy PaymentGW-n
problemak: cash tranzakcioknal nem kell credit card, point of sale tranzakcioknal nem kell inventory reserve se email notif. a notif, credit card processing, inv management bmilyen valtozasa affectalja az Ordert, es azon keresztul a web es point of sale appokat

refactor
respek menten vagjuk szet
ifacek es metodusaik: INotificationService.notifyCustomerOrderCreated(), IReservationService.reserveInventory(), IPaymentProcessor.processCreditCard()
Order szetvagasa tobb classba: 
- OnlineOrder: website csak ezt hasznalja. mindharom ifacen dependal
- PoSCreditOrder: csak IPP ifacen dependal
- PoSCashOrder: egyik ifacen sem dependal
Order class abstract, fieldje a Cart, es csak a checkout() metodus van benne (ami h DB-be loggol). Ordert extendalja a fenti harom konkret order class, ezekben vannak a dependenciak az ifacekre
OnlineOrder.checkout() { pP.pCC(cart.amount); rS.rI(cart.items); nS.nCOC(cart); super.checkout();
PoSCreditOrder.checkout() { pP.pCC(cart.amount); super.checkout();
PosCashOrder: konstruktoraban super(cart), a base class hajtja vegre a checkoutot
pl. NC valtozasa most mar csak az OnlineOrdert affectalja, a PoS-ra nincs hatassal

resp: reason to change. "a difference in usage scenarios from the clients perspective" (?)
tobb kis iface (ld. ISP) segitsegevel elerheto az SRP 

SRP: coupling--, cohesion++
tobb kisebb class distinct respekkel => design flex++ (if,switch,branching--)

===
[The Open / Closed Principle]

OCP: sw entities (class,module,func etc) should be open for ext but closed for modif
"open chest surgery is not needed when putting on a coat"
hasonloan, amikor extendaljuk a swunket akkor nem kellene belenyulnunk az internaljaiba ahhoz h megvaltoztassuk a behaviourjet. tudnunk kellene uj classokat/funcokat hozzaadnunk anelkul h az existing classokat/funcokat valtoztatnunk kellene

open to ext: new behaviour can be added in to future
closed to modif: changes to source or binary not required (nem kell recompile)

behav change code change nelkul hogyan?
rely on abstractions. minden abstrt tetszoleges szamu modon tudunk impl, ezaltal tetszoleges modon valtoztatni az abstractionoket hasznalo codeok behavjet

demo
public class OrderItem { private String sku (stock keeping unit); private int quantity;
public class Cart { 
  private List<OrderItem> items; 
  public double totalAmount() { double total = 0; for(items) { if(item.sku == EACH) total +=item.quantity * 5; else if(item.skup == WEIGHT) total += ... ; return total;
tovabbi sku-k varhatoak es jo lenne ha nem kellene tovabbi else-if agakat hozzaadni (~ne kelljen surgeryt vegrehajtani)
minden change bugokat okozhat; egy ponton torteno valtoztatas vegigcascadeolhat az egesz appon
ha kovetjuk az OCP-t akkor uj behaviour hozzaadasa jellemzoen uj class(oka)t jelent; ezeken meg semmi nem dependal es nincsenek legacy couplingjaik

OCP achieve approachok
- parameterek (procedural prg): appunk/classunk/metodusunk paramo(ka)t exposol es a client controllalja a behaviort ezek segitsegevel. lambdakat hasznalva nagyon hatekony lehet. pl. prg ami leszedi egy digital camerarol a fileokat es lementi drivera "Steve pictures" folderbe. ha a foldernev bele van egetve a prgba akkor az csak Steve nevu emberekhez passzol, megvaltoztatni viszont csak a source modositasaval es ujrabuildelessel lehet. ha command line paramkent adhato meg akkor fel lehet parameterezni az adott user nevenek megfeleloen
- inheritance/template method pattern: default behaviour root classban (altalaban vmi stepek listaja) child classokban ez overridolhato
- composition/strategy pattern: client depends on abstraction. plugin model, a tenyleges behavot definialo classt injektaljuk a workot vegzo masikba. az implk inheritancet hasznalnak (base class, iface), a client viszont compositiont (??)

demo refactor
public interface IPricingCalculatror { double calculatePrice(OrderItem item);
public class Cart { 
  private List<OrderItem> items; 
  private IPricingCalculator pricingCalculator;
  public Cart(IPricingCalculator pricingCalculator) { this.pricingCalculator = pricingCalculator; }
  public double totalAmount() { double total = 0; for(items) { total += pricingCalculator.calculatePrice(item); return total;
public class PricingCalculator implements IPricingCalculator { 
  private List<IPriceRule> pricingRules; 
  public PricingCalculator() { pricingRules.add(new EachRule()); pricingRules.add(new WeightRule())...
  public double calculatePrice(OrderItem item) { return pricingRules(isMatch(item)).calculatePrice(item);
public interface IPriceRule { boolean isMatch(OrderItem item); boolean calculatePrice(OrderItem item); //ide abstractoltuk ki a totalAmount()-ban torteno skuellenorzest es a total novelest
public class EachRule implements IPriceRule { public boolean isMatch(OrderItem item) { return item.sku == EACH; } public double calculatePrice(OrderItem item) { return item.quantity * 5; 
tobbi rule impl uigy. ha uj rulet akarunk hozzaadni akkor csak uj ...Rule impl IPriceRule classt kell felvennunk, es hozzaadni a PricingCalculator.pricingRules listahoz. a Carthoz nem kell hozzanyulnunk

mikor hasznaljunk OCP-t
ne rakjuk tele premature abstractionokkel a kodot, mert az ugy szuksegtelenul komplex lehet
ha a problem domainnel kapcs tapasztalatbol tudjuk h egy adott jellegu change ismetlodhet, akkor mar a design soran hasznalhatjuk az OCP-t
ha nincs ilyen tapasztalatunk: "fool me once shame on you, fool me twice shame on me". eloszor kodoljuk le a simplest-that-works megoldast hardcodeokkal, if-ekkel es legyenek tesztek. ha egy valtozas tortenik, azt fogadjuk el. de ha masodszor is megvaltozik uugy akkor refactoraljuk OCP-re
TANSTAAFL: There Aint No Such Thing As A Free Lunch. az OCP komplexitast hoz a designba, vmint legyunk tudataban h nincs olyan design ami minden valtozasra closed tudna lenni. tehat probaljuk csakkor hasznalni ha varhatoan kifizetodik
OCP flex++, reusability++, maintaibility++

===
[The Liskov Substitution Principle]
LSP: subtypes must be substituable for their base types
"if it looks like a duck, quacks like a duck but needs batteries - you probably have the wrong abstraction". rubberduck-is-a-duck, de nem behelyettesitheto minndenhova ahol tenyleges duckra van szuksegunk

substitutability: child class ne removoljon behaviourt a base classbol es ne violalja a base class invariantjait
a hivo kodnak nem kell tudnia h a base type es a derived type kozott bmilyen kulonbseg van

inheritance/is-a
alap OOP: child class es base class kozti kapcsolat. Employee-is-a-Person, Square-is-a-Shape, Car-is-a-Vehicle
LSP: is-a helyett is-substitutable-for

invariants
a classaink altal reprezentalt model integritasat fejezik ki
resonable assumptions of behaviour by clients
gyakran metodus pre/postcondokkal fejezhetoek ki es "not necessarily indicated within the code"
gyakran a unit testek specifyoljak a metodus/class behaviorjet, es el kell torniuk ha subtype violalja az invariantot es ezaltal megvaltozik a behav
design by contract: technika amivel expliciten magaban a kodban lehet definialni a pre/postcondokat
LSP kovetesehez a derived classoknak nem szabad violalnia a base classra definialt (v a clientek altal feltetelezett) constrainteket 

demo
class Rectangle { int height; int width;
class Square extends Rectangle { 
  void setWidth(int value) { width = value; height = value; //egyformara allitja be a kettot
  void setHeight(int value) { width = value; height = value; //egyformara allitja be a kettot
class AreaCalculator { 
  int calculateArea(Rectangle r) { return r.height * r.width;
  int calculateArea(Square s) { return s.height * s.height; //heightet szorozza onmagaval

tesztek: 
myRec = new Rectangle(2,3); AC.calculateArea(myRec) == 6 OK
mySq = new Square(3); AC.calculateArea(mySq) == 9 OK
Rectangle newRec = new Square(); newRec.width = 4; newRec.height = 5; AC.calculateArea(newRec) == 20; NOK, mert az igy definialt Square nem substitutable Rectangle-re (az eredmeny 25 lesz). a Rectanglere von invariant az h a widthet es a heightet tudnunk kellene egymastol fgtlul besettelni, es a Square ezt violalja
ezenkivul az AC violalja a tell-dont-ask principlet; mert megkerdezi a paramjat (Rectangle r) a heightjerol/widthjerol es vmi muveletet (jelen esetben egy szorzast) hajt rajta vegre. ilyen modon a behav decouplolodik a statetol: a state (width,height) a rectangleben van, a behav (area calculation) viszont az AC-ben. vmint a cohesion is serul mert olyan operek amelyek egyebkent teljesen a rectanglen dependalnak (calculateArea()) igy egy separate classban vannak
ehelyett a rectanglenek kellene megcsinalnia az area calcot az internaljait felhasznalva (meg ha lehetne amellett is ervelni h az meg ugy az SRP-t violalja)

abstract class Shape {}
class Rectangle extends Shape { int height; int width; int area() { return height * width;
class Square extends Shape { int side; int area() { return side * side;
a square es a rectangle kozt nincs is-a kapcs!

a harmadik teszt ujra
shapes = new List<Shape> { new Rectangle(4,5); new Square(3); } areas = new List<Integer>; 
foreach(shape) { if(shape instanceof Rectangle) areas.add((Rectangle) shape).area(); if(shape instanceof Square)...
mukodik, de nem maintainable. ha uj Triangle extends Shape classt veszunk fel, akkor uj if(shape instanceof Triangle) ag kell stb. ez igy OCP violation (es nem csak itt a tesztben hanem mindenhol ahol ilyen jellegu kodreszlet van)

LSP violation smells
1) foreach(employees) if(emp is Manager) printer.printManager(emp); else printer.printEmployee(emp)... tovabbi tipusoknal tovabb bovulne, maint--
jobb lenne ha a Manager tudna hogyan printelje onmagat v csak egy darab print() metodus lenne, h ne kelljen ilyen ifet haszn
2) child nem teljesen impl a baset
abstract class Base { abstract void method1(); abstract void method2();
class Child extends Base { void method1() { throw new NotImplementedException(); } void method2() { ... }
ha egy kulso kliens teljes implra szamit, akkor ez problema lehet
ISP: hasznaljunk kicsi ifaceket h a classoknak ne kelljen annal tobbet impl mint amire szukseguk van

refactor
elozo mo-ban az area() nem volt benne az abstract shapeben es igy belefutottunk a tesztnel jelzett problemaba
abstract class Shape { abstract int area(); }
rectangle-ben es square-ben az area() overridolva
harmadik teszt egyszeruen: foreach(shape) areas.add(shape.area());
es felvehetunk uj shape-child classokat anelkul h ezt valtoztatni kellene

LSP tips
- tell don't ask (move area() to rectangle)
- ha van ket classunk amik behavot sharelnek de nem substitutablek, akkor krealjunk egy harmadik classt amit mindketten extendalnak, es biztositsuk a substitutabilityt az egyes child classok es az uj base kozott (rectangle, square + shape)

LSP polimorf++, maint++

===
[The Interface Segregation Principle]
ISP: clients shouldnt be forced to depend on methods they do not use
fat ifacek helyett kis, cohesive ifacek
USB csatlakozot szeretnenk bedugni valami devicebe amin van egy csomo kapcsolo, lampa, meg tobbek kozott USB portok is: "you want me to plug this in, where?"

"iface"
egyreszt az interface mint implhato type (pl. public interface IDoSomething)
masreszt egy class public iface-e az amit kifele mutat a klienseinek (public propertyk, metodusok). nem biztos h egy adott clientnek ebbol mindenre szuksege van; pl. komplex class v hierarchia ele facadet huzunk ami csak a client szamara szukseges reszeket mutatja kifele

demo (ASP.NET fwbol)
interface MembershipProvider //fat interface
class CustomMembershipProvider implements MembershipProvider
class LoginControl {
  private MembershipProvider membershipProvider;
  void authenticateUsingMembershipProvider() { LoginUtil.getProvider(this.membershipProvider).validateUser(user, password);
LoginControl csak ezt az egy validateUser() metodust hasznalja a MembershipProviderbol. a beinjektalt konkret CustomMembershipProvider classnak megis az osszes metodust impl kell. jobb lenne ha egy IValidateUser ifacet hasznalhatnank amiben csak ez az egy metodus van

class AboutPage {
  ConfigurationSettings settings;
  void render(TextWriter writer) { writer.write("{} {}", settings.AppName, settings.AuthorName); }
class ConfigurationSettings { //tobb fieldje van, tobbek kozt az AppName es AuthorName (emellett DB,cache stb.) es app.config filebol populalja oket
teszt: aboutPage = new AboutPage(); textWriter = new StringWriter(); aboutPage.render(textWriter); assert("Steve Smith", output);
ez igy OK, de ha az app.configban az AppName=Steve Smith-t atirom, akkor a teszt eltorik. emellett az app.configben levo osszes tobbi propertyt is ki kell tolteni h a ConfigurationSettings mukodjon, azoknak pedig ehhez a renderhez semmi koze

ISP viol: client classnak csak egy-ket dologra van szukseges, de egy fat ifacet kell hasznalnia amiben meg van harminc masik szamara irrelevans dolog
coupling++, flex/maint--

refactor
class AboutPage {
  IConfigurationSettings settings;
  public AboutPage(IConfigurationSettings settings) { this.settings = settings; }
  public AboutPage() { this(ConfigurationSettings.settings); } //param nelkuli konstr, fallback a fat classra
  void render(TextWriter writer) { writer.write("{} {}", settings.AppName, settings.AuthorName); }
interface IConfigurationSettings { string AppName; string authorName; ... //es a tobbi DB,cache stb related fieldek + getterek
class ConfigurationSettings implements IConfigurationSettings { ... //fat class is impl az uj ifaceunket

a fenti teszt metodus tovabbra is mukodik, de most mar krealhatunk sajat config class instanceot a teszthez amiben csak a ket szamunkra relevans metodus van tenylegesen impl, a tobbi pedig NotImplementedException-nal
class Settings implements IConfigurationSettings { String getAppName { return "test app name"; } String getAuthorName { return "test author name" }
uj teszt: aboutPage = new AboutPage(new Settings()); textWriter = new StringWriter(); aboutPage.render(textWriter); assert("test author name", output);
ez igy mar nem dependal a config.app fileon

de ezzel meg nem szegregaltunk, csak a fat CS classbol csinaltunk egy meg mindig fat ICS ifacet
class AboutPage {
  IApplicationIdentitySettings settings;
  public AboutPage(IApplicationIdentitySettings settings) { this.settings = settings; }
  public AboutPage() { this(ConfigurationSettings.settings); } 
  void render(TextWriter writer) { writer.write("{} {}", settings.AppName, settings.AuthorName); }
interface IApplicationIdentitySettings { string AppName; string authorName; //csak ez a ket field + gettereik
interface IConfigurationSettings extends IApplicationIdentitySettings { //a tobbi field + gettereik. igy az AboutPage() param nelkuli konstr is mukodokepes marad
teszteknel annyit kell modositani h class Settings implements IApplicationIdentitySettings es tovabbra is mukodnek

ISP smells
unimplemented iface metodusok (throw new NotImplementedException()). ez LSP viol is, ld.fentebb
client egy classnak csak egy reszet hasznalja (erre ld. facade mo fentebb)

mikor javitsuk az ISP violt?
once there is pain
ha eszrevesszuk h egy olyan fat ifacen dependalunk amit mi ownolunk: krealjunk egy kisebb ifacet ami csak azt tart amire szuksegunk van; a fat iface impl ezt az uj ifacet; a kodunkbol hasznaljuk az uj ifacet
ha eszrevesszuk h egy olyan fat ifacen dependalunk amit nem mi ownolunk (ld. MembershipProvider): krealjunk egy kisebb ifacet ami csak azt tart amire szuksegunk van; impl ezt az ifacet egy adaptert hasznalva ami a teljes ifacet impl (??). ekkor az adapter ott lesz koztunk es a 3rd party code kozott

iface legyen kicsi, cohesive, focused
ha lehetseges hagyjuk h a client definialja az ifacet (o tudja h mire van szuksege)
ha lehetseges packagoljuk ossze az ifacet a clienttel. esetleg packagoljuk egy masik csomagba amin a client es az impl is dependal. csak utolso lehetosegkent packagoljuk ossze az ifacet es az implt

===
[The Dependency Inversion Principle]
DIP: high level modules should not depend on low-level modules; both should depend on abstractions. abstractions should not depend on details, details should depend on abstractions
"would you solder (forraszt) a lamp directly to the electrical wiring in the wall?". letezik egy common iface, a dugo aminek segitsegevel bmilyen eszkozt be tudunk dugni ami azt implja. ha a classunk a dependenciait ifacek formajaban exposolja, akkor at tudunk neki adni konkret implkat, amelyek ezeket az ifaceket impljak

mik azok a dependenciak? (.NET) framework, 3rd party lib, DB, filesys, email, web service, system rsc (pl. clock), config, new keyword, static metodusok, Thread.sleep(), Random stb.

traditional prging
high level modulok hivjak a low level modulokat
UI dependal a business logicon (Customer, Order stb.), az dependal infrastructureon, utilityn (logger stb), data accessen 
static metodusok hasznalata convenience okbol v facade layerkent
class instantiation/call stack logic szetscatterelve az appban: SRP viol, mert a new-t kiado class nem csak a sajat actual feladataert resp, hanem azert is h kivel dolgozik egyutt

class depek: be honest! 
konstruktoroknak at kell vennie a depeket amire a classnak szuksege van: explicit depek
azoknak a classoknak amik ezt nem teszik meg, implicit/hidden depjeik vannak. ok hazudnak, mert azt allitjak h anelkul tudjuk oket instanceolni h bmit atadnank neki, holott valojaban szukseguk van pl. a DB-re
class HelloWorldHidden { public String hello(String name) { if(DateTime.Now.Hour < 12) return "good morning" else return "good afternoon";
hidden dep a DateTime-ra. OCP viol, mert nem tudjuk anelkul modositani h belenyulnank. tesztelni csak ugy tudjuk ha 12 ora elott/utan futtatjuk
helyette
class HelloWorldExplicit { private DateTime time; HelloWorldExplicit(DateTime time) { this.time = time; } public String hello(String name) { if(time.Hour < 12) return "good morning"... }
ha csak egy metodus hasznalja a DateTime-ot, akkor eleg annak atadni, nem kell a konstruktornak. value obj (DateTime) helyett adhatunk be ifacet (pl. ICalendar) is ami DateTime-t tud returnolni, es annak aztan csinalhatunk klf implkat, pl. a teszteleshez olyanokat amik fake 12 elotti/utani idopontokat tudnak visszaadni

demo
class Order
  void checkout(Cart cart, PaymentDetails paymentDetails, bool notifyCustomer) { if(paymentDetails.method = CC) chargeCard(paymentDetails, cart); reserveInventory(cart); if(notifyCustomer) notifyCustomer(cart);
nincs konstr, es magaban a checkout() metodusban sincsenek explicit depek (new, static metodusok). de az altala hivott notifyCustomer() stb metodusokban mar van new SmtpClient(), Logger stb

ha teszteni akarjuk az Order classt akkor problemas injektalni a depeket
order = new Order(); cart = new Cart(); paymentDetails = new PaymentDetails(CASH); shouldNotifyCustomer = false; order.checkout(cart, paymentDetails, shouldNotifyCustomer);
ez meg lefut
order = new Order(); cart = new Cart(email = someone@somewhere.com; ); paymentDetails = new PaymentDetails(CASH); shouldNotifyCustomer = true; order.checkout(cart, paymentDetails, shouldNotifyCustomer);
ez viszont egy sima dev gepen exception ha ott nincs felkonfiguralt SmtpClient
korbe lehetne hackelni h a notifyCustomer()-ben csekkelje h real vagy teszt envben vagyunk-e, es a teszt envre felhuzni vmi fake SMTP szervert, de az mar integracios teszt. mi most csak arra lennenk kivancsiak h ha a notifyCustomer = true akkor a notifyCustomer() meghivodik-e
Orderben hidden depek vannak: SmtpClient, PaymentGW, Logger stb. emiatt tight coupling, impl detaileket nem tudjuk valtoztatni (OCP viol), nehez tesztelni

dep inj: technique that is used to allow calling code to inject the deps a class needs when it is instantiated
Hollywood principle: don't call us we'll call you. nem a mi classunk vegzi a peldanyositast, hanem azt mondjuk h szuksegunk van egy notif servicere, es majd azt meg fogjuk hivni az ifacen keresztul
modjai: constr inj, property/setter inj, param inj. mas modok pl. service location, de azokkal most nem fogl
- constr inj (strategy pattern)
pro: classok onmaguk dokumentaljak h mire van szukseguk; containerrel v anelkul is mukodik; classok rogton valid stateben vannak miutan megkrealodtak
con: tul sok dep = tul sok param (design smell); egyes featureok (pl. serialization) miatt default param nelkuli konstr is szukseges lehet; egyes metodusoknak minden depre szukseguk van, masoknak csak bizonyosakra (design smell, nem eleg cohesive a class?)
- property/setter inj
pro: depek az obj lifecycle soran bmikor valtoztathatoak; flexible
con: obj a konstr es a setterek hivasa kozott invalid stateben van (hacsak a konstr nem hivja a settereket); kevesbe intuitiv (nem latszik egybol h mik a szukseges depek, esetleg milyen sorrendben kell besettelni oket)
- param inj: depek metodus paramokkent atadva
pro: leggranularisabb; flexible; a class tobbi reszet nem kell valtoztatni
con: plusz paramok breakelik a metodus signaturet (ha sok helyrol hivjak a metodust akkor uj param hozzaadasakor mindenhol modositani kell); tul sok dep = tul sok param (design smell)
akkor haszn ha csak az az egy metodus hasznalja a depet, egyebkent constr inj jobb

refactor
extract deps to ifaces; inject iface impls into Order; Order resp-- (SRP)

uj iface es impl
public interface INotifyCustomer { void notifyCustomer(Cart cart); }
class NotifyCustomer implements INotifyCustomer { void notifyCustomer(Cart cart) {//ide az eddigi impl} } 

uj konstr. a paramokat class fieldekkent is felvesszuk, pl. INotifyCustomer notifyCustomer;
public Order(Cart cart, PaymentDetails paymentDetails, INotifyCustomer notifyCustomer...) { this.notifyCustomer = notifyCustomer; ...

es a checkout()-bol az iface tipusu class fieldeken hivunk ra a metodusokra: notifyCustomer.notifyCustomer(cart);
ezzel megszuntettuk h az Order dependaljon az SMTP-re

uigy ki lehet extractolni az inv reservationt es a paymentprocessort; es aztan felepiteni az SRP-nel latott OnlineOrder extends Order es a tobbit
OnlineOrder.checkout() { pP.pCC(cart.amount); rS.rI(cart.items); nS.nCOC(cart); super.checkout();
igy minden dep a konstrn keresztul jon be, a tesztekhez pedig konnyen krealhatunk FakeNotificationService es tovabbi fake implkat amiket aztan beinjektalhatunk az Orderbe
cart = new Cart(); paymentDetails = new PaymentDetails(CASH); order = new OnlineOrder(cart, paymentDetails, fakePP, fakeRS, fakeNS); order.checkout(); assertTrue(fakePP.wasCalled); assertEquals(cart.amount, fakePP.amountPassed); //wasAmount es az amountPassed a fakePP-ben altalunk a teszt celjaira definialt fieldek
es az a teszt is atmegy ahol a NS valodi: cart = new Cart(email = someone@somewhere.com); paymentDetails = new PaymentDetails(CASH); order = new OnlineOrder(cart, paymentDetails, fakePP, fakeRS, NS); order.checkout(); 
mar az OnlineOrder konstruktoranak paramjaibol latszik h mik az o required depjei

DIP smells
new keyword hasznalata
static metodusok/propertyk hasznalata 
- DateTime.Now.toString(); helyette ICalendar/IDateTime iface amiben van Now metodus
- DataAccess.saveCustomer(myCustomer): DB-be ment, ezaltal dep van a DB-re
ez persze csak az olyan staticokra von amik belul mas classokat peldanyositanak, es ezaltal depeket hoznak letre; az olyan static metodus ami csak az input adataival dolgozik, pl. osszead ket szamot, az nem jelent ilyen problemat

hol kell az objkat peldanyositani?
default constr: default implkat providol a dep ifacekhez. (pl. egy olyan ami new NotificationService()-t peldanyosit az INotificationService-hez) ("poor man's DI/IoC")
main: kezzel peldanyositunk mindent a startup soran
IoC container: obj graf peldanyositas. app startup soran; code v config (xml) def alapjan. a managed ifaceket es implkat registralni kell a containerben ("mindenutt ahol INS-t latok, ott egy new NS()-t akarok hasznalni"). a depek a startup/runtime soran resolvalodnak

layered/tiered app design
separate logical (neha physical) layerek: UI, business (BLL), data access (DAL)
encapst/abstractiont jol tam: megfelelo abstr szint; idealis esetben minden level csak az egy szinttel lejjebbi levelt ismeri, igy kiswappolhatoak
alt a legalso szintek a leginkabb reusablek

traditional/naiv layered ach
UI - BLL - DAL, Common - DB, Services
igy pl. a BLL dependal a DB-n is es nem lehet anelkul tesztelni

inverted arch
legalul az obj model (core domain objk), folotte a business logic (services); ez a ketto egybe is lehet packagelve. az o depjeik ifacek kell legyenek
folottuk, orajtuk dependalva a data access, UI, tests, IO, web services
DB, services es egyeb infrastructurek "oldalt": data access dependal a DB-n, web services dependal a services-en; de a business logic nem dependal rajtuk, igy tehat pl. a business logic tesztelese lehetseges a DB nelkul is (tests -> business logic dep; de business logic -> DB nem dep!)

demo
NTierWeb -> NTierBLL -> NTierDAL -> Externals
teszt: validEmail = ...; validPassword = ...; validUserId = ...; result = BLL.Security.Login(validEmail, validPassword); assertEquals(validUserId, result);
ez static metodushivas + DAL-on/externalon dep: teszt elhasal mert nem talal meg valamit lejjebb, ahol a DAL az SQL-eket hivogatja. pedig ez unit test, ahol csak a BLL funct akarnam tesztelni, fgtl attol h mi van alatta
amikor ezt a peldaprojektet csinalta akkor azt akarta demozni h a DAL layert h lehet kiswappolni egy masik DAL2-re (ami real DB helyett mondjuk filebol dolgozik); akkor meg nem ismerte a DIP-t es a kodban minden helyen at kellett irnia a DAL-t DAL2-re (OCP viol)

problema: depek vannak az infrastr-ra (DB, xml configok). core/business/domain classok az impl detaileken dependalnak; es ha ezek az implk megvalt, akkor nekunk is meg kell valt a business layerunket, recompilolni stb. (OCP viol). tight coupling a BLL es a DAL/infrastr kozott. nehez/nem lehet izolaltan tesztelni

dep tranzitiv: UI dep a BLL-en, az dep a DAL-on, az dep a DB-n => minden dep a DB-n
helyette DIP: depend on abstractions (felkeszulunk arra h valtozasok lehetnek az appban)
ifaceket (abstractionokat) az oket hasznalo clienttel (ez esetben a BLL) packageljuk ossze: ISP
projectet ugy strukturaljuk h a core/BLL legyen a dep hier kozeppontban/legalul, es minel kevesebb depje legyen, es ne depeljen externalokon

refactor
BLL.Security.Login() metodus a tovabbiakban ne legyen static. a hivasok a tovabbiakban new BLL.Security().Login(...)
uj iface: BLL.IUserRepository { int getByEmailPassword(String email, String password);
uj konstruktor: public Security(IUserRepository userRepository) { this.userRepository = userRepository; }
BLL.Security.Login() { userRepository.getByEmailPassword(email, password); //eddig a DAL.Security.Login()-t hivta, abban vannak az SQL commandok
class SqlUserRepository implements IUserRepository {} //ez egy uj NTier.Data.Sql-be kerul, ami dependal az NTier.BLL-en
class FakeUserRepository implements IUserRepository { int getByEmailPassword(email, password) { //...return valid id; } }
hivas az appbol mindenhol: new Security(new SqlUserRepository()); a tesztbol: new Security(new FakeUserRepository()); //eredetileg default konstruktorral akarta, amiben this(new SqlUserRepository()) van, de vmi .NET package-szerkezeti ok miatt nem tudta; de ez egyebkent lenyegeben a fent leirt poor man's IoC
BLL.Security-ben most mar nincs new-zas/static metodushivas, a hivo mondja meg h milyen UserRepository instance lesz ide beinjektalva (azaz invertaltuk a dependencyt)

a refactor utan: NTierWeb -> NTierDataSql -> NTierBLL
BLL mar nem dependal az infrastructureon. igy a unit testek sem dependalnak ra, es lehet isolationban tesztelni